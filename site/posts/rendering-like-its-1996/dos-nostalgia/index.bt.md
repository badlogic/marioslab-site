{{
metadata = {
	title: "Rendering like it's 1996 - Fixed-width bitmap fonts and DOS",
	summary: "On drawing fixed-width bitmap fonts and get all of this running in DOS.",
	image: "dos-nostalgia.png",
	date: parseDate("2022/12/7 21:00"),
	published: false,
}
}}

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}
{{include "../_demo.bt.html" as demo}}

{{post.figure("dos-nostalgia.png", "This screen has burned itself into my retina.")}}

<div class="table_of_contents"></div>

--markdown-begin

[Last time](../blistering-fast-blits/), we implemented loading files on the desktop and web, load images through the fabulous [sbt_image](https://github.com/nothings/stb), and implemented blitting, the process of copying one image onto another. We also did some performance work, looking at control flow graphs. That was over 2 weeks ago, making me miss my target of posting one series entry a week. But there's a reason for it! I was rather busy in those two weeks.

After using Hopper to generate control flow graphs to discuss performance optimization, I got a little sick of the workflow and built my own [assembly CFG viewer](https://marioslab.io/projects/cfg/). Just paste some x86 or ARM assembly generated by MSVC, Clang, or GCC into it, and view the control flow graph of each function on the right. I even made a [re-usable NPM package](https://www.npmjs.com/package/@marioslab/asmcfg) out of it. Going forward, we'll have embedded pannable/zoomable SVG CFGs in this blog post series. Yay.

Then I drifted off into yet another rabbit hole. Spurred by a mean comment on Reddit about how this series doesn't even run on DOS, I made the code of the series run on DOS.

First, I built a [DOS backend for minifb](https://github.com/emoon/minifb/pull/98). Then, I [forked an old GDB version](https://github.com/badlogic/gdb-7.1a-djgpp/releases/tag/gdb-7.1a-djgpp) which is capable of remotely debugging 32-bit protected mode DOS programs as produced by [DJGPP](https://www.delorie.com/djgpp/), the GCC fork I use to build C/C++ DOS programs. I also forked [DOSBox-x](https://github.com/badlogic/dosbox-x/) to fix it up so my forked GDB can actually connect to DOS programs via the serial port TCP emulation.

Finally, I took the non-functional [GDB stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html) that comes with DJGPP, rewrote it and added a ton of functionality to it, so I can now debug DOS programs running in DOSBox-x from the comforts of Visual Studio Code.

All of that work culminated in a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=badlogicgames.dos-dev), which lets you go from 0 to debugging a simple DOS mode 13h demo app in VS code in about 80 seconds.

<img src="vsc-extension.gif" style="max-width: 100%"></img>

Anyways, today we're going to look into two things:

* Running `r96` in DOS.
* Fixed-width bitmap font rendering.

> You can follow along by checking out the `dos-nostalgia-00` tag in your clone of the [r96](https://github.com/badlogic/r96) repository. `git pull && git checkout dos-nostalgia-00`

## Automated tools installation and launch configs
I realize that setting up the development environment to get this series' code running may be daunting to some. It doesn't get any better by adding DOS as a supported platform. So I made it really easy (tm).

Here's how it works now. First, install these things:

* [Visual Studio Code](https://code.visualstudio.com/)
	* Make sure you can execute `code` on the command line. This works out of the box on Windows and Linux. On macOS, open VS Code, press `CMD+SHIFT+P` on macOS), enter `Shell Command: Install 'code' command in PATH`, and press enter.
* **Windows**
    * [Git for Windows](https://git-scm.com/download/win). Make sure its available on the command line via the system PATH.
    * [Visual Studio with C++ support](https://visualstudio.microsoft.com/vs/features/cplusplus/)
* **macOS**
    * [XCode](https://developer.apple.com/xcode/). Make sure to also install the [command line tools](https://mac.install.guide/commandlinetools/4.html)
* **Linux**
    * Git, [GCC](https://gcc.gnu.org/), [GDB](https://www.sourceware.org/gdb/), Python, and x11-dev E.g. Ubuntu/Debian: `sudo apt install git gcc gdb python x11-dev`

Next, run the `tools/download-tools.sh` script in Bash (Git Bash on Windows). That's it. You are now all set-up to compile the `r96` code and demos for desktop, web, and DOS!

I've compiled an extensive [README.md](https://github.com/badlogic/r96/blob/main/README.md) that walks you through building, running, and debugging the project both in VS Code as well as on the command line.

The gist of running and debugging is:
* It the status bar, using the CMake tools entries:
	* Select the CMake `Debug` or `Release` variant depending on whether you want to debug or not.
	* Select the toolchain for the platform you want to run on:
		* MSVC, Clang, or GCC for Windows, Linux, macOS.
		* Emscripten for web
		* djgpp for DOS
* Run the launch configuration for the platform:
	* `Desktop run target` for desktop
	* `Web run target` for web
	* `DOS debug target` for DOS debugging
	* `DOS run target` for DOS without debugging

The launch configurations will build any changed source code before running. In general, you'll likely work on a specific platform for a while. That means you can fix all of the above and just press `F5` to start debugging/running after a code change.

> **Note:** really do read the [README.md](https://github.com/badlogic/r96/blob/main/README.md) file. I will not re-iterate how to build, run and debug the `r96` demos in detail here.

## Demo: Hello DOS
Assuming you've followed the tools installation in the last section and have read the [README.md](https://github.com/badlogic/r96/blob/main/README.md) to get to know how to build and debug/run `r96` for different platforms, we can add a worthy little demo to run on the desktop, web, and DOS! I called it [`12_hello_dos.c`](https://github.com/badlogic/r96/blob/main/src/12_hello_dos.c):

--markdown-end
{{post.code("12_hello_dos.c", "c",
`
#include <MiniFB.h>
#include <stdio.h>
#include "r96/r96.h"
#include "stdlib.h"
#include <math.h>

#define GDB_IMPLEMENTATION
#include "dos/gdbstub.h"

#define num_grunts 100

typedef struct grunt {
	int x, y, vx, vy;
} grunt;

int main(void) {
	gdb_start();
	r96_image image;
	if (!r96_image_init_from_file(&image, "assets/grunt.png")) {
		printf("Couldn't load file 'assets/grunt.png'\n");
		return -1;
	}

	r96_image output;
	r96_image_init(&output, 320, 240);
	struct mfb_window *window = mfb_open("12_hello_dos", output.width, output.height);

	grunt grunts[num_grunts];
	for (int i = 0; i < num_grunts; i++) {
		grunt *grunt = &grunts[i];
		grunt->x = rand() % 320;
		grunt->y = rand() % 200;
		grunt->vx = 1;
		grunt->vy = 1;
	}
	do {
		r96_clear_with_color(&output, 0xff222222);
		for (int i = 0; i < num_grunts; i++) {
			grunt *grunt = &grunts[i];
			if (grunt->x < 0) {
				grunt->x = 0;
				grunt->vx = -grunt->vx;
			}
			if (grunt->x > 320 - 64) {
				grunt->x = 320 - 64;
				grunt->vx = -grunt->vx;
			}
			if (grunt->y < 0) {
				grunt->y = 0;
				grunt->vy = -grunt->vy;
			}
			if (grunt->y > 240 - 64) {
				grunt->y = 240 - 64;
				grunt->vy = -grunt->vy;
			}
			grunt->x += grunt->vx;
			grunt->y += grunt->vy;
			r96_blit_keyed(&output, &image, grunt->x, grunt->y, 0x00000000);
		}
		if (mfb_update_ex(window, output.pixels, output.width, output.height) != STATE_OK) break;
		gdb_checkpoint();
	} while (mfb_wait_sync(window));

	r96_image_dispose(&image);
	r96_image_dispose(&output);
	return 0;
}
`)}}
--markdown-begin

This is actually our first animated demo! We'll have a dedicated blog post on animation in the future, so I'll just glance over the details for now.

The demo draws 100 grunts each stored in a `grunt` struct. The `grunt` struct stores the on-screen position of a grunt (`x`, `y`) as well as its velocity on the x- and y-axis (`vx`, `vy`) in pixels per frame.

The grunts get initialized with random positions. The velocity is set to `(1, 1)` so they'll start out moving one pixel to the right and one pixel downwards every frame.

In each iteration of the main loop, we update the grunts. The iteration is said to generate a frame, both visually and in terms of simulating the behavior of our grunts.

If a grunt goes outside the screen bounds, we invert their velocity on that bound, and make sure their position is reset to be inside the bounds again. Once all those checks are done, we update the grunt's position by its velocity and blit it.

Depending on how fast our system is, the grunts will move at different speeds. E.g. on the desktop and web, the call to `mfb_wait_sync()` synchronizes our main loop with the display refresh rate. On a display with a 60Hz refresh rate, our main loop is thus executed 60 times, meaning our grunts will move 60 pixels every second. On a display with 120Hz refresh rate, the main loop will be executed 120 times, thus the grunts move 120 pixels every second, and so on.

For a game, that's not great: different players will experience the game at different speeds, depending on their hardware. We'll look into this issue in a future series entry.

> **Note:** Many old DOS games actually did have this problem: they would not take into account how much time has passed since the last frame, but instead update game object positions at a fixed rate each frame. There's a reason Wikipedia has an entry on the notorious [PC turbo button](https://en.wikipedia.org/wiki/Turbo_button).

Here's the little demo on the web:

--markdown-end
{{demo.r96Demo("12_hello_dos", false)}}
--markdown-begin

And here it is running in DOSBox-x, telling DOSBox-x to go full speed.

--markdown-end
<video style="margin: auto; max-width: 100%;" src="grunts-dosbox.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

DOSBox-x on my system synchs to 60Hz, while Chrome runs the web demo at 120Hz. In the video above depicting the demo in DOSBox-x, there is some smearing and artifacts. That's mostly due to the MP4 encoding and doesn't look like that when actually running the demo in DOSBox-x on your system.

Is the DOSBox-x performance indicative of performance on old systems? No. DOSBox-x is going full speed, which is way faster than what my old 486 could do. However, you can modify the emulation speed via the DOSBox-x menu `CPU > Emulated CPU speed`. In the following video, I've set the emulated CPU speed to be equivalent to a 486DX2 with 66Mhz:

--markdown-end
<video style="margin: auto; max-width: 100%;" src="grunts-dosbox-486.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

Well, that's more accurate, but still not quite. I've ran the program in [86Box](https://86box.net/) as well by mounting the `r96/build` folder as a CD-ROM. 86Box is as cycle accurate as emulation will get:

--markdown-end
<video style="margin: auto; max-width: 100%;" src="86box.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

Looks like DOSBox-x isn't far off with its emulation. So why is it so slow?

> **Note:** Setting up virtual machine images for 86Box is a bit terrible. I've created 2 images you can download, a [486](https://marioslab.io/dump/dos/86box/486.zip) image and a [Pentium](https://marioslab.io/dump/dos/86box/pentium.zip) image, pre-installed with MS-DOS 6.22, a mouse driver, and a CD-ROM driver. You can run them via `86box -c 486/86box.conf` and `86box -c pentium/86box.conf`. The images also include QBasic 1.1. And [`NIBBLES.BAS`](https://en.wikipedia.org/wiki/Nibbles_(video_game)) and [`GORILLA.BAS`](https://en.wikipedia.org/wiki/Gorillas_(video_game)). Just saying.

## Why is it so slow on a 486?

The biggest reason is that underneath the hood, we use a video mode with 24-bit or 32-bit color depth instead of the more standard 8-bit [mode 13h](https://en.wikipedia.org/wiki/Mode_13h) or derivatives like [Mode X](https://en.wikipedia.org/wiki/Mode_X), used by games like DOOM or Quake.

The minifb DOS backend I wrote uses [VESA](https://en.wikipedia.org/wiki/VESA_BIOS_Extensions) to set a video mode with either 24-bit or 32-bit color depth that is as close to the requested window width and height as possible. minifb assumes 32-bit color depth support, and we won't shoehorn 8-bit support in there, nor will we add 8-bit support to `r96` itself.

This works pretty well from Pentium class machines onwards, if the (emulated) video card supports VESA. Here's the demo on Pentium class hardware in 86Box:

--markdown-end
<video style="margin: auto; max-width: 100%;" src="86box-pentium.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

However, 486 machines are much less capable when it comes to moving a lot of bytes around. Consider the following back of the napkin calculations.

A single grunt is 64x64 pixels, 4 bytes per pixels, or 16384 bytes in total. We draw 100 such grunts each frame, that's over 1.6Mb. Or viewed from another angle: we draw 5.3 320x240 screens worth of grunts every frame! That's nothing on today's hardware or even early 2000s hardware like the Pentium above. But a punny 486 just can't handle that much data.

So what's the solution? One way would be to go 8-bit color depth, but we won't do that as explained above. And even if we did, drawing 100 64x64 grunts per frame is likely still too much to get a steady 30 frames per second.

The other solution: draw less each frame, ideally only touch each on-screen pixel once. Just like Quake and DOOM relied on various techniques like [binary space partitioning](https://twobithistory.org/2019/11/06/doom-bsp.html).

## DOS debugging support: the GDB stub
When we debug the demo on the desktop, the debugger will spawn the demo process and use system APIs to stop, resume, inspect, and otherwise manipulate the process.

For DOS applications running in DOSBox-x or on a real machine, we do not have the luxury of a debugger. Instead, we use a piece of code called [GDB stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html). Here's how that works.

Of note are 3 pieces of code in the demo above, which are no-ops on any platform other than DOS. The first one is in lines 7-8:

```
#define GDB_IMPLEMENTATION
#include "dos/gdbstub.h"
```

This pulls in the [GDB stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html) sources for DOS debugging. The stub's task is it to communicate with the debugger over the serial port, and inform it when the program the stub has been integrated with, has stopped due to a breakpoint, or segfault, or other reason. The stub then waits for commands from the debugger to execute, like setting breakpoints, inspecting memory, stepping, or continuing.

The GDB stub type of debugging is a cooperative debugging  approach. The stub needs to be integrated in the program itself. This explains the other two GDB related lines of code.

The `gdb_start()` function is called at the beginning of `main()`. It waits for the debugger to connect on the serial port. When the debugger tells the stub to continue execution, the stub stops communicating with the debugger for the time being, and gives back control to the program. The stub then waits for a system level signal to be raised, like a breakpoint or segfault, for which the stub has registered handlers. If such a signal happens, the stub will take over control of the program again, and talks to the debugger.

The final GDB related line is `gdb_checkpoint()` in line 61. It is placed at the end of our main loop. This is required so the stub can check if the debugger asked to interrupt the program, in which case the stub will take control of the program again and talk to the debugger.

The interesting part here is that the program that's being debugged does not need to run on the same machine as the debugger. It can be a program in a virtual machine (like VirtualBox) or emulator (like DOSBox-x), which is isolated from the host OS.

The host OS debugger then establishes a connection to the VM or emulator via TCP, and the VM or emulator will then pretend there was some data arriving on a real serial port on the emulated machine.

Another alternative is running the program and integrated GDB stub on a real machine and connecting to it via a real serial cable. Not necessarily something we will do, but it would work.

> **Note:** when debugging the demos compiled for DOS, we'll be using DOSBox-x instead of 86Box. Two reasons: getting data into and out of 86Box is very annoying. And there is no serial port over TCP emulation in 86Box, so the debugger couldn't even connect. It should be possible to hook the debugger up with a program running in MS-DOS or FreeDOS in VirtualBox though.

## Next time on "Mario writes a lot"

Discuss this post on [Twitter]() or [Mastodon]().

--markdown-end
<script>
tableOfContents()
</script>

{{include "../../../_templates/post_footer.bt.html"}}