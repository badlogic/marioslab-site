{{
metadata = {
	title: "Rendering like it's 1996 - Bitmap fonts and DOS",
	summary: "On drawing bitmap fonts and getting all of this running in DOS.",
	image: "dos-nostalgia.png",
	date: parseDate("2022/12/7 21:00"),
	published: false,
}
}}

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}
{{include "../_demo.bt.html" as demo}}

{{post.figure("dos-nostalgia.png", "This screen has burned itself into my retina.")}}

<div class="table_of_contents"></div>

--markdown-begin

[Last time](../blistering-fast-blits/) we learned about loading images and blitting. That was over 2 weeks ago, making me miss my target of posting one series entry a week. But there's a reason for it! I was rather busy in those two weeks.

After using Hopper to generate control flow graphs to discuss performance optimization, I got a little sick of the workflow and built my own [assembly CFG viewer](https://marioslab.io/projects/cfg/). Just paste some x86 or ARM assembly generated by MSVC, Clang, or GCC into the left panel, and view the control flow graph of each function on the right. I also made it a [re-usable NPM package](https://www.npmjs.com/package/@marioslab/asmcfg). Going forward, I can embed those fancy CFGs directly.

Then I drifted off into yet another rabbit hole. Spurred by a mean comment on Reddit about how the `r96` code doesn't even run in DOS, I made the code of the series run in DOS.

First, I built a [DOS backend for MiniFB](https://github.com/emoon/MiniFB/pull/98). Then, I [forked an old GDB version](https://github.com/badlogic/gdb-7.1a-djgpp/releases/tag/gdb-7.1a-djgpp) which is capable of remotely debugging 32-bit protected mode DOS programs as produced by [DJGPP](https://www.delorie.com/djgpp/), the GCC fork I use to build C/C++ DOS programs. I also forked [DOSBox-x](https://github.com/badlogic/dosbox-x/) to fix it up so my forked GDB can actually connect to DOS programs via the serial port/TCP emulation.

Finally, I took the barely functional [GDB stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html) that comes with DJGPP, rewrote it and added a ton of functionality to it, so I can now debug DOS programs running in DOSBox-x from the comforts of Visual Studio Code.

All of that work culminated in a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=badlogicgames.dos-dev), which lets you go from 0 to debugging a simple DOS mode 13h demo app in VS code in about 80 seconds:

<img src="vsc-extension.gif" style="max-width: 100%"></img>

With all of that out of my system, I built some shell scripts that will help you install (almost) all the tools to compile, run, and debug the `r96` project for desktop, web, and DOS. And I added some VS Code magic so you can comfortably start debugging sessions on each platform.

I can now happily continue writing the series. Promise. Unless I'll add Android and iOS support in the future. I currently don't feel that specific masochism piling up inside of me.

Today, we're looking into the new bells and whistles of the `r96` tools setup, check out DOS support, and then load and draw some bitmap fonts.

> You can follow along by checking out the `dos-nostalgia-00` tag in your clone of the [r96](https://github.com/badlogic/r96) repository. `git pull && git checkout dos-nostalgia-00`

## Automated tools installation and launch configs
I realize that setting up the development environment to get this series' code running may be daunting to some. It doesn't get any better by adding DOS as a supported platform. So I made it really easy (tm).

Please hop over to GitHub and checkout the extensive [README.md](https://github.com/badlogic/r96/blob/main/README.md) that gives you a quick-start as well as detailed information how things work.

Let me know if any of this gives you problems on the [issue tracker](https://github.com/badlogic/r96/issues).

## Demo: Hello DOS
Now that you've totally read the [README.md](https://github.com/badlogic/r96/issues), and installed the tools to compile, run, and debug `r96` on desktop, web, and DOS, we can add a new demo to celebrate DOS support.

Let's call the new demo [`12_hello_dos.c`](https://github.com/badlogic/r96/blob/main/src/12_hello_dos.c):

--markdown-end
{{post.code("12_hello_dos.c", "c",
`
#include <MiniFB.h>
#include <stdio.h>
#include "r96/r96.h"
#include "stdlib.h"
#include <math.h>

#define GDB_IMPLEMENTATION
#include "dos/gdbstub.h"

#define num_grunts 100

typedef struct grunt {
	int x, y, vx, vy;
} grunt;

int main(void) {
	gdb_start();
	r96_image image;
	if (!r96_image_init_from_file(&image, "assets/grunt.png")) {
		printf("Couldn't load file 'assets/grunt.png'\n");
		return -1;
	}

	r96_image output;
	r96_image_init(&output, 320, 240);
	struct mfb_window *window = mfb_open("12_hello_dos", output.width, output.height);

	grunt grunts[num_grunts];
	for (int i = 0; i < num_grunts; i++) {
		grunt *grunt = &grunts[i];
		grunt->x = rand() % 320;
		grunt->y = rand() % 200;
		grunt->vx = 1;
		grunt->vy = 1;
	}
	do {
		r96_clear_with_color(&output, 0xff222222);
		for (int i = 0; i < num_grunts; i++) {
			grunt *grunt = &grunts[i];
			if (grunt->x < 0) {
				grunt->x = 0;
				grunt->vx = -grunt->vx;
			}
			if (grunt->x > 320 - 64) {
				grunt->x = 320 - 64;
				grunt->vx = -grunt->vx;
			}
			if (grunt->y < 0) {
				grunt->y = 0;
				grunt->vy = -grunt->vy;
			}
			if (grunt->y > 240 - 64) {
				grunt->y = 240 - 64;
				grunt->vy = -grunt->vy;
			}
			grunt->x += grunt->vx;
			grunt->y += grunt->vy;
			r96_blit_keyed(&output, &image, grunt->x, grunt->y, 0x00000000);
		}
		if (mfb_update_ex(window, output.pixels, output.width, output.height) != STATE_OK) break;
		gdb_checkpoint();
	} while (mfb_wait_sync(window));

	r96_image_dispose(&image);
	r96_image_dispose(&output);
	return 0;
}
`)}}
--markdown-begin

This is our first animated demo!

The demo draws 100 moving grunts, that bounce off of the screen boundaries. Each grunt is stored in a simple `grunt` struct, which in turn stores the grunt's position (`x`, `y`) and velocity on the x- and y-axis (`vx`, `vy`) in pixels per frame. During initialization, we give each grunt a random position within the screen boundaries and set their velocity on each axis to `1` (lines 29-35).

What's a frame you may ask? A frame can be many things, but in our case, a frame is simply one iteration of the main loop of your program (lines 36-62). In each frame, we check whether each grunt is still inside the screen boundaries. If a grunt is outside the screen boundaries on the x- or y-axis (or both), we move them back inside the bounds and negate their velocity on the axis they left the screen on.

E.g. a grunt moving to the right (`vx = 1`), leaving the screen on the x-axis (`x > 320 - 64`), will be moved back inside the screen boundaries (`x = 320 - 64`), and its velocity on the x-axis will become `-1`. Starting in the next frame, the grunt will then move to the left, until it exits the screen boundaries on the left side of the screen. The same happens on the y-axis.

Once all the checks are complete, we add the grunt's velocity to its position. Each frame, the grunt's position thus changes by `vx` pixels on the x-axis, and `vy` pixels on the y-axis. Hence why `vx` and `vy` are given as pixels per frame.

Now, there's one big problem with this type of moving objects: it depends on the speed of execution.

We call `mfb_wait_sync()`, which waits for a vertical refresh, effectively limiting the number of frames per second to the screen refresh rate, so 60Hz, 90Hz, 120Hz, or whatever other wonky screen refresh rate the display has.

On a 60Hz screen a grunt will thus move 60 pixels per second, on a 120Hz it will move 120 pixels.

For a game, that's not great: different players will experience the game at different speeds, depending on their hardware. We'll look into this issue in a future series entry.

> **Note:** Many old DOS games actually did have this problem: they would not take into account how much time has passed since the last frame, but instead update game object positions at a fixed rate each frame. There's a reason Wikipedia has an entry on the notorious [PC turbo button](https://en.wikipedia.org/wiki/Turbo_button).

Here's the little demo on the web:

--markdown-end
{{demo.r96Demo("12_hello_dos", false)}}
--markdown-begin

And here it is running in DOSBox-x, telling DOSBox-x to go full speed.

--markdown-end
<video style="margin: auto; max-width: 100%;" src="grunts-dosbox.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

DOSBox-x on my system syncs to 60Hz in windowed mode, while Chrome runs the web demo at the full 120Hz of my display. In the video above, there is some smearing and artifacts. That's mostly due to the MP4 encoding and doesn't look like that when actually running the demo in DOSBox-x on your system.

Is the DOSBox-x performance indicative of performance on old systems? No. DOSBox-x is going full speed, which is way faster than what my old 486 could do. However, you can modify the emulation speed via the DOSBox-x menu `CPU > Emulated CPU speed`. In the following video, I've set the emulated CPU speed to be equivalent to a 486DX2 with 66Mhz:

--markdown-end
<video style="margin: auto; max-width: 100%;" src="grunts-dosbox-486.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

While that's more accurate, it's still not quite the same as real hardware. To get a more accurate sense of how the program would perform on a real 486, we can use [86Box](https://86box.net/). 86Box is as cycle accurate emulator for various old x86 systems.

--markdown-end
<video style="margin: auto; max-width: 100%;" src="86box.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

Looks like DOSBox-x isn't far off with its emulation. So why is it so slow?

> **Note:** Setting up virtual machine images for 86Box is a bit terrible. I've created 2 images you can download, a [486](https://marioslab.io/dump/dos/86box/486.zip) image and a [Pentium](https://marioslab.io/dump/dos/86box/pentium.zip) image, pre-installed with MS-DOS 6.22, a mouse driver, and a CD-ROM driver. You can run them via `86box -c 486/86box.conf` and `86box -c pentium/86box.conf`. The images also include QBasic 1.1. And [`NIBBLES.BAS`](https://en.wikipedia.org/wiki/Nibbles_(video_game)) and [`GORILLA.BAS`](https://en.wikipedia.org/wiki/Gorillas_(video_game)). Just saying.

## Why is it so slow on a 486?

The MiniFB DOS backend sets up a video mode with either 24-bit or 32-bit color depth through [VESA](https://en.wikipedia.org/wiki/VESA_BIOS_Extensions). MiniFB assumes 32-bit color depth, so we have to abide by that and go VESA.

This works pretty well from Pentium class machines onwards, if the (emulated) video card supports VESA. Here's the demo on Pentium class hardware in 86Box:

--markdown-end
<video style="margin: auto; max-width: 100%;" src="86box-pentium.mp4" autoplay=true loop=true controls=true></video>
--markdown-begin

A 486 may support 24-bit and 32-bit color depth video modes, depending on the graphics cards. Mine did. However, that doesn't mean the system is fast enough to actually deal with that amount of data. A run of the mill 486 would have memory throughput somewhere in the range of 10-25MB/s. You read that right.

In our demo above, we render to a 320x240 output `r96_image`. The call to `r96_clear_with_color()` has to touch `0.3M` worth of pixels. Rendering a single grunt means reading 64x64x4 bytes from the grunt image and writing them to a 64x64x4 bytes big region in the output `r96_image`. For 100 grunts, that's reading `1.6MB` and writing `1.6MB`. Finally, the output `r96_image` is transferred to the VESA linear buffer, a memory mapped region from which the graphics card will read what it should output to the display. That's another 320x240x4 bytes, or `0.3MB`. Each frame we thus touch `0.3 + 1.6 + 1.6 + 0.3 = 3.8MB` of memory. And while this simple analysis doesn't account for memory caches, it does align with what we experience when running the demo on a (emulated) 486. We do indeed only get something like 3-5 frames per second, which is `11.4-19MB` of data pushed by the demo per second.

That's one of the reasons pretty much all older DOS games targeting 386 or 486 would use [mode 13h](https://en.wikipedia.org/wiki/Mode_13h) or derivatives like [Mode X](https://en.wikipedia.org/wiki/Mode_X). Both of these video modes use 8 bits to encode a pixel's color. But instead of directly encoding the color's red, green and blue component, the 8-bit value is an index into a palette with a total of 256 colors. That cuts down on memory and bandwidth needs considerably.

In our demo's case, we'd go from `3.8MB` to `0.95MB` of data per frame. That translates to 12-20 frames per second, which is still not great, but often playable enough. That's about the frame rate I got when playing [MicroProse's Formula One Grand Prix](https://www.youtube.com/watch?v=qATaCWHLAxw) on my 486.

So what's the solution? Draw less each frame! DOOM and Quake relied on various techniques like [binary space partitioning](https://twobithistory.org/2019/11/06/doom-bsp.html) to avoid drawing things that are invisible or occluded. Drawing less things means touching less memory. Consider that 100 grunts are about 5.3 screens worth of pixels. That's a lot of overdraw.

And yes, we could probably squeeze a lot of cycles out of the blitting functions if we handcrafted some 32-bit x86 assembly. But DJGPP actually does a pretty good job at producing fast machine code. And I don't want to drop down into assembly land.

> **Note:** modern hardware won't save you from these issues either sometimes. When NVIDIA sent me a prototype Tegra board in the early 2010s, I soon found out that you could only render about 2 full-screen alpha blended rectangles through OpenGL ES before the frame-rate takes a heavy hit.

## Excursion: DOS debugging support
When we debug the demo on the desktop, the debugger will spawn the demo process and use system APIs to stop, resume, inspect, and otherwise manipulate the process.

For DOS applications running in DOSBox-x or on a real machine, we do not have the luxury of a debugger. Instead, we use a piece of code called [GDB stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html). Here's how that works.

Of note are 3 pieces of code in the demo above, which do nothing on any platform other than DOS. In lines 7-8 we have:

```
#define GDB_IMPLEMENTATION
#include "dos/gdbstub.h"
```

This pulls in [my GDB stub implementation for DJGPP/DOS](https://github.com/badlogic/r96/blob/main/src/dos/gdbstub.h), which is a single header file library.

The stub's task is it to communicate with the debugger over the serial port, and tell it when the program has stopped due to a breakpoint, or segfault, or other reason. The stub then waits for commands from the debugger to execute, like setting breakpoints, inspecting memory and CPU registers, stepping, continuing, etc.

This GDB stub type of debugging is a cooperative debugging approach. The stub needs to be integrated with the program itself. This explains the other two GDB related lines of code in the demo.

The `gdb_start()` function is called at the beginning of `main()`. It waits for the debugger to connect on the serial port. When the debugger tells the stub to continue execution of the program, the stub stops communicating with the debugger for the time being, and gives back control to the program.

The stub then waits for a system level signal to be raised, like a breakpoint or segfault, for which the stub has registered handlers. If such a signal happens, the stub takes over control from the program again, tells the debugger about the program being stopped, and waits for debugger commands to execute.

The final GDB related line is `gdb_checkpoint()` in line 61. It is placed at the end of our main loop. This is required so the stub can check if the debugger asked to interrupt the program, in which case the stub will take control of the program again and talk to the debugger.

The GDB stub expects all communication to happen through serial port `COM1`. Some emulators and virtual machines, like DOSBox-x or VirtualBox, can expose the emulated serial port as a TCP port to programs on the host OS. That's what's happening when we debug a demo in DOSBox-x. DOSBox-x exposes the serial port on TCP port 5123, to which GDB connects via TCP. DOSBox-x will then translate TCP packages to writes to the serial port, which the GDB stub reads from `COM1`. If the GDB stub writes to `COM1`, then DOSBox-x will forward the data through TCP to GDB.

In theory, the GDB stub should also work on real-hardware. Sadly, I do not have my 486 anymore, nor a serial cable or a serial port on my MacBook.

If you want to debug any of the demos in DOS, you'll have to add the 3 pieces of GDB stub related code to the demo's sources as outlined above. Only the `12_hello_dos.c` demo is currently set-up for DOS debugging. Since our code is cross-platform, there won't be a need to debug in DOS a lot though.

> **Note:** when debugging the demos compiled for DOS, we'll be using DOSBox-x instead of 86Box. Two reasons: getting data into and out of 86Box is very annoying. And there is no serial port over TCP emulation in 86Box, so the debugger couldn't even connect. It should be possible to hook the debugger up with a program running in MS-DOS or FreeDOS in VirtualBox though.

## Bitmap fonts


## Next time on "Mario writes a lot of words"

Discuss this post on [Twitter]() or [Mastodon]().

--markdown-end
<script>
tableOfContents()
</script>

{{include "../../../_templates/post_footer.bt.html"}}