{{
metadata = {
	title: "Rendering like it's 1996 - Baby's first pixel",
	summary: "Follow me down memory lane, as I bumble through algorithms I don't understand to reconstruct parts of my childhood, badly.",
	image: "quake.png",
	date: parseDate("2022/11/29 21:00"),
	published: false,
}
}}

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}

{{post.figure("quake.png", "There's absolutely no chance we'll get to this level of quality.")}}

<p> 
	In 1996, I was a teen without a gaming console. While my friends enjoyed their Crash Bandicoots, Tekens, and Turoks, I had a beige 486 DX 2 with a turbo button, 16Mb of RAM, a 256Mb hard disk, and a 2x CD-ROM drive running DOS. And then I got a copy of Quake. Did it run great? No. But it did run! And to my young eyes, it was the most beautiful thing I've ever seen on my computer screen. Ok, the most beautiful brown thing.
</p>

<p>
	3D accelerator graphics cards were in their <a href="https://www.techspot.com/article/650-history-of-the-gpu/">infancy</a>. Most DOS PC games around that time would render their glorious pixels via the CPU to a dedicated area in RAM, e.g. starting at segment address 0xa000. The (pretty dumb) graphics card would then read and display the contents of that memory area on your bulky CRT. This is known as <a href="https://en.wikipedia.org/wiki/Software_rendering">software rendering or software rasterization</a>.
</p>

<p>
	I did dabble in some graphics programming back then. I even managed to create a <a href="/projects/return-to-marchfeld">Wolfenstein style first person shooter</a> in QBasic with some assembly before the end of the century.
</p>

{{post.figureMaxWidth("rtm.png", "Actually not a ray casting engine, but a polygonal 3D engine with terrible affine texture mapping.", "320px")}}

<p>
	But I never really dove into the depths of contemporary graphics technology. And while my subsequent professional career featured plenty of graphics programming, it was mostly the GPU accelerated kind, not the "worry about each cycle in your inner loops" software rasterizer kind of type.
</p>

<h2>(Non-)Goals</h2>
<p>
	I want to explore the ins and outs of software rasterization, starting from first principles, i.e. getting a pixel on screen. From there, I want to delve into topics like simple demo effects, primitive rasterization, ray casting, voxel terrain, maybe even Quake-style 3D rendering, and whatever else comes to mind.
</p>

<p>
	Each blog post on a topic will lay out the theory the way I understand it in hopefully simple terms, discuss a naive practical implementation, and finally investigate ways to optimize the implementation until it is reasonably fast.
</p>

<p>
	The end product(s) should work on Windows, Linux, macOS, and common browsers. Ideally, a little software rasterizer library and demos will fall out at the end, that can serve both as an example implementation of common techniques, or as the basis for other demos or games with DOS game aesthetics.
</p>
	
<p>
	You'll be able to follow along both here, and by playing with the <a href="https://github.com/badlogic/r96">code on GitHub</a>.
</p>

<p>
	What I do not want to do is dabble in things like assembly or SIMD optimizations. While that can be fun too, it is unlikely to be necessary on today's hardware, given that I'll target common DOS resolutions like 320x240, or 640x480. I might however inspect and discuss the compiler's assembly output to identify areas that can be improved performance wise in the higher level code.
</p>

<h2>Tools of the trade</h2>
<p>
	The weapon of choice will be C99 for aesthetic and practical reasons. I want all the code produced throughout this series to run on anything, so C99 is a good choice. 
</p>

<p>
	I'll use <a href="https://cmake.org/">CMake</a> as the build tool, not because I love it, but because my favorite C/C++ IDE <a href="https://www.jetbrains.com/clion/">CLion</a> has first class support it. Other development environments understand CMake as well these days, including <a href="https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170">Visual Studio</a> if that's your kink.
</p>

<p>
	The pixels we'll generate need to be thrown up on the display somehow. On Windows, Linux, and macOS we'll use <a href="https://github.com/emoon/minifb">minifb</a>. In a few lines of code, we can open a window, process keyboard and mouse input, and give it a bunch of pixels to draw to the window. It can even upscale our low resolution output if needed. Since minifb does not have browser support, I've written a web backend myself and submitted it as a <a href="https://github.com/emoon/minifb/pull/94">pull request</a> to the upstream repo. In the meantime, we'll use my <a href="https://github.com/badlogic/minifb/tree/web">minifb fork</a>, which has web support baked in.
</p>

<p>
	To get the code running in the browser, we'll use <a href="https://emscripten.org/">emscripten</a> to compile the C code to <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WASM</a> and a small <code>.js</code> file, which loads the <code>.wasm</code> file and exposes our C functions to JavaScript.
</p>

<p>
	To follow along by compiling, running and debugging the code of this tutorial series, you'll need to install a few things:
</p>

<ul>
	<li><strong>Windows:</strong>
		<ul>
			<li><a href="https://git-scm.com/download/win">Git for Windows</a>. Make sure its available on the command line via the system PATH.</li>
			<li><a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">Visual Studio with C++ support</a></li>
			<li><a href="https://cmake.org/download/">CMake</a>. Make sure you add CMake to the system PATH during installation, so you can execute it from the command line</li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>. Put the <code>ninja.exe</code> file somewhere and make sure it's available on the command line via your system PATH.</li>
			<li><a href="https://www.python.org/">Python</a>. Make sure it's available on the command line via your system PATH.</li>	
		</ul>
	</li>
	<li><strong>Linux:</strong>
		<ul>			
			<li><a href="https://gcc.gnu.org/">GCC</a> and Git. On Ubuntu <code>sudo apt install build-essential git gdb</code> will do</li>
			<li>x11-dev library. On Ubuntu: <code>sudo apt install libx11-dev</code></li>
			<li><a href="https://cmake.org/download/">CMake</a>. On Ubuntu: <code>sudo apt install cmake</code></li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>. On Ubuntu: <code>sudo apt install ninja</code></li>
		</ul>
	</li>
	<li><strong>macOS:</strong>
		<ul>
			<li><a href="https://developer.apple.com/xcode/">Xcode</a>. Make sure to also install the <a href="https://mac.install.guide/commandlinetools/4.html">command line tools</a>.</li>
			<li><a href="https://cmake.org/download/">CMake</a>, e.g. via <a href="https://brew.sh/">brew</a> <code>brew install cmake</code></li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>, e.g. via brew <code>brew install ninja</code></li>
		</ul>
	</li>
</ul>

<p>
	Finally, to test things in the browser, you'll need to install <a href="https://emscripten.org/docs/getting_started/downloads.html">emscripten</a>. Welcome to cross-platform development.
</p>

<p>
	If you know your way around cross-platform C/C++ development with CMake and already have a preferred editor/IDE setup, skip the next section.
</p>

<h2>Setting up VS Code for C development</h2>
<p>
	Yes, we could do all development from the command line. But I'm old and cranky and need my UI safe space. Don't @ me.
</p>
<p>
	I'm not religious in general, but for C/C++ work I now exclusively use <a href="https://www.jetbrains.com/clion/">CLion</a>. However, that has a price tag, and since I want everyone to be able to follow along, we'll be using <a href="https://code.visualstudio.com/">Visual Studio Code</a> (or VS Code for short), which is available for Windows, Linux, and macOS. Here's how that's setup:
</p>

<ul>
	<li>Install <a href="https://code.visualstudio.com/Download">VS Code</a></li>
	<li>Open VS Code and install these extensions:
		<ul>
			<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a>. Provides C/C++ debugging, CMake support, and bad intellisense which we'll disable</li>
			<li><a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd</a>. Provides good intellisense</li>
		</ul>
	</li>
	<li>Re-open VS Code for good measure</li>
	<li>Open the command palette (<code>CTRL+SHIFT+P</code> or <code>CMD+SHIFT+P</code> on macOS), type <code>user setting</code> and select <code>Preferences: Open User-Settings (JSON)</code></li>
	<li>At the bottom of the freshly opened <code>settings.json</code> file, add the following lines before the closing <code>}</code>:
		{{post.code("settings.json", "json",
"
\"C_Cpp.intelliSenseEngine\": \"Disabled\"
\"cmake.configureOnOpen\": true,
\"cmake.configureArgs\": [\"-DCMAKE_EXPORT_COMPILE_COMMANDS=TRUE\"],
"
		)}}
	This will disable the bad intellisense of the C/C++ extension, ensures that CMake projects are automatically configured when opened in VS Code, and that CMake always builds a <code>compile_commands.json</code> file, which the clangd extension needs to provide intellisense/auto-completion.
	</li>	
</ul>

<p>
	With everything installed and set up, let's briefly have a look at how we can use VS Code for C development.
</p>

<h2>Using VS Code for C development</h2>
<p>
	Let's start by creating a simple CMake project.
</p>

<ul>
	<li>Create a folder <code>quickstart</code> somewhere on your hard disk</li>
	<li>Open the folder in VS Code</li>
	<li>Create a folder called <code>src</code>, and within it a file called <code>quickstart.c</code> with the following content:
	{{post.code("quickstart.c", "c",
"
#include <stdio.h>

int main(void) {
	char *text = \"Hello World\\n\";
	printf(\"%s\", text);
	return 0;
}
	
"
	)}}
	</li>
	<li>Create a file called <code>CMakeLists.txt</code> in the root of the folder with the following content:
		{{post.code("CMakeLists.txt", "cmake",
"
cmake_minimum_required(VERSION 3.21.1)
project(quickstart)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REQUIRED TRUE)

if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)
endif()

add_executable(quickstart \"src/quickstart.c\")
"
		)}}
	</li>
</ul>

<p>
	The <code>quickstart.c</code> file should be pretty self-explanatory. If not, then this blog post series may not be for you.
</p>

<p>
	The <code>CMakeLists.txt</code> file defines our build. Line 1 defines the minimally required CMake version. Line 2 specifies the project name. Lines 4 and 5 ensure that the compiler uses and must support the C99 standard. Lines 7 to 11 set the warning level to "extremely pedantic, warnings are errors", the Microsoft C++ compiler way as well as the Clang/GCC way. These flags will be added to any target we build. A target is (usually) a library or an executable from a set of source files. We can add as many targets as we want, build them all at once, or build just one specifically. Targets can also depend on each other. CMake is smart enough to figure out which targets need to be build when building a specific target. In line 13 we define an executable target called <code>quickstart</code>, which is build from the <code>src/quickstart.c</code> file.
</p>

<p>
	To clean, build, run and debug, we can either use the CMake extension commands  from the command palette (search for <code>cmake</code> in the palette to see what's available), or use the CMake UI at the bottom of the VS Code window:
</p>

{{post.figure("cmake-ui.png", "The CMake extension UI.")}}

<p>
	Let's run through the CMake UI real quick:
</p>

<ul>
	<li><code>[Debug]</code>: Let's you select the currently active variant. A variant is a fancy name for build type, e.g. release or debug</li>
	<li><code>No active kit</code>: Let's you select the currently active kit. A kit is a compiler toolchain for a specific architecture, e.g. Clang for x86_64, Visual Studio for ARM64, etc. Always select a specific toolchain, otherwise the debugger won't work!</li>
	<li><code>Build</code>: Triggers a build of the target(s) specified in the next setting, using the currently selected variant and kit</li>
	<li><code>[all]</code>: Specifies which targets will be build, like our <code>quickstart</code> executable target. For small projects, it's fine to leave this as <code>[all]</code></li>
	<li><code>Debug</code>: Builds the selected target(s) as specified by the previous settings, then starts a debugging session for the target specified in the last setting of the ui (in the screenshot that's <code>[quickstart]</code>)</li>
	<li><code>Run</code>: Builds the selected target(s) as specified by the previous settings, then starts a debugging session for the target specified in the last setting of the ui (in the screenshot that's <code>[quickstart]</code>)</li>
	<li><code>[quickstart]</code>: Let's you specify which target will be run or debugged when clicking one of the previous two buttons or using the corresponding command from the palette.</li>
</ul>

<p>
	All of these except the last one have a command equivalent in the command palette:
</p>

<ul>
	<li><code>CMake: Select Variant</code></li>
	<li><code>CMake: Select a Variant</code></li>
	<li><code>CMake: Build</code></li>
	<li><code>CMake: Set Build Target</code></li>
	<li><code>CMake: Debug</code></li>
	<li><code>CMake: Run Without Debugging</code></li>
</ul>

<p>I usually use the UI to set the variant, kit, targets to be build, and target to be debugged/run, and the commands from the palette for building, debugging and running.</p>

<p>You may be asked by the CMake extension to select a kit, or in case no kits have been configured yet, scan for kits:</p>

{{post.figure("scan-kits.png", "")}}

<p><a href="https://github.com/microsoft/vscode-cmake-tools/blob/main/docs/kits.md#how-kits-are-found-and-defined">Scanning for kits</a> means searching for compiler toolchains on your system. Once the scan is complete, you'll be able to select a specific kit to build, run, and debug your targets with.</p>

<p>If the scan fails to find a specific kit, you can also add a kit configuration manually. We have to do exactly that for the emscripten toolchain.</p>

<ul>
	<li>Run the <code>CMake: Edit User-Local Kits</code> commands</li>
	<li>At the end of the <code>cmake-tools-kits.json</code> file, add the following lines before the closing <code>]</code>:
		{{post.code("cmake-tools-kits.json", "json",
"
,{
	\"name\": \"Emscripten\",
	\"toolchainFile\": \"/Users/badlogic/workspaces/emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake\"
}
"
		)}}
	</li>
	<li>Replace the <code>"toolchainFile"</code> path with the path to your emscripten installation's toolchain file.</li>
</ul>

<p>
	Congratulations, you can now also compile your C code for the web by selecting the emscripten kit! The emscripten toolchain doesn't output executables, but a pair of <code>.js</code> and <code>.wasm</code> files. On their own, they can't be run or debugged. They need to be loaded with a little JavaScript within a HTML document. We'll have a look at how that works in the next section.
</p>

<p>
	When a build completes, you can find all its output in the <code>build/</code> folder.
</p>

<p class="note">
	<strong>Note:</strong> The clangd intellisense/auto-completion will only start working correctly once we've build the project at least once. It requires the <code>compile_commands.json</code> file that the build will generate.
</p>

<p>
	For our final trick, let's set a breakpoint anywhere in <code>src/quickstart.c</code> and start a debugging session either through the CMake UI or the corresponding command from the palette:
</p>

{{post.figure("debug.png", "This will do pig, this will do.")}}

<p>
	We're ready to build the scaffold of our little "Rendering like it's 1996" project. And since that's a mouthful, the project shall henceforth be known as <code>r96</code>
</p>

<h2>The r96 project scaffold</h2>
<p>
	Like any good TV cook, I've already prepared a little something. Clone the <code>r96</code> repository and check out the <code>babys-first-pixel-00</code> branch.
</p>

{{post.code("", "bash",
"
git clone https://github.com/badlogic/r96 --branch babys-first-pixel-00
"
)}}

<p>
	Then open it in VS Code. You'll be asked to select a kit. Select whatever makes sense for your host OS. Here's what you'll get.
</p>

{{post.figureMaxWidth("r96-files.png", "Initial file tree of r96.", "200px")}}

<p>
	The <code>.gitignore</code>, <code>LICENSE</code>, and <code>README.md</code> files are pretty self-explanatory. The <code>.clang-format</code> file stores the formatting settings used to format the code via ... <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a>. The C/C++ extension uses the settings in that file whenever you format a C/C++ source file.
</p>

<p>Next we have the <code>CMakeLists.txt</code> file. Here it is in all its glory:</p>

{{post.code("CMakeLists.txt", "cmake",
"
cmake_minimum_required(VERSION 3.21.1)
project(r96)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REQUIRED TRUE)

include(FetchContent)
FetchContent_Declare(minifb GIT_REPOSITORY https://github.com/badlogic/minifb GIT_TAG web)
set(MINIFB_BUILD_EXAMPLES CACHE INTERNAL FALSE)
FetchContent_MakeAvailable(minifb)

if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)

    if(EMSCRIPTEN)
        add_link_options(
                -sSTRICT=1
                -sENVIRONMENT=web
                -sLLD_REPORT_UNDEFINED
                -sMODULARIZE=1
                -sALLOW_MEMORY_GROWTH=1
                -sALLOW_TABLE_GROWTH
                -sMALLOC=emmalloc
                -sEXPORT_ALL=1
                -sEXPORTED_FUNCTIONS=[\"_malloc\",\"_free\",\"_main\"]
                -sASYNCIFY
                --no-entry
        )
    endif()
endif()

add_library(r96 \"src/r96/r96.c\")

add_executable(r96_00_basic_window \"src/00_basic_window.c\")
target_link_libraries(r96_00_basic_window LINK_PUBLIC minifb r96)

if(EMSCRIPTEN)
    add_custom_target(r96_web_assets
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_CURRENT_SOURCE_DIR}/web
            ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_dependencies(r96_00_basic_window r96_web_assets)
    target_link_options(r96_00_basic_window PRIVATE -sEXPORT_NAME=r96_00_basic_window)
endif()
"
)}}

{{include "../../../_templates/post_footer.bt.html"}}