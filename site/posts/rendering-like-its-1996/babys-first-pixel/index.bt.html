{{
metadata = {
	title: "Rendering like it's 1996 - Baby's first pixel",
	summary: "Follow me down memory lane, as I bumble through algorithms I don't understand to reconstruct parts of my childhood, badly.",
	image: "quake.png",
	date: parseDate("2022/12/02 21:00"),
	published: true,
}
}}

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}

{{post.figure("quake.png", "There's absolutely no chance we'll get to this level of quality.")}}

<div class="table_of_contents"></div>

<p>
	In 1996, I was a teen without a gaming console. While my friends enjoyed their Crash Bandicoots, Tekens, and Turoks, I had a beige 486 DX 2 with a turbo button, 16Mb of RAM, a 256Mb hard disk, and a 2x CD-ROM drive running DOS. And then I got a copy of Quake. Did it run great? No. But it did run! And to my young eyes, it was the most beautiful thing I've ever seen on my computer screen. Ok, the most beautiful brown thing.
</p>

<p>
	3D accelerator graphics cards were in their <a href="https://www.techspot.com/article/650-history-of-the-gpu/">infancy</a>. Most DOS PC games around that time would render their glorious pixels via the CPU to a dedicated area in RAM, e.g. starting at segment address 0xa000. The (pretty dumb) graphics card would then read and display the contents of that memory area on your bulky CRT. This is known as <a href="https://en.wikipedia.org/wiki/Software_rendering">software rendering or software rasterization</a>.
</p>

<p>
	I did dabble in some graphics programming back then. I even managed to create a <a href="/projects/return-to-marchfeld">Wolfenstein style first person shooter</a> in QBasic with some assembly before the end of the century.
</p>

{{post.figureMaxWidth("rtm.png", "Actually not a ray casting engine, but a polygonal 3D engine with terrible affine texture mapping.", "320px")}}

<p>
	But I never really dove into the depths of contemporary graphics technology. And while my subsequent professional career featured plenty of graphics programming, it was mostly the GPU accelerated kind, not the "worry about each cycle in your inner loops" software rasterizer kind of type.
</p>

<h2>(Non-)Goals</h2>
<p>
	I want to explore the ins and outs of software rasterization, starting from first principles, i.e. getting a pixel on screen. From there, I want to delve into topics like simple demo effects, primitive rasterization, ray casting, voxel terrain, maybe even Quake-style 3D rendering, and whatever else comes to mind.
</p>

<p>
	Each blog post on a topic will lay out the theory the way I understand it in hopefully simple terms, discuss a naive practical implementation, and finally investigate ways to optimize the implementation until it is reasonably fast.
</p>

<p>
	The end product(s) should work on Windows, Linux, macOS, and common browsers. Ideally, a little software rasterizer library and demos will fall out at the end, that can serve both as an example implementation of common techniques, or as the basis for other demos or games with DOS game aesthetics.
</p>

<p>
	You'll be able to follow along both here, and by playing with the <a href="https://github.com/badlogic/r96">code on GitHub</a>. In addition to the render-y bits, I'll also demonstrate how I set up a cross-platform C project and show you how I structure, build, and debug C code in such a project. I love seeing and learning from other people's workflows. Maybe that's true for you too.
</p>

<p>
	What I do not want to do is dabble in things like assembly or SIMD optimizations. While that can be fun too, it is unlikely to be necessary on today's hardware, given that I'll target common DOS resolutions like 320x240, or 640x480. I might however inspect and discuss the compiler's assembly output to identify areas that can be improved performance wise in the higher level code.
</p>

<h2>Tools of the trade</h2>
<p>
	The weapon of choice will be C99 for aesthetic and practical reasons. I want all the code produced throughout this series to compile anywhere. It should also be easy to re-use the code in other languages through an <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>. C99 is a good choice for both objectives.
</p>

<p>
	I'll use <a href="https://cmake.org/">CMake</a> as the build tool, not because I love it, but because my favorite C/C++ IDE <a href="https://www.jetbrains.com/clion/">CLion</a> has first class support for it. Other development environments understand CMake as well these days, including <a href="https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170">Visual Studio</a> if that's your kink.
</p>

<p>
	The pixels we'll generate need to be thrown up on the display somehow. On Windows, Linux, and macOS we'll use <a href="https://github.com/emoon/minifb">minifb</a>. In a few lines of code, we can open a window, process keyboard and mouse input, and give it a bunch of pixels to draw to the window. It can even upscale our low resolution output if needed. Since minifb does not have browser support, I've written a web backend myself and submitted it as a <a href="https://github.com/emoon/minifb/pull/94">pull request</a> to the upstream repo. In the meantime, we'll use my <a href="https://github.com/badlogic/minifb/tree/web">minifb fork</a>, which has web support baked in.
</p>

<p>
	To get the code running in the browser, we'll use <a href="https://emscripten.org/">emscripten</a> to compile the C code to <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WASM</a> and a small <code>.js</code> file, which loads the <code>.wasm</code> file and exposes our C functions to JavaScript.
</p>

<p>
	To follow along by compiling, running and debugging the code of this series, you'll need to install a few things:
</p>

<ul>
	<li><strong>Windows:</strong>
		<ul>
			<li><a href="https://git-scm.com/download/win">Git for Windows</a>. Make sure its available on the command line via the system PATH.</li>
			<li><a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">Visual Studio with C++ support</a></li>
			<li><a href="https://cmake.org/download/">CMake</a>. Make sure you add CMake to the system PATH during installation, so you can execute it from the command line</li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>. Put the <code>ninja.exe</code> file somewhere and make sure it's available on the command line via your system PATH</li>
			<li><a href="https://www.python.org/">Python</a>. Make sure it's available on the command line via your system PATH</li>
		</ul>
	</li>
	<li><strong>Linux:</strong>
		<ul>
			<li><a href="https://gcc.gnu.org/">GCC</a> and Git. On Ubuntu <code>sudo apt install build-essential git gdb</code> will do</li>
			<li>x11-dev library. On Ubuntu: <code>sudo apt install libx11-dev</code></li>
			<li><a href="https://cmake.org/download/">CMake</a>. On Ubuntu: <code>sudo apt install cmake</code></li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>. On Ubuntu: <code>sudo apt install ninja</code></li>
		</ul>
	</li>
	<li><strong>macOS:</strong>
		<ul>
			<li><a href="https://developer.apple.com/xcode/">Xcode</a>. Make sure to also install the <a href="https://mac.install.guide/commandlinetools/4.html">command line tools</a></li>
			<li><a href="https://cmake.org/download/">CMake</a>, e.g. via <a href="https://brew.sh/">brew</a> <code>brew install cmake</code></li>
			<li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a>, e.g. via brew <code>brew install ninja</code></li>
		</ul>
	</li>
</ul>

<p>
	Finally, to test things in the browser, you'll need to install <a href="https://emscripten.org/docs/getting_started/downloads.html">emscripten</a>. Welcome to cross-platform development.
</p>

<p>
	If you know your way around cross-platform C/C++ development with CMake and already have a preferred editor/IDE setup, skip the next section.
</p>

<h2>Setting up VS Code for C development</h2>
<p>
	Yes, we could do all development from the command line. But I'm old and cranky and need my UI safe space. Don't @ me.
</p>
<p>
	I'm not religious in general, but for C/C++ work I now exclusively use <a href="https://www.jetbrains.com/clion/">CLion</a>. However, that has a price tag, and since I want everyone to be able to follow along, we'll be using <a href="https://code.visualstudio.com/">Visual Studio Code</a> (or VS Code for short), which is available for Windows, Linux, and macOS. Here's how that's set up:
</p>

<ul>
	<li>Install <a href="https://code.visualstudio.com/Download">VS Code</a></li>
	<li>Open VS Code and install these extensions:
		<ul>
			<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a>. Provides C/C++ debugging, CMake support, and bad intellisense which we'll disable</li>
			<li><a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd</a>. Provides good intellisense</li>
		</ul>
	</li>
	<li>Re-open VS Code for good measure</li>
	<li>Open the command palette (<code>CTRL+SHIFT+P</code> or <code>CMD+SHIFT+P</code> on macOS), type <code>user setting</code> and select <code>Preferences: Open User-Settings (JSON)</code></li>
	<li>At the bottom of the freshly opened <code>settings.json</code> file, add the following lines before the closing <code>}</code>:
		{{post.code("settings.json", "json",
`
"C_Cpp.intelliSenseEngine": "Disabled"
"cmake.configureOnOpen": true,
"cmake.configureArgs": ["-DCMAKE_EXPORT_COMPILE_COMMANDS=TRUE"],
`
		)}}
	This will disable the bad intellisense of the C/C++ extension, ensures that CMake projects are automatically configured when opened in VS Code, and that CMake always builds a <code>compile_commands.json</code> file, which the clangd extension needs to provide intellisense/auto-completion.
	</li>
</ul>

<p>
	With everything installed and set up, let's briefly have a look at how we can use VS Code for C development.
</p>

<h2>Using VS Code for C development</h2>
<p>
	Let's start by creating a simple CMake project.
</p>

<ul>
	<li>Create a folder <code>quickstart</code> somewhere on your hard disk</li>
	<li>Open the folder in VS Code</li>
	<li>Create a folder called <code>src</code>, and within it a file called <code>quickstart.c</code> with the following content:
	{{post.code("quickstart.c", "c",
`
#include <stdio.h>

int main(void) {
	char *text = "Hello World\n";
	printf("%s", text);
	return 0;
}
`
	)}}
	</li>
	<li>Create a file called <code>CMakeLists.txt</code> in the root of the folder with the following content:
		{{post.code("CMakeLists.txt", "cmake",
`
cmake_minimum_required(VERSION 3.21.1)
project(quickstart)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REQUIRED TRUE)

if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)
endif()

add_executable(quickstart "src/quickstart.c")
`
		)}}
	</li>
</ul>

<p>
	The <code>quickstart.c</code> file should be pretty self-explanatory. If not, then this blog post series may not be for you.
</p>

<p>
	The <code>CMakeLists.txt</code> file defines our build. Line 1 defines the minimally required CMake version. Line 2 specifies the project name. Lines 4 and 5 ensure that the compiler uses and must support the C99 standard. Lines 7 to 11 set the warning level to "extremely pedantic, warnings are errors", the Microsoft C++ compiler way as well as the Clang/GCC way. These flags will be added to any target we build.
</p>

<p>
	A target is (usually) a library or an executable from a set of source files. We can add as many targets as we want, build them all at once, or build just one specifically. Targets can also depend on each other. CMake is smart enough to figure out which targets need to be build when building a specific target.
</p>

<p>
In line 13 we define an executable target called <code>quickstart</code>, which is build from the <code>src/quickstart.c</code> file.
</p>

<p>
	To clean, build, run and debug, we can either use the CMake extension commands  from the command palette (search for <code>cmake</code> in the palette to see what's available), or use the CMake UI at the bottom of the VS Code window:
</p>

{{post.figureMaxWidth("cmake-ui.png", "The CMake extension UI.", "80%")}}

<p>
	Let's run through the CMake UI real quick:
</p>

<ul>
	<li><code>[Debug]</code>: Let's you select the currently active variant. A variant is a fancy name for build type, e.g. release or debug</li>
	<li><code>No active kit</code>: Let's you select the currently active kit. A kit is a compiler toolchain for a specific architecture, e.g. Clang for x86_64, Visual Studio for ARM64, etc. Always select a specific toolchain, otherwise the debugger may not work!</li>
	<li><code>Build</code>: Triggers a build of the target(s) specified in the next setting, using the currently selected variant and kit</li>
	<li><code>[all]</code>: Specifies which targets will be build, like our <code>quickstart</code> executable target. For small projects, it's fine to leave this as <code>[all]</code></li>
	<li><code>Debug</code>: Builds the selected target(s) as specified by the previous settings, then starts a debugging session for the target specified in the last setting of the ui (in the screenshot that's <code>[quickstart]</code>)</li>
	<li><code>Run</code>: Builds the selected target(s) as specified by the previous settings, then starts the target specified in the last setting of the ui (in the screenshot that's <code>[quickstart]</code>)</li>
	<li><code>[quickstart]</code>: Let's you specify which target will be run or debugged when clicking one of the previous two buttons or using the corresponding command from the palette.</li>
</ul>

<p>
	All of these except the last one have a command equivalent in the command palette:
</p>

<ul>
	<li><code>CMake: Select Variant</code></li>
	<li><code>CMake: Select a Variant</code></li>
	<li><code>CMake: Build</code></li>
	<li><code>CMake: Set Build Target</code></li>
	<li><code>CMake: Debug</code></li>
	<li><code>CMake: Run Without Debugging</code></li>
</ul>

<p>I usually use the UI to set the variant, kit, targets to be build, and target to be debugged/run, as I do not change these settings often. I use the commands from the palette for building, debugging and running as I do that frequently. Using hot keys to do these tasks saves a lot of time.</p>

<p>You may be asked by the CMake extension to select a kit, or in case no kits have been configured yet, scan for kits:</p>

{{post.figureMaxWidth("scan-kits.png", "", "80%")}}

<p><a href="https://github.com/microsoft/vscode-cmake-tools/blob/main/docs/kits.md#how-kits-are-found-and-defined">Scanning for kits</a> means searching for compiler toolchains on your system. Once the scan is complete, you'll be able to select a specific kit to build, run, and debug your targets with.</p>

<p>If the scan fails to find a specific kit, you can also add a kit configuration manually. We have to do exactly that for the emscripten toolchain.</p>

<ul>
	<li>Run the <code>CMake: Edit User-Local Kits</code> commands</li>
	<li>At the end of the <code>cmake-tools-kits.json</code> file, add the following lines before the closing <code>]</code>:
		{{post.code("cmake-tools-kits.json", "json",
`
,{
	"name": "Emscripten",
	"toolchainFile": "/Users/badlogic/workspaces/emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake"
}
`
		)}}
	</li>
	<li>Replace the <code>"toolchainFile"</code> path with the path to your emscripten installation's toolchain file.</li>
</ul>

<p>
	Congratulations, you can now also compile your C code for the web by selecting the emscripten kit! The emscripten toolchain doesn't output executables, but a pair of <code>.js</code> and <code>.wasm</code> files. On their own, they can't be run or debugged. They need to be loaded with a little JavaScript within an HTML document. We'll have a look at how that works in the next section.
</p>

<p>
	When a build completes, you can find all its output in the <code>build/</code> folder.
</p>

<p class="note">
	<strong>Note:</strong> The clangd intellisense/auto-completion will only start working correctly once we've build the project at least once. It requires the <code>compile_commands.json</code> file that the build will generate.
</p>

<p>
	For our final trick, let's set a breakpoint anywhere in <code>src/quickstart.c</code> and start a debugging session either through the CMake UI or the corresponding command from the palette:
</p>

{{post.figureMaxWidth("debug.png", "This will do pig, this will do.", "80%")}}

<p>
	We're ready to build the scaffold of our little "Rendering like it's 1996" project. And since that's a mouthful, the project shall henceforth be known as <code>r96</code>
</p>

<h2>The r96 project scaffold</h2>

<p>
	These are the goals for the project scaffold:
</p>

<ul>
	<li>Allow adding new demo apps that work without code modification on both the desktop and in the browser</li>
	<li>Make creating re-usable code easy, to be used by demo apps.</li>
	<li>Make building for the desktop and the web trivial</li>
</ul>

<p>
	Like any good TV cook, I've already prepared a little something. Clone the <a href="https://github.com/badlogic/r96"><code>r96</code></a> repository and check out the <code>babys-first-pixel-00</code> branch.
</p>

{{post.code("", "bash",
"
git clone https://github.com/badlogic/r96 --branch babys-first-pixel-00
"
)}}

<p>
	Open it in VS Code. You'll be asked to select a kit. Select whatever makes sense for your host OS. Here's what you'll get.
</p>

<h3>File structure</h3>
</p>

{{post.figureMaxWidth("r96-files.png", "Initial file tree of r96.", "200px")}}

<p>
	The <code>.gitignore</code>, <code>CMakeLists.txt</code>, <code>LICENSE</code>, and <code>README.md</code> files are pretty self-explanatory. The <code>.clang-format</code> file stores the formatting settings used to format the code via, you guessed it, <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a>. The C/C++ extension uses the settings in that file whenever you format a C/C++ source file in VS Code. The file can also be used to format the entire code base from the command line.
</p>

<p>
	The <code>src</code> folder contains our code. Re-usable code goes into <code>src/r96/</code>. Demo apps go into the root of the <code>src/</code> folder. There's one demo app so far called <code>00_basic_window.c</code>. Any demo apps we write in subsequent blog posts will also go into <code>src/</code> and start with a sequential number, so we immediately see in which order they were written.
</p>

<p>
	The <code>web/</code> folder may be weird, even scary to seasoned C veterans. But we need it to run our demo apps on the web. A small price to pay. It contains one <code>.html</code> file per demo app. The purpose of that file is to:
</p>

<ul>
	<li>Load the <code>.js</code> and <code>.wasm</code> files generated by emscripten for the demo app executable target</li>
	<li>Provide the demo app with a HTML5 canvas element to draw to</li>
	<li>Kick off the demo apps execution by calling its <code>main()</code> function</li>
</ul>
<p>
	For any demo app we write in the future, we'll add a source file to the <code>src/</code> folder, and a corresponding <code>.html</code> file to the <code>web/</code> folder.
</p>

<p>The <code>web/index.html</code> file is just a plain listing linking to all the <code>.html</code> files of our demo apps. The <code>web/r96.css</code> file is a CSS style sheet used to make the elements in the demo app <code>.html</code> files a little prettier.</p>

<p>
	When you build the project for the first time through CMake, a transient <code>build/</code> folder will be created. It contains the build output: executable files for desktop builds, <code>.js</code>/<code>.wasm</code>/<code>.html</code> files for web builds.
</p>

<p>
	To run a desktop build, just run the executable file. To run a web build, have a web browser of your choice serve the contents of the <code>build/</code> folder and point your browser at it. E.g. serve the files via <code>python -m http.server --directory build</code>, open <a href="http://localhost:8000">http://localhost:8000</a> in your browser.
</p>

<h3>Dissecting the CMakeLists.txt file</h3>

<p>To understand how the build is setup, we need to dissect the <code>CMakeLists.txt</code> file. Here it is in all its glory, section by section.</p>

{{post.code("CMakeLists.txt", "cmake",
"
cmake_minimum_required(VERSION 3.21.1)
project(r96)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REQUIRED TRUE)
"
)}}

<p>
	The first few lines we already know from our quickstart example project above. The project name is <code>r96</code> and we force C99.
</p>

{{post.code("", "cmake",
"
include(FetchContent)
FetchContent_Declare(minifb GIT_REPOSITORY https://github.com/badlogic/minifb GIT_TAG web)
set(MINIFB_BUILD_EXAMPLES CACHE INTERNAL FALSE)
FetchContent_MakeAvailable(minifb)
"
)}}

<p>
	Next we pull in minifb via CMake's <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a> mechanism. CMake veterans may sneer at this and rather use a Git submodule. But I like it that way, thank you very much. This magic incantation will clone my minifb fork with web support, disable the minifb example targets, and finally make the remaining minifb library target available to the targets defined in our own <code>CMakeLists.txt</code>. Nice.
</p>

{{post.code("", "cmake",
`
if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)

    if(EMSCRIPTEN)
        add_link_options(
			-sSTRICT=1
			-sENVIRONMENT=web
			-sLLD_REPORT_UNDEFINED
			-sMODULARIZE=1
			-sALLOW_MEMORY_GROWTH=1
			-sALLOW_TABLE_GROWTH
			-sMALLOC=emmalloc
			-sEXPORT_ALL=1
			-sEXPORTED_FUNCTIONS=["_malloc","_free","_main"]
			-sASYNCIFY
			--no-entry
        )
    endif()
endif()
`
)}}

<p>
	In the next section, we set the "pedantic warnings are errors" compiler flags again. If we build with the emscripten toolchain, we add additional linker flags specific to emscripten via <code>add_link_options()</code>. These linker flags will get used by all subsequently defined executable targets. These are the flags I use for all my WASM projects after about a year of playing with emscripten and WASM. You can learn more about them in emscripten's <a href="https://github.com/emscripten-core/emscripten/blob/main/src/settings.js">settings.js</a> file.
</p>

{{post.code("", "cmake",
`
add_library(r96 "src/r96/r96.c")
`
)}}

<p>
	Next we add a library target called <code>r96</code>. It's compiled from the <code>r96/r96.c</code> source file. Any re-usable code we write during the course of this blog post series will go in there. Any of our demo app executable targets can then depend on the <code>r96</code> library target to pull in its code.
</p>

{{post.code("", "cmake",
`
add_executable(r96_00_basic_window "src/00_basic_window.c")
target_link_libraries(r96_00_basic_window LINK_PUBLIC minifb r96)
`
)}}

<p>
	That's exactly what we do in the next two lines! First we declare an executable target for our first demo app called <code>r96_00_basic_window</code>. It's compiled from <code>00_basic_window.c</code> and links to the <code>minifb</code> and <code>r96</code> library targets. We'll follow this exact pattern for all future demo apps.
</p>

{{post.code("", "cmake",
`
if(EMSCRIPTEN)
    add_custom_target(r96_web_assets
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_CURRENT_SOURCE_DIR}/web
            ${CMAKE_CURRENT_BINARY_DIR}
    )

    add_dependencies(r96_00_basic_window r96_web_assets)
    target_link_options(r96_00_basic_window PRIVATE -sEXPORT_NAME=r96_00_basic_window)
endif()
`
)}}

<p>
	In the final section of the <code>CMakeLists.txt</code> file, we again do something emscripten specific. First, we add a custom target called <code>r96_web_assets</code>. It copies the files from the <code>web/</code> folder to the build output folder <code>build/</code>, so the <code>.html</code> file of each demo app ends up with its <code>.js</code> and <code>.wasm</code> counter parts in the <code>build/</code> folder.
</p>

<p>
	The <code>r96_web_assets</code> target is added as a dependency to the <code>r96_00_basic_window</code> demo app target. Anytime the demo app target is build through emscripten, the custom asset target will be executed as well.
</p>

<p>
	Finally, we add an emscripten specific linker flag <code>-sEXPORT_NAME</code> for the <code>r96_00_basic_window</code> target via <code>target_link_options()</code>. It specifies the module name by which the JavaScript code in the corresponding <code>.html</code> file can load and run the demo app's <code>.wasm</code> code.
</p>

<p>
	You can switch between the desktop and web build by simply choosing the corresponding kit aka compiler toolchain in the CMake UI in VS Code.
</p>

<h3>The first demo app: 00_basic_window</h3>

<p>
	Before we can get our hands dirty with programmatically creating the most beautiful pixels in the world, we need to understand how minifb works and how a demo app is structured in terms of code. With no further ado, here's <code>src/00_basic_window.c</code>:
</p>

{{post.code("00_basic_window.c", "c",
`
#include <MiniFB.h>
#include <stdlib.h>

int main(void) {
	const int res_x = 320, res_y = 240;
	struct mfb_window *window = mfb_open("00_basic_window", res_x, res_y);
	uint32_t *pixels = (uint32_t *) malloc(sizeof(uint32_t) * res_x * res_y);
	do {
		mfb_update_ex(window, pixels, res_x, res_y);
	} while (mfb_wait_sync(window));
	return 0;
}

`
)}}

<p>
	This is a minimal minifb app that opens a window with a drawing area of 320x240 pixels (line 6). It then allocates a buffer of 320x240 <code>unit32_t</code> elements (line 7). Each <code>uint32_t</code> element encodes the color of a pixel. Next, we keep drawing the contents of the buffer to the window via <code>mfb_update_ex()</code> (line 9) until <code>mfb_wait_sync()</code> returns false (line 10), e.g. because the user pressed the ESC key to quit the app. It can't get any simpler.
</p>

<h3>Running the demo app on the desktop</h3>

<p>
	To compile and run (or debug) our little demo app on the desktop, select the desktop compiler toolchain kit in the CMake UI at the bottom of VS Code, select the <code>r96_00_basic_window</code> target as the target that's going to be run, and finally click on the debug or play button, or run <code>CMake: Debug</code> or <code>CMake: Run Without Debugging</code> from the command palette. You'll get this:
</p>

{{post.figureMaxWidth("desktop.png", "r96_00_basic_window on the desktop.", "320px")}}

<p>
	Most impressive. Now how do we run the same demo app in the browser?
</p>

<h3>Running the demo app on the web</h3>

<p>
	First, select the emscripten kit in the CMake UI. Next, open a terminal in VS Code and start a web server. Yes, you read that right. Since you have Python installed it's easy:
</p>

{{post.code("", "bash",
"
python3 -m http.server --directory build
"
)}}

<p>
	The server serves all files in the <code>build/</code> folder and listens for incoming connections on port 80 on localhost. Opening <a href="https://localhost:8000">https://localhost:8000</a> in a browser will show you the <code>build/index.html</code> file. Keep the server running in the background while you work on the web version of a demo app.
</p>
<p>
	Next, click the <code>Build</code> button in the CMake GUI, or run the <code>CMake: Build</code> command from the command palette. This will copy the files from the <code>web/</code> folder over to the <code>build/</code> folder. It will also use emscripten to compile the demo app code (and its dependencies) to <code>.js</code> and <code>.wasm</code> files, which also get copied to the <code>build/</code> folder.
</p>

<p>Now open a browser, go to <a href="http://localhost:8000/00_basic_window.html">http://localhost:8000/00_basic_window.html</a> and tada!
</p>

{{post.figureMaxWidth("browser.png", "r96_00_basic_window running in the browser.", "80%")}}


<p class="note">
	<strong>Note:</strong> you can not use the debug or run functionality in VS Code, as the C/C++ extension doesn't know how to do that for emscripten generated "executables". If you want to test a code change, saved the changed source files, trigger a CMake build using the emscripten kit, and refresh the page in the browser.
</p>

<h3>How the web version works</h3>

<p>
	It's kind of magic. Here's how the <code>00_basic_window.html</code> file for the <code>00_basic_window.c</code> demo app looks like:
</p>

{{post.code("00_basic_window.html", "html",
"
<html>
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' href='r96.css'>
    <script src='r96_00_basic_window.js'></script>
</head>
<body class='r96_content'>
    <h2>Basic window</h2>
    <canvas id='00_basic_window'></canvas>
</body>
<script>
    async function init() {
        await r96_00_basic_window()
    }

    init();
</script>
</html>
"
)}}

<p>
	Ignoring the boring HTML boilerplate, we see that the <code>r96_00_basic_window.js</code> file is loaded via a <code>&lt;script&gt;</code> tag. Then we define a <code>&lt;canvas&gt;</code> with the id <code>00_basic_window</code>. A little JavaScript kicks of a call to <code>r96_00_basic_window()</code> in an asynchronous function. This call will load the <code>r96_00_basic_window.wasm</code> file and run its <code>main()</code> method.
</p>

<p>
	How does minifb know to render to the canvas? In our C code we have this line:
</p>

{{post.code("", "c",
`
struct mfb_window *window = mfb_open("00_basic_window", res_x, res_y);
`
)}}

<p>
	Instead of opening a window with "00_basic_window" as the title, the minifb web backend uses the first argument passed to <code>mfb_open()</code> to search a canvas element with that string as its id. Any calls to <code>mfb_update_ex()</code> will then draw the contents of the provided buffer to this canvas.
</p>

<p>
	Also of note: We didn't have to modify our C code at all, it just "works". If you've ever done any front-end development, that may be very weird to you. The app basically has an infinite loop! If you do that in JavaScript, the browser tab (or the whole browser) will freeze, because the browser engine's event loop will never get a chance to run and process events. How does this magic work?
</p>

<p>
	The minifb web backend I wrote uses an emscripten feature called <a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a>. In the implementation of <code>mfb_wait_sync()</code>, I call <code>emscripten_sleep(0)</code>. This gives back control to the browser engine, so it can process any DOM events and not freeze. Our native C code will then resume again, without our C code ever knowing that it was actually put to sleep. The Asyncify feature rewrites our C code (or rather its WASM representation) to use continuations. That allows pausing and resuming the C code transparently. Super cool!
</p>

<p>
	Bonus point: I use <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame()</code></a> as the "yielding" primitive. This means that our main loop will be synced to the screen refresh rate (unless the browser implements it as a software vsync, which is usually the case, but doesn't matter for our purpose).
</p>

<h3>Can I debug the C code in the browser?</h3>
<p>
	Yes, we can in Chrome. When we build using the debug variant, emscripten will emit DWARF information in the resulting <code>.wasm</code> file. Chrome can use that information to provide native code debugging right in the developer tools. To get that working:
</p>

<ul>
	<li>Install Chrome</li>
	<li>Install the <a href="https://chrome.google.com/webstore/detail/cc%20%20-devtools-support-dwa/pdcpmagijalfljmkmjngeonclgbbannb">C/C++ DevTools Support (DWARF) extension</a> in Chrome</li>
	<li>Open Chrome Developer Tools, click the gear (âš™) icon in the top right corner of dev tools pane, go to the experiments panel and tick <code>WebAssembly Debugging: Enable DWARF support</code>
	{{post.figureMaxWidth("chrome.png", "", "400px")}}
	</li>
	<li>Restart Chrome</li>
</ul>

<p>
	Make sure the demo app was build using the debug variant, (re-)load the demo app <code>.html</code> file in the browser, then open the dev tools, and click on the <code>Sources</code> tab. You can find all the <code>.c</code> files that make up our little demo app under the <code>file://</code> node, including the minifb sources. Open up <code>00_basic_window.c</code> and set a breakpoint inside the loop:
</p>

{{post.figureMaxWidth("chrome-debug.png", "C/C++ debugging in Chrome", "80%")}}

<p>
	And there you have it: C/C++ debugging in Chrome! Since the C code runs the same on both the desktop and in the browser, we'll likely never need this functionality, unless we implement web specific features.
</p>

<p>
	Speaking of features, let's add a second demo app and draw our first pixel! But first, some very practical "theory".
</p>

<h2>Of colors, pixels, and rasters</h2>

<p>
	What's a pixel? Rumor has it that pixel is a stylized abbreviation of "(pic)ture (el)ement". A precise answer is actually quite involved and may even depend on the decade you are living in.
</p>

<p>
	Here, we lazily and imprecisely define a pixel as the smallest "atomic" area within a raster for which we can define a color. A raster is a rectangular area made up  of pixels. Each pixel in the raster is assumed to have the same size. The width of a raster equals the number of pixels in a row, the height equals the number of pixels in a column. The below raster has a width of 23 pixels and a height of 20 pixels. To locate a pixel inside the raster, we use an integer coordinate system, with the x-axis pointing to the right, and the y-axis pointing down. The top left pixel in the raster is at coordinate <code>(0, 0)</code>, the top right pixel is at coordinate <code>(22, 0)</code> (or <code>(width - 1, 0)</code>), the bottom right pixel is at coordinate <code>(22, 19)</code> (or <code>(width - 1, height -1)</code>), and so on.
</p>

{{post.figureMaxWidth("raster.png", "A fishy raster. <a href='https://commons.wikimedia.org/wiki/File:Raster_graphic_fish_20x23squares_sdtv-example.png'>Source: Wikipedia</a>", "320px")}}

<p>
	A raster can be a display device's output area, a piece of grid paper, etc. The rasters we'll work with are two-dimensional arrays in memory. Each array element stores the color of the pixel in some encoding.
</p>

<h3>Color encodings</h3>

<p>
	We encode the color of a pixel using the <a href="https://en.wikipedia.org/wiki/RGBA_color_model">RGBA color model</a>, where a color is represented as an additive mix of its red, green, and blue components, and an additional alpha component specifying the pixel's opacity. The opacity comes into play when we blend pixels of one raster with pixels from another raster. That's a topic for another blog post.
</p>

<p>
	More specifically, we use an ARGB8888 encoding that fits in a 32-bit unsigned integer (or <code>uint32_t</code> in C). Each color component is encoded as an 8-bit integer in the range 0 (no contribution) to 255 (highest contribution). For the alpha component, 0 means "fully transparent" and 255 means "fully opaque".
</p>

<p>
	Here's how the components are stored in a 32-bit unsigned integer. The most significant byte stores the alpha component, then come the red, green, and blue bytes.
</p>

{{post.figure("argb8888.png", "Storage layout of an ARGB8888 color in a 32-bit unsigned integer. <a href='https://commons.wikimedia.org/wiki/File:PixelSamples32bppRGBA.png'>Source: Wikipedia</a>")}}

Here are a few colors in C:

{{post.code("", "c",
"
uint32_t red = 0xffff0000;
uint32_t green = 0xff00ff00;
uint32_t blue = 0xff0000ff;
uint32_t pink = 0xffff00ff;
uint32_t fifty_percent_transparent_white = 0x80ffffff;
"
)}}

<p>
	More generally, we can compose a color by bit shifting and or'ing its individual components:
</p>

{{post.code("", "c",
"
uint8_t alpha = 255; // fully opaque
uint8_t red = 20;    // a little red
uint8_t green = 200; // a lot of green
uint8_t blue = 0;    // no blue
uint32_t color = (alpha << 24) | (red << 16) | (green << 8) | blue;
"
)}}

<p>
	That looks like a great candidate for a re-usable macro! Why a macro? Because C99 support in Microsoft's C++ compiler is still meh and who knows how it does with inlined functions defined in a header. The macro guarantees that the code is inlined at the use site. Let's put the following in <code>src/r96/r96.h</code>
</p>

{{post.code("", "c",
"
#include <stdint.h>

#define R96_ARGB(alpha, red, green, blue) (((uint8_t)alpha << 24) | ((uint8_t)red << 16) | ((uint8_t)green << 8) | (uint8_t)blue)

"
)}}

<p>
	Defining a color then becomes:
</p>

{{post.code("", "c",
"
uint32_t color = R96_ARGB(255, 20, 200, 0);
"
)}}

<h3>Adressing a pixel in a raster</h3>

<p>
	We now can define colors easily. But how do we work with rasters in code and manipulate the colors of its pixels? We already did! Remember this line from our <code>00_basic_window</code> demo app?
</p>

{{post.code("", "c",
"
const int res_x = 320, res_y = 240;
...
uint32_t *pixels = (uint32_t *)malloc(res_x * res_y * sizeof(uint32_t))
"
)}}

<p>
	This allocates memory to store a 320x240 raster where each pixel is stored in a <code>uint32_t</code>. Each row of pixels is stored after the other. We can think of it as a one-dimensional array storing a two-dimensional raster.
</p>

<p>
This raster is passed to <code>mfb_update_ex()</code> to be drawn to the window. The reason the window content remains black is that the pixels all have the color <code>0x00000000</code> aka black (at least when building the debug variant or for emscripten).
</p>

<p>
	We can set the pixel in the top left corner at coordinate <code>(0, 0)</code> to the color red like this:
</p>

{{post.code("", "c",
"
pixels[0] = R96_ARGB(255, 255, 0, 0);
"
)}}

<p>
	OK, that was obvious. But how about a pixel at an arbitrary coordinate? Let's look at a smaller 4x3 pixel raster:
</p>

<div id="coords_to_index"></div>
<script>
let resX = 920, resY = 200;
let q5 = q5Diagram(920, 200, "coords_to_index")
let w = 40; h = 40;
q5.translate(w * 2, resY / 2 - (h * 3) / 2)
colors = [ "#b00", "#020", "#00b"]
q5.textAlign(q5.CENTER, q5.CENTER)
for (y = 0; y < 3; y++) {
    for(x = 0; x < 4; x++) {
        q5.stroke("black")
        q5.fill(colors[y])
        q5.rect(x * w, y * h, w, h);
        q5.fill("#bbb")
        q5.noStroke()
        q5.text("(" + x + "," + y + ")", x * w + w / 2, y * h + h / 2)
    }
}
q5.resetMatrix()

q5.fill("#bbb")
q5.text("width = 4", 160, 20)
q5.text("height = 3", 35, 100)

q5.text("index = x + y * width", 8 * w, 80)
q5.text("uint32_t *pixels", 16 * w, 60)

q5.strokeWeight(2)
q5.stroke("#bbb")
q5.line(6 * w + w / 2, 100, 10 * w - w / 2, 100)
q5.triangle(10 * w - w / 2, 100, 10 * w - w / 2 - 10, 95, 10 * w - w / 2 - 10, 105)
q5.strokeWeight(1)

q5.translate(w * 4 + w * 4 + w * 2, resY / 2 - h / 2)
let rx = 0
for (y = 0; y < 3; y++) {
    for(x = 0; x < 4; x++) {
        q5.stroke("black")
        q5.fill(colors[y])
        q5.rect(rx, 0, w, h);
        q5.fill("#bbb")
        q5.noStroke()
        q5.text("" + rx / w, rx + w / 2, h / 2)
        rx += w
    }
}
q5.resetMatrix()
</script>

<p>
Our raster is a one dimensional block of memory. The pixel rows are stored one behind the other. The 4 pixels of the first pixel row with <code>y=0</code> are stored in <code>pixels[0]</code> to <code>pixels[3]</code>. The index of a pixel in the first row is simply its x-coordinate. E.g. the pixel at coordinate <code>(2, 0)</code> is stored in <code>pixels[2]</code>.
</p>

<p>The pixels of the second row with <code>y=1</code> are stored in <code>pixels[4]</code> to <code>pixels[7]</code>. The pixels of the third row with <code>y=2</code> are stored in <code>pixels[8]</code> to <code>pixels[11]</code>. In general, the first pixel of a row at y-coordinate <code>y</code> is located at <code>pixels[y * width]</code>. And to address any pixel inside a row, we just add its x-coordinate! The general formula to go from a pixel's <code>(x, y)</code> coordinate to an index in the one dimensional array representing the raster is thus <code>x + y * width</code>!
</p>

<p class="note">
	<strong>Note:</strong> this is how C implements two-dimensional arrays under the hood as well. The principle also applies to higher dimensional arrays.
</p>

<p>
	If we want to set the color of the pixel at <code>(160, 120)</code> to red in our 320x240 pixel raster, we can do it like this:
</p>

{{post.code("", "c",
"
const int res_x = 320, res_y = 240;
...
pixels[160 + 120 * res_x] = R96_ARGB(255, 255, 0, 0);
"
)}}

<p>Alright, time to draw some pixels!</p>

<h3>Demo app: drawing a pixel</h3>

<p>
	Let's add a new demo app to draw a pixel:
</p>

<ul>
	<li>Add a file <code>src/01_drawing_a_pixel.c</code> and copy the contents from <code>src/00_basic_window.c</code> to it
		<ul>
			<li>Change the first argument to <code>mfb_open()</code> to <code>"01_drawing_a_pixel"</code></li>
		</ul>
	</li>
	<li>Add a file to <code>web/01_drawing_a_pixel.html</code> and copy the contents from <code>web/00_basic_window.html</code> to it
		<ul>
			<li>Change the <code>src</code> of the <code>&lt;script&gt;</code> element to <code>'r96_01_drawing_a_pixel.js'</code></li>
			<li>Change the canvas <code>id</code> to <code>'01_drawing_a_pixel'</code></li>
			<li>Change the call to <code>r96_00_basic_window()</code> to <code>r96_01_drawing_a_pixel()</code></li>
		</ul>
	</li>
	<li>In the <code>web/index.html</code> file, add a link to <code>01_drawing_a_pixel.html</code></li>
	<li>In the <code>CMakeLists.txt</code> file
		<ul>
			<li>Add a new executable target in the <code>CMakeLists.txt</code> file after the definition of the <code>r96_00_basic_window</code> executable target:
			{{post.code("CMakeLists.txt", "cmake",
`
add_executable(r96_01_drawing_a_pixel "src/01_drawing_a_pixel.c")
target_link_libraries(r96_01_drawing_a_pixel LINK_PUBLIC minifb r96)
`
			)}}</li>
			<li>
				Add the custom <code>r96_web_assets</code> target as a dependency to the <code>r96_01_drawing_a_pixel</code> target, and set the <code>EXPORT_NAME</code> linker flag to <code>r96_01_drawing_a_pixel</code>:
		{{post.code("CMakeLists.txt", "cmake",
"
add_dependencies(r96_01_drawing_a_pixel r96_web_assets)
target_link_options(r96_00_basic_window PRIVATE -sEXPORT_NAME=r96_01_drawing_a_pixel)
"
	)}}
			</li>
		</ul>
	</li>
</ul>

<p class="note">
	Going forward, anytime we add a new demo app, we'll repeat the above process. I won't spell it out in detail, but simply state the demo app's name, from which we can derive all the file names and ids needed.
</p>

<p>
	Drawing a single pixel is a bit boring, so how about we flood the screen with a gazillion pixels instead?
</p>

{{post.code("01_drawing_a_pixel.c", "c",
`
#include <MiniFB.h>
#include <stdlib.h>
#include <string.h>
#include "r96/r96.h"

int main(void) {
	const int res_x = 320, res_y = 240;
	struct mfb_window *window = mfb_open("01_drawing_a_pixel", res_x, res_y);
	uint32_t *pixels = (uint32_t *) malloc(sizeof(uint32_t) * res_x * res_y);
	do {
		for (int i = 0; i < 200; i++) {
			int32_t x = rand() % res_x;
			int32_t y = rand() % res_y;
			uint32_t color = R96_ARGB(255, rand() % 255, rand() % 255, rand() % 255);
			pixels[x + y * res_x] = color;
		}

		if (mfb_get_mouse_button_buffer(window)[MOUSE_BTN_1]) {
			memset(pixels, 0, sizeof(uint32_t) * res_x *  res_y);
		}

		mfb_update_ex(window, pixels, res_x, res_y);
	} while (mfb_wait_sync(window));
	return 0;
}
`
)}}

<p>
	The interesting bit happens in lines 10 to 15. Each frame, we generate 200 pixels at random coordinates with random colors. We ensure that the coordinates are within the raster bounds by <code>% res_x</code> and <code>% res_y</code>. We also clamp the color components to the range 0-255 via modulo.
</p>

<p>
	We also introduce some light input handling by checking if the left mouse button is pressed. If so, we set all pixels to the color black, giving the "user" a way to restart the glorious demo.
</p>

<p>
	And here it is live in your browser, because why would we spend so much time getting the WASM build to work so nicely. Click/touch to start!
</p>

<div style="display: flex; flex-direction: column; align-items: center; margin: 1em; max-width: 100%;">
	<canvas id="01_drawing_a_pixel" width="640" heigh="480" style="width: 100%; aspect-ratio: 640 / 480; background: black;"></canvas>
</div>
<script src="demo/r96_01_drawing_a_pixel.js"></script>
<script>
	let canvas = document.getElementById("01_drawing_a_pixel")
	let ctx = canvas.getContext("2d");
	ctx.font = "18px monospace";
	ctx.textAlign = "center";
	ctx.fillStyle = "white";
	ctx.fillText("Click/tap to start", canvas.width / 2, canvas.height / 2);

	let started = false;
	let init = async () => {
		if (started) return;
		started = true;
		await r96_01_drawing_a_pixel();
	}
	document.getElementById("01_drawing_a_pixel").addEventListener("click", () => init());
</script>

<p>
	I sure feel all this build up paid off, don't you?
</p>

<p>
	You can checkout the <code>babys-first-pixel-01</code> tag and diff it against the <code>babys-first-pixel-00</code> tag to view all the code changes that were made to add this demo.
</p>

{{post.code("", "bash",
"
git checkout babys-first-pixel-01
"
)}}

<h2>Mario, WTF</h2>
<p>
	Yeah, I'm sorry. I sometimes just drift off. But we learned a lot! Next time I likely won't be so wordy. We'll have a looksy at how to draw rectangles. Exciting!
</p>

<p>
	Discuss this post on <a href="https://twitter.com/badlogicgames/status/1598843445472550912">Twitter</a> or <a href="">Mastodon</a>.
</p>

<script>tableOfContents()</script>

{{include "../../../_templates/post_footer.bt.html"}}