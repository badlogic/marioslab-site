{{
metadata = {
	title: "Qak - Minimally viable product",
	summary: "",
	image: "mvp.jpg",
	date: parseDate("2020/06/26 23:00"),
	published: true,
}
}}
<!-- Hi! -->

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}

{{post.figure("mvp.jpg", "Language goes Brrrr.")}}

<h2>Qak 0.1</h2>

<p>
	Alrighty. With all the basics out of the way as described in the <a href="https://marioslab.io/posts/qak/humble-beginnings/">last Qak post</a>, it's time to define a minimal language I want to implement. This v0.1 will only contain the absolute mininum language features needed to get the infrastructure composed of tokenizer, parser, AST, type checker, byte code generator, and interpreter going. Ideally, I can also build the debugger interface for this.
</p>

<p>
	Once all these components are in place for language version 0.1, I hope to be able to iterate quickly, adding new language, interpreter and standard library features. I've used this iterative approach for previous (toy) language projects and it's so far worked pretty well. It's also a surefire way to run into dead ends, which means I get to document my back tracking and failures.
</p>

<h2>v0.1 language features</h2>
<p>
	Before we dive into the semantics and syntax bike shed, let me quickly lay out the planned high level language features for v0.1.
</p>

<ul>
	<li>Types: <code>boolean</code>, <code>int32</code>, <code>float32</code>, <code>nothing</code>.</li>
	<li>Functions, operators, and overloading.</li>
	<li>Basic expressions</li>
	<li>Basic control flow statements</li>
	<li>Foreign function interface.</li>
	<li>Modules.</li>
	<li>Module <code>std</code>, containing <code>print()</code> and maybe a handful of other things.</li>
</ul>

<p>
Let's look at these in more detail.
</p>

<h3>Types and values</h3>
<p>
	Only supporting two primitive types in the beginning makes things significantly simpler. <code>boolean</code> is needed for conditionals. <code>int32</code> and <code>float32</code> are what you'd expect, with the values (<code>true</code>, <code>false</code>, <code>123</code>, <code>123.456</code>, ...) you know and love.
</p>

<p>
	Why not just <code>int32</code>? Because it complicates the type checker just an itsy bit more, which may lay bare issues earlier in the development process. Having both an integer and float type also forces me to figure out if and what type conversions I want to have in Qak.
</p>

<p>
	<code>nothing</code> is there to indicate that a function returns, well, nothing. It has a single value: <code>nothing</code>.
</p>

<p>
	These types are built into the language and have no explicit definition in form of Qak source code. In later language versions, I'll try to keep the number of built-in types to a minimum. Types like the inevitable <code>string</code>, <code>list</code>, or <code>map</code> will hopefully be expressible by the built-in types.
</p>

<p>
	v0.1 of Qak will only allow the definition of <code>foreign</code> types. These are types of which the full definition must be provided to the compiler outside of a <code>.qak</code> source file. They must be declared in the module they belong to like this (<code>std.qak</code>):</code>
</p>

<pre><code>module std
foreign type boolean
foreign type int32
foreign type float32
</code></pre>

<p>
	Why have them explicitely in a <code>.qak</code> file like that at all? You'll see in the next section on functions an operators.
</p>

<p>
	v0.1 will also not include any string or collection types, which keeps the scope small. The v0.1 types don't require me to implement a GC, which is nice. It's also an open invitation to walk right into a dead end. We'll see how that works out.
</p>

<h3>Functions, operators, and overloading</h3>
<p>
	A function is a piece of code that has a name, (optional) arguments, and a return type. I don't particularly care for the syntax, but here we go:
</p>

<pre><code>function add(a: int32, b: int32): int32
	return a + b
end
</code></pre>

<p>Omitting the return type means the function returns <code>nothing</code> (which can of course also be specified explicitely.</p>

<p>
	A pretty standard affair, with the notable exception that Qak won't be a curly based language, at least not for statement/block delimitation. Instead we write it all out and will like it. I believe this to be friendlier to beginners, but we'll see.
</p>

<p>
	Surprise: operators and functions are the same thing. It's just that operators have syntactic sugar, i.e. they can be called by infix notation ala <code>2 + 3</code>, instead of <code>+(2, 3)</code> (looks familiar, eh?).
</p>

{{include "../../../_templates/post_footer.bt.html"}}