{{
metadata = {
	title: "Qak - Minimally viable product",
	summary: "",
	image: "mvp.jpg",
	date: parseDate("2020/06/26 23:00"),
	published: true,
}
}}
<!-- Hi! -->

{{include "../../../_templates/post_header.bt.html"}}
{{include "../../../_templates/post_header.bt.html" as post}}

{{post.figure("mvp.jpg", "Language goes Brrrr.")}}

<h2>Qak 0.1</h2>

<p>
	Alrighty. With all the basics out of the way as described in the <a href="https://marioslab.io/posts/qak/humble-beginnings/">last Qak post</a>, it's time to define a minimal language I want to implement. This v0.1 will only contain the absolute mininum language features needed to get the infrastructure composed of tokenizer, parser, AST, type checker, byte code generator, and interpreter going. Ideally, I can also build the debugger interface for this.
</p>

<p>
	Once all these components are in place for language version 0.1, I hope to be able to iterate quickly, adding new language, interpreter and standard library features. I've used this iterative approach for previous (toy) language projects and it's so far worked pretty well. It's also a surefire way to run into dead ends, which means I get to document my back tracking and failures.
</p>

<h2>v0.1 language features</h2>
<p>
	Before we dive into the semantics and syntax bike shed, let me quickly lay out the planned high level language features for v0.1.
</p>

<ul>
	<li>Basic and values.</li>
	<li>Functions, operators, overloading, and foreign function interface</li>
	<li>Basic statements.</li>
	<li>Modules.</li>
	<li>Minimal standard library.</li>
</ul>

<p>
Let's look at these in more detail.
</p>

<h2>Types and values</h2>
<p>
	Only supporting two primitive types in the beginning makes things significantly simpler. <code>boolean</code> is needed for conditionals. <code>int32</code> and <code>float32</code> are what you'd expect, with the values (<code>true</code>, <code>false</code>, <code>123</code>, <code>123.456</code>, ...) you know and love.
</p>

<p>
	Why not just <code>int32</code>? Because it complicates the type checker just an itsy bit more, which may lay bare issues earlier in the development process. Having both an integer and float type also forces me to figure out if and what type conversions I want to have in Qak.
</p>

<p>
	<code>nothing</code> is there to indicate that a function returns, well, nothing. It has a single value: <code>nothing</code>.
</p>

<p>
	These types are built into the language and have no explicit definition in form of Qak source code. In later language versions, I'll try to keep the number of built-in types to a minimum. Types like the inevitable <code>string</code>, <code>list</code>, or <code>map</code> will hopefully be expressible by the built-in types.
</p>

<p>
	v0.1 of Qak will only allow the definition of <code>foreign</code> types. These are types of which the full definition must be provided to the compiler outside of a <code>.qak</code> source file. They must be declared in the module they belong to like this (<code>std.qak</code>):</code>
</p>

<pre><code>module std

foreign type boolean
foreign type int32
foreign type float32
</code></pre>

<p>
	Why have them explicitely in a <code>.qak</code> file like that at all? You'll see in the next section on functions an operators.
</p>

<p>
	v0.1 will also not include any string or collection types, which keeps the scope small. The v0.1 types don't require me to implement a GC, which is nice. It's also an open invitation to walk right into a dead end. We'll see how that works out.
</p>

<h2>Functions, operators, overloading, and foreign function interface</h2>
<p>
	A function is a piece of code that has a name, (optional) arguments, and a return type. I don't particularly care for the syntax, but here we go:
</p>

<pre><code>function foo(a: int32, b: int32): int32
	...
end
</code></pre>

<p>Omitting the return type means the function returns <code>nothing</code> (which can of course also be specified explicitely.</p>

<p>
	A pretty standard affair, with the notable exception that Qak won't be a curly based language, at least not for statement/block delimitation. Instead we write it all out and will like it. I believe this to be friendlier to beginners, but we'll see.
</p>

<p>
	Surprise: operators and functions are the same thing. It's just that operators have syntactic sugar, i.e. they can be called by infix notation ala <code>2 + 3</code>, instead of <code>+(2, 3)</code> (looks familiar, eh?).
</p>

<p>
	The whole range of operators for our built-in types are expressed as functions. The precedence of operators is fixed and part of the language definition. Making that configurable seems like a lot of pain. The supported operators consist of the standard logical and arithmetic operators you are used to from other languages, including unary, binary, and ternary operators.
</p>

<p>
	Going back to our <code>std.qak</code> file, which defines the built-in types, it comes as no surprise that the operators are defined there as well, namely as <code>foreign</code> functions, the implementation of which must be provided to interpreter later on.
</p>

<pre><code>module std

foreign type boolean
foreign type int32
foreign type float32

foreign function !(a:boolean): boolean
foreign function &&(a: boolean, b: boolean): boolean
...
foreign function ==(a:float32, b: float32): boolean
...
foreign function +(a: int32, b: int32): int32
foreign function *(a: int32, b: int32): int32
...
foreign function +(a: float32, b: float32): float32
</code></pre>

<p>
	Should the compiler find an expression like <code>3 + 2</code>, it will see if there's a function defined for that operator with those 2 input types, and insert a call to that function in the generated code.
</p>

<p>
	What about <code>3.0 + 2</code>, the addition of a <code>float32</code> and <code>int32</code>? I can't possibly create operator functions for all permutations of input types. So I'll rely on explicit casting for now. The expression <code>3.0 + 2</code> will throw a compiler error, as no function <code>+(a: float32, b: int32): float32</code> will be defined. Instead a user is expected to explicitely cast one of the operands to the type of the other, e.g. <code>3.0 + toFloat32(2)</code>. I might add some compiler sugar to insert automatic casts. For now everything is explicit.
</p>

<p>
	Functions can also be overloaded based on their argument type. I could include the return type in this mechanism, but my gut tells me that leads to evil things. We'll see!
</p>

<h2>Basic statements</h2>
<p>
	Many languages de jour treat almost anything as expressions that evaluate to a value, including control flow statements like <code>if</code>. Qak won't do that. Instead, it provides a handful of statements that do not produce a value, and also allow you to liter your functions with naked expressions:
</p>

<pre><code>
// variable declaration with initializers and simple type inference
// Variables without initializer will be initialized to the type's
// default value.
var foo = 123
var bar: boolean = true
var zeroInitializer: int32

// While statement, who needs for(-each)?!
while(bar)
	// Variables are block scoped
	var uff = 3

	// If statement
	if (foo > 200) then
		// Assignments
		bar = false
	else
		// arbitrary expressions (Which includes things
		// like function calls. The value generated by
		// the expression is simply discarded.
		print(foo)
		foo + 34 * zeroInitializer

		if (shouldWeStop()) then
			// break and continue (not pictured here)
			break
		end
	end

	foo = foo + 1
end

// return statement
return foo * 10
</code></pre>

<p>
	There's plenty in the above code that will force me to build a good infrastructure basis for the interpreter.
</p>

<h2>Modules</h2>
<p>
	The compilation unit of Qak is the module, a single file with a module definition at the top, as we've seen in <code>std.qak</code> above. A module consists of:
</p>

<ul>
	<li>Type definitions. For now only <code>foreign</code> types are possible.</li>
	<li>Function definitions.</li>
	<li>Module variable definitions.</li>
</ul>

<p>
	A module can import other modules, as long as the resulting graph of imports is acyclic. I'm sure this is a terrible idea, but I'll go with it for now. All modules import the <code>std</code> module by default.
</p>

<p>
	Importing a module is done like this: <code>import someModuleName</code>. I'll cross the "how the hell do you resolve modules?" bridge later. To avoid name clashes between things from an imporated module and the current module, one can do <code>import someModuleName as foo</code>, and access things from that module via <code>foo.thing</code>.
</p>

<p>
	Any type, function, or variable with a name starting with <code>_</code> is considered private to the module. Anything else can be accessed by other modules. Again, this is likely a terrible idea. An explicit <code>private</code> specifier might be better.
</p>

<h2>Standard library</h2>
<p>
	The standard library will be exceptionally minimal. It will define the (<code>foreign</code>) built-in types and their operators, common type conversion functions, and a handful of <code>print()</code> overloads, one for each type.
</p>

<h2>Up next</h2>
<p>This should be enough to create a contrived factorial nano benchmark to compare Qak against the likes of Lua and Python. Next time we'll look at the implementation of the parser and generation of the abstract syntax tree for the poor excuse of a language specification outlined above.</p>

<p>Discuss this post by replying to <a href="">this tweet.</a></p>

{{include "../../../_templates/post_footer.bt.html"}}