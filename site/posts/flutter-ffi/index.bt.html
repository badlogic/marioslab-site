{{
metadata = {
	title: "C/C++ code in your Flutter app on desktop, mobile, and <blink style='color: red'>WEB</blink> through dart:ffi and WASM",
	summary: "A guided tour on how to achieve what the title says, cause the documentation is lacking.",
	image: "god.jpeg",
	date: parseDate("2022/11/24 21:00"),
	published: false,
}
}}

{{include "../../_templates/post_header.bt.html"}}
{{include "../../_templates/post_header.bt.html" as post}}

<style>
blink {
	animation: 1.2s linear infinite condemned_blink_effect;
}

@keyframes condemned_blink_effect {
	0% { visibility: hidden; }
	50% { visibility: hidden; }
	100% { visibility: visible; }
}
</style>

{{post.figure("god.jpeg", "This blog post is dedicated to things I wished existed.")}}

<p>
Hi, long time no see. I didn't build the game I was fantasizing about. I did however build a <a href="https://ulang.io/editor/9af0e00d809a3aec8f33181d1194596c">DOS-like online development environment</a> where you can write made-up assembly to create little demos. It even has a stepping debugger. Kind of like Codepen for masochists. But I digress.
</p>

<p>
I'm currently building a <a href="https://esotericsoftware.com">Spine</a> runtime for <a href="https://flutter.dev/">Flutter</a>, so you can load and render your fancy 2D skeletal animations in your even fancier cross-platform mobile (or desktop, or web) Flutter apps. The runtimes core is C++, so I needed to figure out how to get my Dart code to talk to C++ and then publish the whole thing as a package to <a href="https://pub.dev">pub.dev</a>  for others to easily consume.
</p>
<p>
Since documentation on this is a bit sparse and partially wrong, I figured I'd write a little guide on how to create a Flutter FFI plugin that you can deploy as a package to with support for desktop, mobile, and web.
</p>

<h2>Talking to native code from Dart: dart:ffi and web_ffi</h2>

<p>
The good people working on Dart built <a href="https://dart.dev/guides/libraries/c-interop">dart:ffi</a>, a pretty Dart API (aka <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a>) you can use to call into native code you bundle with your app in form of a shared library. It works on desktop and mobile, but not in the browser. Luckily, I found a package called <a href="https://github.com/EPNW/web_ffi/">web_ffi</a>, which emulates dart:ffi on the web. Instead of a shared library, the "native" code is stored in and accessed from a WASM module file by the browser. Neat.
</p>

<p>
Unfortunately, it's a bit outdated and only supports dart:ffi version 2.12.0 with a bunch of caveats. It also doesn't work with the latest output generated by <a href="https://emscripten.org/">emscripten</a>, the compiler toolchain usually used to compile C/C++ to WASM. For the remainder of this blog post, we'll thus work with my fork of web_ffi, which you can find under <a href="https://pub.dev/packages/web_ffi_fork">pub.dev/packages/web_ffi_fork</a>.
</p>

<p>
Like pretty much all FFIs, dart:ffi and web_ffi only allow you to call into C functions for <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> reasons. If you want to expose C++ or Rust code, you'll have to write or generate a C wrapper around it. I leave that as an exercise to you, dear reader. I usually write a minimal C wrapper around my C++ code. In case of the Spine Flutter runtime, <a href="https://github.com/EsotericSoftware/spine-runtimes/blob/4.2-beta/spine-flutter/src/spine_flutter.h">the C wrapper which is exposed to Dart came out a little less minimal</a>.
</p>

<p>
As you can see, the C API of the Spine Flutter runtime doesn't expose any structs, only <a href="https://github.com/EsotericSoftware/spine-runtimes/blob/4.2-beta/spine-flutter/src/spine_flutter.h#L57">opaque handles</a>, which boil down to pointers to C++ structs and classes. Fields are accessed by setter and getter functions. Concrete values are expressed through plain old data types limited to <code>char</code>, integer types from <code>stdint.h</code> like <code>uint16_t</code> or <code>int32_t</code>, <code>float</code> and <code>double</code>, and pointers of these types.
</p>

<p>
This "design" may seem cumbersome, but it has benefits and is even a requirement when using web_ffi, which does not support <a href="https://api.flutter.dev/flutter/dart-ffi/Struct-class.html">structs like dart:ffi</a>. If you build your own Flutter FFI plugin that should also work on the web, you'll have to follow this format. This also likely means that you can't use a C bindings generator for your C++ or Rust code, as these will not limit themselves to what is outlined above.
</p>

<p>
For the purpose of this blog post, we'll need a simple C API that does something. I've written a terrible raycaster, consisting of the files 'raycaster.h' and 'raycaster.cpp', shown below in their full glory.
</p>

<pre><code>
</code></pre>

<pre><code>	
</code></pre>

{{include "../../_templates/post_footer.bt.html"}}