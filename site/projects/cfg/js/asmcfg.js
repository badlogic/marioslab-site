"use strict";
var asmcfg = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            var value = array2[index];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach(array2, iteratee) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (iteratee(array2[index], index, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          while (length--) {
            if (iteratee(array2[length], length, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (!predicate(array2[index], index, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          return !!length && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (comparator(value, array2[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array2, iteratee) {
          var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array2[index], index, array2);
          }
          return result;
        }
        function arrayPush(array2, values) {
          var index = -1, length = values.length, offset = array2.length;
          while (++index < length) {
            array2[offset + index] = values[index];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array2[index], index, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array2[length], length, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (predicate(array2[index], index, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array2[index], index, array2)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array2.length;
          while (++index < length) {
            if (comparator(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSum(array2, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer) {
          var length = array2.length;
          array2.sort(comparer);
          while (length--) {
            array2[length] = array2[length].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index = -1, length = array2.length;
          while (++index < length) {
            var current = iteratee(array2[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array2, placeholder) {
          var length = array2.length, result = 0;
          while (length--) {
            if (array2[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array2, placeholder) {
          var index = -1, length = array2.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array2[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array2[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index = fromIndex - 1, length = array2.length;
          while (++index < length) {
            if (array2[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array2[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root2._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap && new WeakMap();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array2[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length = array2.length;
            return length ? array2[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array2, n) {
            return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray(array2));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array2, key) {
            var length = array2.length;
            while (length--) {
              if (eq(array2[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower2, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower2 !== undefined2) {
                number = number >= lower2 ? number : lower2;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array2, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index = -1, length = array2.length;
            while (++index < length) {
              var value = array2[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start, end) {
            var length = array2.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array2[start++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array2, depth, predicate, isStrict, result2) {
            var index = -1, length = array2.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array2[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap(array2, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
            }
            array2 = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array2, n) {
            var length = array2.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array2[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array2, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
            if (array2 === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array2, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array2) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length = array2 ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array2, index, 1);
                } else {
                  baseUnset(array2, index);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower2, upper) {
            return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array2 = values(collection);
            return shuffleSelf(array2, baseClamp(n, 0, array2.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array2, start, end) {
            var index = -1, length = array2.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array2[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array2[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index = -1, length = array2.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array2);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length = array2.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array2 = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array2, start, end) {
            var length = array2.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array2 : baseSlice(array2, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root2.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array2) {
            var index = -1, length = source.length;
            array2 || (array2 = Array2(length));
            while (++index < length) {
              array2[index] = source[index];
            }
            return array2;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array2);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array2, other);
            stack.set(other, array2);
            while (++index < arrLength) {
              var arrValue = array2[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array2);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
            while (length--) {
              var data = array2[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array2) {
            var length = array2.length, result2 = new array2.constructor(length);
            if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
              while (++index < length) {
                array2[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array2);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
            while (length--) {
              var index = indexes[length];
              array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array2;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array2, size2) {
            var index = -1, length = array2.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array2[rand];
              array2[rand] = array2[index];
              array2[index] = value;
            }
            array2.length = size2;
            return array2;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array2, size2, guard) {
            if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array2 == null ? 0 : array2.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array2, index, index += size2);
            }
            return result2;
          }
          function compact(array2) {
            var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array2[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array2 = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array2, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array2, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function dropRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array2, value, start, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
          }
          function flatten(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, INFINITY) : [];
          }
          function flattenDepth(array2, depth) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array2, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined2;
          }
          function indexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array2, value, index);
          }
          function initial(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? array2[length - 1] : undefined2;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
          }
          function nth(array2, n) {
            return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array2, values2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
          }
          function pullAllBy(array2, values2, iteratee2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values2, comparator) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array2[index];
              if (predicate(value, index, array2)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice(array2, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array2, start, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index = baseSortedIndex(array2, value);
              if (index < length && eq(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index = baseSortedIndex(array2, value, true) - 1;
              if (eq(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 1, length) : [];
          }
          function take(array2, n, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function takeRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length = 0;
            array2 = arrayFilter(array2, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array2, baseProperty(index));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length && !array2.length) {
                array2.push(undefined2);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter2(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey2 = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array2 = args[start], otherArgs = castSlice(args, 0, start);
              if (array2) {
                arrayPush(otherArgs, array2);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower2, upper) {
            if (upper === undefined2) {
              upper = lower2;
              lower2 = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower2 !== undefined2) {
              lower2 = toNumber(lower2);
              lower2 = lower2 === lower2 ? lower2 : 0;
            }
            return baseClamp(toNumber(number), lower2, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower2, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower2 == "boolean") {
                floating = lower2;
                lower2 = undefined2;
              }
            }
            if (lower2 === undefined2 && upper === undefined2) {
              lower2 = 0;
              upper = 1;
            } else {
              lower2 = toFinite(lower2);
              if (upper === undefined2) {
                upper = lower2;
                lower2 = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower2 > upper) {
              var temp = lower2;
              lower2 = upper;
              upper = temp;
            }
            if (floating || lower2 % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower2, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array2) {
            return baseMean(array2, identity);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey2;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter2;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find2;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root2._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root2._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/graphlib-dot/lib/lodash.js
  var require_lodash2 = __commonJS({
    "node_modules/graphlib-dot/lib/lodash.js"(exports, module) {
      var lodash;
      if (__require) {
        try {
          lodash = require_lodash();
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/graphlib-dot/lib/dot-grammar.js
  var require_dot_grammar = __commonJS({
    "node_modules/graphlib-dot/lib/dot-grammar.js"(exports, module) {
      module.exports = function() {
        function peg$subclass(child, parent) {
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
        }
        function SyntaxError(message, expected, found, offset, line, column) {
          this.message = message;
          this.expected = expected;
          this.found = found;
          this.offset = offset;
          this.line = line;
          this.column = column;
          this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError, Error);
        function parse2(input) {
          var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart, graphStmt: peg$parsegraphStmt }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = peg$FAILED, peg$c2 = null, peg$c3 = "{", peg$c4 = { type: "literal", value: "{", description: '"{"' }, peg$c5 = "}", peg$c6 = { type: "literal", value: "}", description: '"}"' }, peg$c7 = function(strict, type, id, stmts) {
            return { type, id, strict: strict !== null, stmts };
          }, peg$c8 = ";", peg$c9 = { type: "literal", value: ";", description: '";"' }, peg$c10 = function(first, rest) {
            var result = [first];
            for (var i = 0; i < rest.length; ++i) {
              result.push(rest[i][1]);
            }
            return result;
          }, peg$c11 = function(type, attrs) {
            return { type: "attr", attrType: type, attrs: attrs || {} };
          }, peg$c12 = "=", peg$c13 = { type: "literal", value: "=", description: '"="' }, peg$c14 = function(k, v) {
            var attrs = {};
            attrs[k] = v;
            return { type: "inlineAttr", attrs };
          }, peg$c15 = function(id, attrs) {
            return { type: "node", id, attrs: attrs || {} };
          }, peg$c16 = function(lhs, rhs, attrs) {
            var elems = [lhs];
            for (var i = 0; i < rhs.length; ++i) {
              elems.push(rhs[i]);
            }
            return { type: "edge", elems, attrs: attrs || {} };
          }, peg$c17 = function(id, stmts) {
            id = id && id[2] || [];
            return { type: "subgraph", id: id[0], stmts };
          }, peg$c18 = function(first, rest) {
            var result = first;
            for (var i = 0; i < rest.length; ++i) {
              _.merge(result, rest[i][1]);
            }
            return result;
          }, peg$c19 = "[", peg$c20 = { type: "literal", value: "[", description: '"["' }, peg$c21 = "]", peg$c22 = { type: "literal", value: "]", description: '"]"' }, peg$c23 = function(aList) {
            return aList;
          }, peg$c24 = ",", peg$c25 = { type: "literal", value: ",", description: '","' }, peg$c26 = function(first, rest) {
            var result = first;
            for (var i = 0; i < rest.length; ++i) {
              _.merge(result, rest[i][3]);
            }
            return result;
          }, peg$c27 = "--", peg$c28 = { type: "literal", value: "--", description: '"--"' }, peg$c29 = function() {
            return directed;
          }, peg$c30 = void 0, peg$c31 = "->", peg$c32 = { type: "literal", value: "->", description: '"->"' }, peg$c33 = function(rhs, rest) {
            var result = [rhs];
            if (rest) {
              for (var i = 0; i < rest.length; ++i) {
                result.push(rest[i]);
              }
            }
            return result;
          }, peg$c34 = function(k, v) {
            var result = {};
            result[k] = v[3];
            return result;
          }, peg$c35 = function(id) {
            return { type: "node", id, attrs: {} };
          }, peg$c36 = function(id) {
            return id;
          }, peg$c37 = ":", peg$c38 = { type: "literal", value: ":", description: '":"' }, peg$c39 = "ne", peg$c40 = { type: "literal", value: "ne", description: '"ne"' }, peg$c41 = "se", peg$c42 = { type: "literal", value: "se", description: '"se"' }, peg$c43 = "sw", peg$c44 = { type: "literal", value: "sw", description: '"sw"' }, peg$c45 = "nw", peg$c46 = { type: "literal", value: "nw", description: '"nw"' }, peg$c47 = "n", peg$c48 = { type: "literal", value: "n", description: '"n"' }, peg$c49 = "e", peg$c50 = { type: "literal", value: "e", description: '"e"' }, peg$c51 = "s", peg$c52 = { type: "literal", value: "s", description: '"s"' }, peg$c53 = "w", peg$c54 = { type: "literal", value: "w", description: '"w"' }, peg$c55 = "c", peg$c56 = { type: "literal", value: "c", description: '"c"' }, peg$c57 = "_", peg$c58 = { type: "literal", value: "_", description: '"_"' }, peg$c59 = { type: "other", description: "identifier" }, peg$c60 = /^[a-zA-Z\u0200-\u0377_]/, peg$c61 = { type: "class", value: "[a-zA-Z\\u0200-\\u0377_]", description: "[a-zA-Z\\u0200-\\u0377_]" }, peg$c62 = /^[a-zA-Z\u0200-\u0377_0-9]/, peg$c63 = { type: "class", value: "[a-zA-Z\\u0200-\\u0377_0-9]", description: "[a-zA-Z\\u0200-\\u0377_0-9]" }, peg$c64 = function(fst, rest) {
            return fst + rest.join("");
          }, peg$c65 = "-", peg$c66 = { type: "literal", value: "-", description: '"-"' }, peg$c67 = ".", peg$c68 = { type: "literal", value: ".", description: '"."' }, peg$c69 = /^[0-9]/, peg$c70 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c71 = function(sign, dot, after) {
            return (sign || "") + dot + after.join("");
          }, peg$c72 = function(sign, before, after) {
            return (sign || "") + before.join("") + (after ? after[0] : "") + (after ? after[1].join("") : "");
          }, peg$c73 = '"', peg$c74 = { type: "literal", value: '"', description: '"\\""' }, peg$c75 = '\\"', peg$c76 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c77 = function() {
            return '"';
          }, peg$c78 = "\\", peg$c79 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c80 = /^[^"]/, peg$c81 = { type: "class", value: '[^"]', description: '[^"]' }, peg$c82 = function(ch) {
            return "\\" + ch;
          }, peg$c83 = function(id) {
            return id.join("");
          }, peg$c84 = "node", peg$c85 = { type: "literal", value: "node", description: '"node"' }, peg$c86 = function(k) {
            return k.toLowerCase();
          }, peg$c87 = "edge", peg$c88 = { type: "literal", value: "edge", description: '"edge"' }, peg$c89 = "graph", peg$c90 = { type: "literal", value: "graph", description: '"graph"' }, peg$c91 = "digraph", peg$c92 = { type: "literal", value: "digraph", description: '"digraph"' }, peg$c93 = "subgraph", peg$c94 = { type: "literal", value: "subgraph", description: '"subgraph"' }, peg$c95 = "strict", peg$c96 = { type: "literal", value: "strict", description: '"strict"' }, peg$c97 = function(graph) {
            directed = graph === "digraph";
            return graph;
          }, peg$c98 = { type: "other", description: "whitespace" }, peg$c99 = /^[ \t\r\n]/, peg$c100 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" }, peg$c101 = { type: "other", description: "comment" }, peg$c102 = "//", peg$c103 = { type: "literal", value: "//", description: '"//"' }, peg$c104 = /^[^\n]/, peg$c105 = { type: "class", value: "[^\\n]", description: "[^\\n]" }, peg$c106 = "/*", peg$c107 = { type: "literal", value: "/*", description: '"/*"' }, peg$c108 = "*/", peg$c109 = { type: "literal", value: "*/", description: '"*/"' }, peg$c110 = { type: "any", description: "any character" }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function text() {
            return input.substring(peg$reportedPos, peg$currPos);
          }
          function offset() {
            return peg$reportedPos;
          }
          function line() {
            return peg$computePosDetails(peg$reportedPos).line;
          }
          function column() {
            return peg$computePosDetails(peg$reportedPos).column;
          }
          function expected(description) {
            throw peg$buildException(
              null,
              [{ type: "other", description }],
              peg$reportedPos
            );
          }
          function error(message) {
            throw peg$buildException(message, null, peg$reportedPos);
          }
          function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
              var p, ch;
              for (p = startPos; p < endPos; p++) {
                ch = input.charAt(p);
                if (ch === "\n") {
                  if (!details.seenCR) {
                    details.line++;
                  }
                  details.column = 1;
                  details.seenCR = false;
                } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                  details.line++;
                  details.column = 1;
                  details.seenCR = true;
                } else {
                  details.column++;
                  details.seenCR = false;
                }
              }
            }
            if (peg$cachedPos !== pos) {
              if (peg$cachedPos > pos) {
                peg$cachedPos = 0;
                peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
              }
              advance(peg$cachedPosDetails, peg$cachedPos, pos);
              peg$cachedPos = pos;
            }
            return peg$cachedPosDetails;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildException(message, expected2, pos) {
            function cleanupExpected(expected3) {
              var i = 1;
              expected3.sort(function(a, b) {
                if (a.description < b.description) {
                  return -1;
                } else if (a.description > b.description) {
                  return 1;
                } else {
                  return 0;
                }
              });
              while (i < expected3.length) {
                if (expected3[i - 1] === expected3[i]) {
                  expected3.splice(i, 1);
                } else {
                  i++;
                }
              }
            }
            function buildMessage(expected3, found2) {
              function stringEscape(s) {
                function hex(ch) {
                  return ch.charCodeAt(0).toString(16).toUpperCase();
                }
                return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                  return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                  return "\\x" + hex(ch);
                }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                  return "\\u0" + hex(ch);
                }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                  return "\\u" + hex(ch);
                });
              }
              var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
              for (i = 0; i < expected3.length; i++) {
                expectedDescs[i] = expected3[i].description;
              }
              expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
              foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
              return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }
            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
            if (expected2 !== null) {
              cleanupExpected(expected2);
            }
            return new SyntaxError(
              message !== null ? message : buildMessage(expected2, found),
              expected2,
              found,
              pos,
              posDetails.line,
              posDetails.column
            );
          }
          function peg$parsestart() {
            var s0, s1;
            s0 = [];
            s1 = peg$parsegraphStmt();
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parsegraphStmt();
              }
            } else {
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsegraphStmt() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parsestrict();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c1;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c1;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsegraphType();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseid();
                    if (s5 === peg$FAILED) {
                      s5 = peg$c2;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = [];
                      s7 = peg$parse_();
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parse_();
                      }
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 123) {
                          s7 = peg$c3;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c4);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = [];
                          s9 = peg$parse_();
                          while (s9 !== peg$FAILED) {
                            s8.push(s9);
                            s9 = peg$parse_();
                          }
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parsestmtList();
                            if (s9 === peg$FAILED) {
                              s9 = peg$c2;
                            }
                            if (s9 !== peg$FAILED) {
                              s10 = [];
                              s11 = peg$parse_();
                              while (s11 !== peg$FAILED) {
                                s10.push(s11);
                                s11 = peg$parse_();
                              }
                              if (s10 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                  s11 = peg$c5;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c6);
                                  }
                                }
                                if (s11 !== peg$FAILED) {
                                  s12 = [];
                                  s13 = peg$parse_();
                                  while (s13 !== peg$FAILED) {
                                    s12.push(s13);
                                    s13 = peg$parse_();
                                  }
                                  if (s12 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c7(s2, s3, s5, s9);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c1;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c1;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c1;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsestmtList() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            s0 = peg$currPos;
            s1 = peg$parsestmt();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s3 = peg$c8;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = [];
                  s7 = peg$parse_();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_();
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsestmt();
                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$parse_();
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$parse_();
                      }
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                          s9 = peg$c8;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c9);
                          }
                        }
                        if (s9 === peg$FAILED) {
                          s9 = peg$c2;
                        }
                        if (s9 !== peg$FAILED) {
                          s6 = [s6, s7, s8, s9];
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$c1;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c1;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c1;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c1;
                  }
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = [];
                    s7 = peg$parse_();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parse_();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsestmt();
                      if (s7 !== peg$FAILED) {
                        s8 = [];
                        s9 = peg$parse_();
                        while (s9 !== peg$FAILED) {
                          s8.push(s9);
                          s9 = peg$parse_();
                        }
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 59) {
                            s9 = peg$c8;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c9);
                            }
                          }
                          if (s9 === peg$FAILED) {
                            s9 = peg$c2;
                          }
                          if (s9 !== peg$FAILED) {
                            s6 = [s6, s7, s8, s9];
                            s5 = s6;
                          } else {
                            peg$currPos = s5;
                            s5 = peg$c1;
                          }
                        } else {
                          peg$currPos = s5;
                          s5 = peg$c1;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c1;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c1;
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c10(s1, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsestmt() {
            var s0;
            s0 = peg$parseattrStmt();
            if (s0 === peg$FAILED) {
              s0 = peg$parseedgeStmt();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesubgraphStmt();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseinlineAttrStmt();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenodeStmt();
                  }
                }
              }
            }
            return s0;
          }
          function peg$parseattrStmt() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsegraph();
            if (s1 === peg$FAILED) {
              s1 = peg$parsenode();
              if (s1 === peg$FAILED) {
                s1 = peg$parseedge();
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseattrList();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c11(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseinlineAttrStmt() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parseid();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c12;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseid();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c14(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsenodeStmt() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsenodeId();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseattrList();
                if (s3 === peg$FAILED) {
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseedgeStmt() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsenodeIdOrSubgraph();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseedgeRHS();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseattrList();
                    if (s5 === peg$FAILED) {
                      s5 = peg$c2;
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c16(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsesubgraphStmt() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsesubgraph();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parseid();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_();
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c1;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
                if (s4 === peg$FAILED) {
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c1;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c1;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c1;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 123) {
                s2 = peg$c3;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parse_();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parse_();
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsestmtList();
                  if (s4 === peg$FAILED) {
                    s4 = peg$c2;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parse_();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parse_();
                    }
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s6 = peg$c5;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c6);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c17(s1, s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseattrList() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parseattrListBlock();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseattrListBlock();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseattrListBlock();
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c18(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseattrListBlock() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c19;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c20);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseaList();
                if (s3 === peg$FAILED) {
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s5 = peg$c21;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c22);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c23(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseaList() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            s1 = peg$parseidDef();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c24;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c25);
                  }
                }
                if (s5 === peg$FAILED) {
                  s5 = peg$c2;
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parse_();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parse_();
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseidDef();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c1;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c24;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c25);
                    }
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$c2;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parse_();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parse_();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseidDef();
                      if (s7 !== peg$FAILED) {
                        s4 = [s4, s5, s6, s7];
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c1;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c1;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseedgeRHS() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c27) {
              s2 = peg$c27;
              peg$currPos += 2;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = peg$currPos;
              s3 = peg$c29();
              if (s3) {
                s3 = peg$c1;
              } else {
                s3 = peg$c30;
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$c1;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c1;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c31) {
                s2 = peg$c31;
                peg$currPos += 2;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = peg$currPos;
                s3 = peg$c29();
                if (s3) {
                  s3 = peg$c30;
                } else {
                  s3 = peg$c1;
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c1;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c1;
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsenodeIdOrSubgraph();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseedgeRHS();
                    if (s5 === peg$FAILED) {
                      s5 = peg$c2;
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c33(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseidDef() {
            var s0, s1, s2, s3, s4, s5, s6;
            s0 = peg$currPos;
            s1 = peg$parseid();
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c12;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parse_();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parse_();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseid();
                    if (s6 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c1;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c1;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c1;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c1;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c34(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsenodeIdOrSubgraph() {
            var s0, s1;
            s0 = peg$parsesubgraphStmt();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsenodeId();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c35(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsenodeId() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parseid();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseport();
                if (s3 === peg$FAILED) {
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c36(s1);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parseport() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 58) {
              s1 = peg$c37;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c38);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s6 = peg$c37;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c38);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parse_();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parse_();
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsecompassPt();
                        if (s8 !== peg$FAILED) {
                          s6 = [s6, s7, s8];
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$c1;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c1;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c1;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = peg$c2;
                    }
                    if (s5 !== peg$FAILED) {
                      s1 = [s1, s2, s3, s4, s5];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            return s0;
          }
          function peg$parsecompassPt() {
            var s0;
            if (input.substr(peg$currPos, 2) === peg$c39) {
              s0 = peg$c39;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c40);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c41) {
                s0 = peg$c41;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c42);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c43) {
                  s0 = peg$c43;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c44);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c45) {
                    s0 = peg$c45;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c46);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 110) {
                      s0 = peg$c47;
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c48);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 101) {
                        s0 = peg$c49;
                        peg$currPos++;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c50);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 115) {
                          s0 = peg$c51;
                          peg$currPos++;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c52);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 119) {
                            s0 = peg$c53;
                            peg$currPos++;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c54);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 99) {
                              s0 = peg$c55;
                              peg$currPos++;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c56);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 95) {
                                s0 = peg$c57;
                                peg$currPos++;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c58);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parseid() {
            var s0, s1, s2, s3, s4, s5, s6;
            peg$silentFails++;
            s0 = peg$currPos;
            if (peg$c60.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c61);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$c62.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c63);
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c62.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c64(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c65;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c66);
                }
              }
              if (s1 === peg$FAILED) {
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s2 = peg$c67;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c68);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  if (peg$c69.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      if (peg$c69.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c70);
                        }
                      }
                    }
                  } else {
                    s3 = peg$c1;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c71(s1, s2, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                  s1 = peg$c65;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c66);
                  }
                }
                if (s1 === peg$FAILED) {
                  s1 = peg$c2;
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  if (peg$c69.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      if (peg$c69.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c70);
                        }
                      }
                    }
                  } else {
                    s2 = peg$c1;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s4 = peg$c67;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c68);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      if (peg$c69.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c70);
                        }
                      }
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        if (peg$c69.test(input.charAt(peg$currPos))) {
                          s6 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s6 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c70);
                          }
                        }
                      }
                      if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c1;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c1;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$c2;
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c72(s1, s2, s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s1 = peg$c73;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c74);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c75) {
                      s4 = peg$c75;
                      peg$currPos += 2;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c76);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s3;
                      s4 = peg$c77();
                    }
                    s3 = s4;
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 92) {
                        s4 = peg$c78;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c79);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        if (peg$c80.test(input.charAt(peg$currPos))) {
                          s5 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c81);
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s3;
                          s4 = peg$c82(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$c1;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c1;
                      }
                      if (s3 === peg$FAILED) {
                        if (peg$c80.test(input.charAt(peg$currPos))) {
                          s3 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c81);
                          }
                        }
                      }
                    }
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c75) {
                        s4 = peg$c75;
                        peg$currPos += 2;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c76);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s3;
                        s4 = peg$c77();
                      }
                      s3 = s4;
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 92) {
                          s4 = peg$c78;
                          peg$currPos++;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c79);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          if (peg$c80.test(input.charAt(peg$currPos))) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c81);
                            }
                          }
                          if (s5 !== peg$FAILED) {
                            peg$reportedPos = s3;
                            s4 = peg$c82(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$c1;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$c1;
                        }
                        if (s3 === peg$FAILED) {
                          if (peg$c80.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c81);
                            }
                          }
                        }
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 34) {
                        s3 = peg$c73;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c74);
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c83(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c59);
              }
            }
            return s0;
          }
          function peg$parsenode() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c84) {
              s1 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c85);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseedge() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c87) {
              s1 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c88);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsegraph() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c89) {
              s1 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsedigraph() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c91) {
              s1 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsesubgraph() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c93) {
              s1 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c94);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsestrict() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c95) {
              s1 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c96);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c86(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsegraphType() {
            var s0, s1;
            s0 = peg$parsegraph();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsedigraph();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c97(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1;
            peg$silentFails++;
            s0 = [];
            if (peg$c99.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c100);
              }
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (peg$c99.test(input.charAt(peg$currPos))) {
                  s1 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c100);
                  }
                }
              }
            } else {
              s0 = peg$c1;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c98);
              }
            }
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c102) {
              s1 = peg$c102;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c103);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$c104.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c105);
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c104.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c105);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c107);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 2) === peg$c108) {
                  s5 = peg$c108;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c109);
                  }
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = peg$c30;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  if (input.substr(peg$currPos, 2) === peg$c108) {
                    s5 = peg$c108;
                    peg$currPos += 2;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c109);
                    }
                  }
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = peg$c30;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c1;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c110);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s4 = [s4, s5];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c1;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                }
                if (s2 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c108) {
                    s3 = peg$c108;
                    peg$currPos += 2;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c109);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            return s0;
          }
          function peg$parse_() {
            var s0;
            s0 = peg$parsewhitespace();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
            return s0;
          }
          var _ = require_lodash2();
          var directed;
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail({ type: "end", description: "end of input" });
            }
            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
          }
        }
        return {
          SyntaxError,
          parse: parse2
        };
      }();
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      module.exports = root2;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root2 = require_root();
      var Symbol2 = root2.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      var root2 = require_root();
      var coreJsData = root2["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Map2 = getNative(root2, "Map");
      module.exports = Map2;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module.exports = Stack;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module) {
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      module.exports = arrayEach;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      var isArray = Array.isArray;
      module.exports = isArray;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      var root2 = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports, module) {
      var copyObject = require_copyObject();
      var keys = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module.exports = baseAssign;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports, module) {
      var isObject = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module.exports = keysIn;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports, module) {
      var root2 = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports, module) {
      function copyArray(source, array2) {
        var index = -1, length = source.length;
        array2 || (array2 = Array(length));
        while (++index < length) {
          array2[index] = source[index];
        }
        return array2;
      }
      module.exports = copyArray;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module.exports = copySymbols;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      module.exports = arrayPush;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports, module) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var DataView2 = getNative(root2, "DataView");
      module.exports = DataView2;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Promise2 = getNative(root2, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Set2 = getNative(root2, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var WeakMap = getNative(root2, "WeakMap");
      module.exports = WeakMap;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array2) {
        var length = array2.length, result = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
          result.index = array2.index;
          result.input = array2.input;
        }
        return result;
      }
      module.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root2 = require_root();
      var Uint8Array2 = root2.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports, module) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports, module) {
      var isObject = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module.exports = baseCreate;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports, module) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module.exports = initCloneObject;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports, module) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports, module) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports, module) {
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module.exports = baseClone;
    }
  });

  // node_modules/lodash/clone.js
  var require_clone = __commonJS({
    "node_modules/lodash/clone.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      module.exports = clone;
    }
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/lodash/constant.js"(exports, module) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module.exports = constant;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      module.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module.exports = createBaseEach;
    }
  });

  // node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js"(exports, module) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module.exports = baseEach;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports, module) {
      function identity(value) {
        return value;
      }
      module.exports = identity;
    }
  });

  // node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "node_modules/lodash/_castFunction.js"(exports, module) {
      var identity = require_identity();
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      module.exports = castFunction;
    }
  });

  // node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "node_modules/lodash/forEach.js"(exports, module) {
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray = require_isArray();
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module.exports = forEach;
    }
  });

  // node_modules/lodash/each.js
  var require_each = __commonJS({
    "node_modules/lodash/each.js"(exports, module) {
      module.exports = require_forEach();
    }
  });

  // node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "node_modules/lodash/_baseFilter.js"(exports, module) {
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module.exports = baseFilter;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports, module) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module.exports = isKey;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module.exports = memoize;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports, module) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString = require_toString();
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      module.exports = castPath;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module.exports = baseGet;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      module.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // node_modules/lodash/filter.js
  var require_filter = __commonJS({
    "node_modules/lodash/filter.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function filter2(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
      }
      module.exports = filter2;
    }
  });

  // node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/lodash/_baseHas.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      module.exports = baseHas;
    }
  });

  // node_modules/lodash/has.js
  var require_has = __commonJS({
    "node_modules/lodash/has.js"(exports, module) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      module.exports = has;
    }
  });

  // node_modules/lodash/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/lodash/isEmpty.js"(exports, module) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLike = require_isArrayLike();
      var isBuffer = require_isBuffer();
      var isPrototype = require_isPrototype();
      var isTypedArray = require_isTypedArray();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      module.exports = isEmpty;
    }
  });

  // node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "node_modules/lodash/isUndefined.js"(exports, module) {
      function isUndefined(value) {
        return value === void 0;
      }
      module.exports = isUndefined;
    }
  });

  // node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js"(exports, module) {
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      module.exports = baseMap;
    }
  });

  // node_modules/lodash/map.js
  var require_map = __commonJS({
    "node_modules/lodash/map.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray = require_isArray();
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module.exports = map;
    }
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js"(exports, module) {
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "node_modules/lodash/_baseReduce.js"(exports, module) {
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      module.exports = baseReduce;
    }
  });

  // node_modules/lodash/reduce.js
  var require_reduce = __commonJS({
    "node_modules/lodash/reduce.js"(exports, module) {
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray = require_isArray();
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module.exports = reduce;
    }
  });

  // node_modules/lodash/isString.js
  var require_isString = __commonJS({
    "node_modules/lodash/isString.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isArray = require_isArray();
      var isObjectLike = require_isObjectLike();
      var stringTag = "[object String]";
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      module.exports = isString;
    }
  });

  // node_modules/lodash/_asciiSize.js
  var require_asciiSize = __commonJS({
    "node_modules/lodash/_asciiSize.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var asciiSize = baseProperty("length");
      module.exports = asciiSize;
    }
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module.exports = hasUnicode;
    }
  });

  // node_modules/lodash/_unicodeSize.js
  var require_unicodeSize = __commonJS({
    "node_modules/lodash/_unicodeSize.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      module.exports = unicodeSize;
    }
  });

  // node_modules/lodash/_stringSize.js
  var require_stringSize = __commonJS({
    "node_modules/lodash/_stringSize.js"(exports, module) {
      var asciiSize = require_asciiSize();
      var hasUnicode = require_hasUnicode();
      var unicodeSize = require_unicodeSize();
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      module.exports = stringSize;
    }
  });

  // node_modules/lodash/size.js
  var require_size = __commonJS({
    "node_modules/lodash/size.js"(exports, module) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArrayLike = require_isArrayLike();
      var isString = require_isString();
      var stringSize = require_stringSize();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      module.exports = size;
    }
  });

  // node_modules/lodash/transform.js
  var require_transform = __commonJS({
    "node_modules/lodash/transform.js"(exports, module) {
      var arrayEach = require_arrayEach();
      var baseCreate = require_baseCreate();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      var getPrototype = require_getPrototype();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isFunction = require_isFunction();
      var isObject = require_isObject();
      var isTypedArray = require_isTypedArray();
      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee = baseIteratee(iteratee, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee(accumulator, value, index, object2);
        });
        return accumulator;
      }
      module.exports = transform;
    }
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module.exports = isFlattenable;
    }
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array2, depth, predicate, isStrict, result) {
        var index = -1, length = array2.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array2[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module.exports = baseFlatten;
    }
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/lodash/_apply.js"(exports, module) {
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module.exports = apply;
    }
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js"(exports, module) {
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
          while (++index < length) {
            array2[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array2);
          return apply(func, this, otherArgs);
        };
      }
      module.exports = overRest;
    }
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js"(exports, module) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module.exports = baseSetToString;
    }
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js"(exports, module) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module.exports = shortOut;
    }
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js"(exports, module) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module.exports = setToString;
    }
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js"(exports, module) {
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      module.exports = baseRest;
    }
  });

  // node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "node_modules/lodash/_baseFindIndex.js"(exports, module) {
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      module.exports = baseFindIndex;
    }
  });

  // node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "node_modules/lodash/_baseIsNaN.js"(exports, module) {
      function baseIsNaN(value) {
        return value !== value;
      }
      module.exports = baseIsNaN;
    }
  });

  // node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "node_modules/lodash/_strictIndexOf.js"(exports, module) {
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      module.exports = strictIndexOf;
    }
  });

  // node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "node_modules/lodash/_baseIndexOf.js"(exports, module) {
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      module.exports = baseIndexOf;
    }
  });

  // node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS({
    "node_modules/lodash/_arrayIncludes.js"(exports, module) {
      var baseIndexOf = require_baseIndexOf();
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      module.exports = arrayIncludes;
    }
  });

  // node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS({
    "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      module.exports = arrayIncludesWith;
    }
  });

  // node_modules/lodash/noop.js
  var require_noop = __commonJS({
    "node_modules/lodash/noop.js"(exports, module) {
      function noop() {
      }
      module.exports = noop;
    }
  });

  // node_modules/lodash/_createSet.js
  var require_createSet = __commonJS({
    "node_modules/lodash/_createSet.js"(exports, module) {
      var Set2 = require_Set();
      var noop = require_noop();
      var setToArray = require_setToArray();
      var INFINITY = 1 / 0;
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set2(values);
      };
      module.exports = createSet;
    }
  });

  // node_modules/lodash/_baseUniq.js
  var require_baseUniq = __commonJS({
    "node_modules/lodash/_baseUniq.js"(exports, module) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var cacheHas = require_cacheHas();
      var createSet = require_createSet();
      var setToArray = require_setToArray();
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array2, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array2);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array2[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      module.exports = baseUniq;
    }
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module.exports = isArrayLikeObject;
    }
  });

  // node_modules/lodash/union.js
  var require_union = __commonJS({
    "node_modules/lodash/union.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      var baseRest = require_baseRest();
      var baseUniq = require_baseUniq();
      var isArrayLikeObject = require_isArrayLikeObject();
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      module.exports = union;
    }
  });

  // node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "node_modules/lodash/_baseValues.js"(exports, module) {
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module.exports = baseValues;
    }
  });

  // node_modules/lodash/values.js
  var require_values = __commonJS({
    "node_modules/lodash/values.js"(exports, module) {
      var baseValues = require_baseValues();
      var keys = require_keys();
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      module.exports = values;
    }
  });

  // node_modules/graphlib/lib/lodash.js
  var require_lodash3 = __commonJS({
    "node_modules/graphlib/lib/lodash.js"(exports, module) {
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            clone: require_clone(),
            constant: require_constant(),
            each: require_each(),
            filter: require_filter(),
            has: require_has(),
            isArray: require_isArray(),
            isEmpty: require_isEmpty(),
            isFunction: require_isFunction(),
            isUndefined: require_isUndefined(),
            keys: require_keys(),
            map: require_map(),
            reduce: require_reduce(),
            size: require_size(),
            transform: require_transform(),
            union: require_union(),
            values: require_values()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/graphlib/lib/graph.js
  var require_graph = __commonJS({
    "node_modules/graphlib/lib/graph.js"(exports, module) {
      "use strict";
      var _ = require_lodash3();
      module.exports = Graph;
      var DEFAULT_EDGE_NAME = "\0";
      var GRAPH_NODE = "\0";
      var EDGE_KEY_DELIM = "";
      function Graph(opts) {
        this._isDirected = _.has(opts, "directed") ? opts.directed : true;
        this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
        this._isCompound = _.has(opts, "compound") ? opts.compound : false;
        this._label = void 0;
        this._defaultNodeLabelFn = _.constant(void 0);
        this._defaultEdgeLabelFn = _.constant(void 0);
        this._nodes = {};
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
        this._in = {};
        this._preds = {};
        this._out = {};
        this._sucs = {};
        this._edgeObjs = {};
        this._edgeLabels = {};
      }
      Graph.prototype._nodeCount = 0;
      Graph.prototype._edgeCount = 0;
      Graph.prototype.isDirected = function() {
        return this._isDirected;
      };
      Graph.prototype.isMultigraph = function() {
        return this._isMultigraph;
      };
      Graph.prototype.isCompound = function() {
        return this._isCompound;
      };
      Graph.prototype.setGraph = function(label) {
        this._label = label;
        return this;
      };
      Graph.prototype.graph = function() {
        return this._label;
      };
      Graph.prototype.setDefaultNodeLabel = function(newDefault) {
        if (!_.isFunction(newDefault)) {
          newDefault = _.constant(newDefault);
        }
        this._defaultNodeLabelFn = newDefault;
        return this;
      };
      Graph.prototype.nodeCount = function() {
        return this._nodeCount;
      };
      Graph.prototype.nodes = function() {
        return _.keys(this._nodes);
      };
      Graph.prototype.sources = function() {
        var self2 = this;
        return _.filter(this.nodes(), function(v) {
          return _.isEmpty(self2._in[v]);
        });
      };
      Graph.prototype.sinks = function() {
        var self2 = this;
        return _.filter(this.nodes(), function(v) {
          return _.isEmpty(self2._out[v]);
        });
      };
      Graph.prototype.setNodes = function(vs, value) {
        var args = arguments;
        var self2 = this;
        _.each(vs, function(v) {
          if (args.length > 1) {
            self2.setNode(v, value);
          } else {
            self2.setNode(v);
          }
        });
        return this;
      };
      Graph.prototype.setNode = function(v, value) {
        if (_.has(this._nodes, v)) {
          if (arguments.length > 1) {
            this._nodes[v] = value;
          }
          return this;
        }
        this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
        if (this._isCompound) {
          this._parent[v] = GRAPH_NODE;
          this._children[v] = {};
          this._children[GRAPH_NODE][v] = true;
        }
        this._in[v] = {};
        this._preds[v] = {};
        this._out[v] = {};
        this._sucs[v] = {};
        ++this._nodeCount;
        return this;
      };
      Graph.prototype.node = function(v) {
        return this._nodes[v];
      };
      Graph.prototype.hasNode = function(v) {
        return _.has(this._nodes, v);
      };
      Graph.prototype.removeNode = function(v) {
        var self2 = this;
        if (_.has(this._nodes, v)) {
          var removeEdge = function(e) {
            self2.removeEdge(self2._edgeObjs[e]);
          };
          delete this._nodes[v];
          if (this._isCompound) {
            this._removeFromParentsChildList(v);
            delete this._parent[v];
            _.each(this.children(v), function(child) {
              self2.setParent(child);
            });
            delete this._children[v];
          }
          _.each(_.keys(this._in[v]), removeEdge);
          delete this._in[v];
          delete this._preds[v];
          _.each(_.keys(this._out[v]), removeEdge);
          delete this._out[v];
          delete this._sucs[v];
          --this._nodeCount;
        }
        return this;
      };
      Graph.prototype.setParent = function(v, parent) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (_.isUndefined(parent)) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
            if (ancestor === v) {
              throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v);
        this._removeFromParentsChildList(v);
        this._parent[v] = parent;
        this._children[parent][v] = true;
        return this;
      };
      Graph.prototype._removeFromParentsChildList = function(v) {
        delete this._children[this._parent[v]][v];
      };
      Graph.prototype.parent = function(v) {
        if (this._isCompound) {
          var parent = this._parent[v];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      };
      Graph.prototype.children = function(v) {
        if (_.isUndefined(v)) {
          v = GRAPH_NODE;
        }
        if (this._isCompound) {
          var children2 = this._children[v];
          if (children2) {
            return _.keys(children2);
          }
        } else if (v === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v)) {
          return [];
        }
      };
      Graph.prototype.predecessors = function(v) {
        var predsV = this._preds[v];
        if (predsV) {
          return _.keys(predsV);
        }
      };
      Graph.prototype.successors = function(v) {
        var sucsV = this._sucs[v];
        if (sucsV) {
          return _.keys(sucsV);
        }
      };
      Graph.prototype.neighbors = function(v) {
        var preds = this.predecessors(v);
        if (preds) {
          return _.union(preds, this.successors(v));
        }
      };
      Graph.prototype.isLeaf = function(v) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v);
        } else {
          neighbors = this.neighbors(v);
        }
        return neighbors.length === 0;
      };
      Graph.prototype.filterNodes = function(filter2) {
        var copy = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy.setGraph(this.graph());
        var self2 = this;
        _.each(this._nodes, function(value, v) {
          if (filter2(v)) {
            copy.setNode(v, value);
          }
        });
        _.each(this._edgeObjs, function(e) {
          if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
            copy.setEdge(e, self2.edge(e));
          }
        });
        var parents = {};
        function findParent(v) {
          var parent = self2.parent(v);
          if (parent === void 0 || copy.hasNode(parent)) {
            parents[v] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (this._isCompound) {
          _.each(copy.nodes(), function(v) {
            copy.setParent(v, findParent(v));
          });
        }
        return copy;
      };
      Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
        if (!_.isFunction(newDefault)) {
          newDefault = _.constant(newDefault);
        }
        this._defaultEdgeLabelFn = newDefault;
        return this;
      };
      Graph.prototype.edgeCount = function() {
        return this._edgeCount;
      };
      Graph.prototype.edges = function() {
        return _.values(this._edgeObjs);
      };
      Graph.prototype.setPath = function(vs, value) {
        var self2 = this;
        var args = arguments;
        _.reduce(vs, function(v, w) {
          if (args.length > 1) {
            self2.setEdge(v, w, value);
          } else {
            self2.setEdge(v, w);
          }
          return w;
        });
        return this;
      };
      Graph.prototype.setEdge = function() {
        var v, w, name, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v = "" + v;
        w = "" + w;
        if (!_.isUndefined(name)) {
          name = "" + name;
        }
        var e = edgeArgsToId(this._isDirected, v, w, name);
        if (_.has(this._edgeLabels, e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value;
          }
          return this;
        }
        if (!_.isUndefined(name) && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w);
        this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
        var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
        v = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w], v);
        incrementOrInitEntry(this._sucs[v], w);
        this._in[w][e] = edgeObj;
        this._out[v][e] = edgeObj;
        this._edgeCount++;
        return this;
      };
      Graph.prototype.edge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return this._edgeLabels[e];
      };
      Graph.prototype.hasEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return _.has(this._edgeLabels, e);
      };
      Graph.prototype.removeEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        var edge = this._edgeObjs[e];
        if (edge) {
          v = edge.v;
          w = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w], v);
          decrementOrRemoveEntry(this._sucs[v], w);
          delete this._in[w][e];
          delete this._out[v][e];
          this._edgeCount--;
        }
        return this;
      };
      Graph.prototype.inEdges = function(v, u) {
        var inV = this._in[v];
        if (inV) {
          var edges = _.values(inV);
          if (!u) {
            return edges;
          }
          return _.filter(edges, function(edge) {
            return edge.v === u;
          });
        }
      };
      Graph.prototype.outEdges = function(v, w) {
        var outV = this._out[v];
        if (outV) {
          var edges = _.values(outV);
          if (!w) {
            return edges;
          }
          return _.filter(edges, function(edge) {
            return edge.w === w;
          });
        }
      };
      Graph.prototype.nodeEdges = function(v, w) {
        var inEdges = this.inEdges(v, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v, w));
        }
      };
      function incrementOrInitEntry(map, k) {
        if (map[k]) {
          map[k]++;
        } else {
          map[k] = 1;
        }
      }
      function decrementOrRemoveEntry(map, k) {
        if (!--map[k]) {
          delete map[k];
        }
      }
      function edgeArgsToId(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
      }
      function edgeArgsToObj(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        var edgeObj = { v, w };
        if (name) {
          edgeObj.name = name;
        }
        return edgeObj;
      }
      function edgeObjToId(isDirected, edgeObj) {
        return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
      }
    }
  });

  // node_modules/graphlib/lib/version.js
  var require_version = __commonJS({
    "node_modules/graphlib/lib/version.js"(exports, module) {
      module.exports = "2.1.8";
    }
  });

  // node_modules/graphlib/lib/index.js
  var require_lib = __commonJS({
    "node_modules/graphlib/lib/index.js"(exports, module) {
      module.exports = {
        Graph: require_graph(),
        version: require_version()
      };
    }
  });

  // node_modules/graphlib/lib/json.js
  var require_json = __commonJS({
    "node_modules/graphlib/lib/json.js"(exports, module) {
      var _ = require_lodash3();
      var Graph = require_graph();
      module.exports = {
        write,
        read: read2
      };
      function write(g) {
        var json = {
          options: {
            directed: g.isDirected(),
            multigraph: g.isMultigraph(),
            compound: g.isCompound()
          },
          nodes: writeNodes(g),
          edges: writeEdges(g)
        };
        if (!_.isUndefined(g.graph())) {
          json.value = _.clone(g.graph());
        }
        return json;
      }
      function writeNodes(g) {
        return _.map(g.nodes(), function(v) {
          var nodeValue = g.node(v);
          var parent = g.parent(v);
          var node = { v };
          if (!_.isUndefined(nodeValue)) {
            node.value = nodeValue;
          }
          if (!_.isUndefined(parent)) {
            node.parent = parent;
          }
          return node;
        });
      }
      function writeEdges(g) {
        return _.map(g.edges(), function(e) {
          var edgeValue = g.edge(e);
          var edge = { v: e.v, w: e.w };
          if (!_.isUndefined(e.name)) {
            edge.name = e.name;
          }
          if (!_.isUndefined(edgeValue)) {
            edge.value = edgeValue;
          }
          return edge;
        });
      }
      function read2(json) {
        var g = new Graph(json.options).setGraph(json.value);
        _.each(json.nodes, function(entry) {
          g.setNode(entry.v, entry.value);
          if (entry.parent) {
            g.setParent(entry.v, entry.parent);
          }
        });
        _.each(json.edges, function(entry) {
          g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
        });
        return g;
      }
    }
  });

  // node_modules/graphlib/lib/alg/components.js
  var require_components = __commonJS({
    "node_modules/graphlib/lib/alg/components.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = components;
      function components(g) {
        var visited = {};
        var cmpts = [];
        var cmpt;
        function dfs(v) {
          if (_.has(visited, v))
            return;
          visited[v] = true;
          cmpt.push(v);
          _.each(g.successors(v), dfs);
          _.each(g.predecessors(v), dfs);
        }
        _.each(g.nodes(), function(v) {
          cmpt = [];
          dfs(v);
          if (cmpt.length) {
            cmpts.push(cmpt);
          }
        });
        return cmpts;
      }
    }
  });

  // node_modules/graphlib/lib/data/priority-queue.js
  var require_priority_queue = __commonJS({
    "node_modules/graphlib/lib/data/priority-queue.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = PriorityQueue;
      function PriorityQueue() {
        this._arr = [];
        this._keyIndices = {};
      }
      PriorityQueue.prototype.size = function() {
        return this._arr.length;
      };
      PriorityQueue.prototype.keys = function() {
        return this._arr.map(function(x) {
          return x.key;
        });
      };
      PriorityQueue.prototype.has = function(key) {
        return _.has(this._keyIndices, key);
      };
      PriorityQueue.prototype.priority = function(key) {
        var index = this._keyIndices[key];
        if (index !== void 0) {
          return this._arr[index].priority;
        }
      };
      PriorityQueue.prototype.min = function() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      };
      PriorityQueue.prototype.add = function(key, priority) {
        var keyIndices = this._keyIndices;
        key = String(key);
        if (!_.has(keyIndices, key)) {
          var arr = this._arr;
          var index = arr.length;
          keyIndices[key] = index;
          arr.push({ key, priority });
          this._decrease(index);
          return true;
        }
        return false;
      };
      PriorityQueue.prototype.removeMin = function() {
        this._swap(0, this._arr.length - 1);
        var min = this._arr.pop();
        delete this._keyIndices[min.key];
        this._heapify(0);
        return min.key;
      };
      PriorityQueue.prototype.decrease = function(key, priority) {
        var index = this._keyIndices[key];
        if (priority > this._arr[index].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
        }
        this._arr[index].priority = priority;
        this._decrease(index);
      };
      PriorityQueue.prototype._heapify = function(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      };
      PriorityQueue.prototype._decrease = function(index) {
        var arr = this._arr;
        var priority = arr[index].priority;
        var parent;
        while (index !== 0) {
          parent = index >> 1;
          if (arr[parent].priority < priority) {
            break;
          }
          this._swap(index, parent);
          index = parent;
        }
      };
      PriorityQueue.prototype._swap = function(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      };
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra.js"(exports, module) {
      var _ = require_lodash3();
      var PriorityQueue = require_priority_queue();
      module.exports = dijkstra;
      var DEFAULT_WEIGHT_FUNC = _.constant(1);
      function dijkstra(g, source, weightFn, edgeFn) {
        return runDijkstra(
          g,
          String(source),
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runDijkstra(g, source, weightFn, edgeFn) {
        var results = {};
        var pq = new PriorityQueue();
        var v, vEntry;
        var updateNeighbors = function(edge) {
          var w = edge.v !== v ? edge.v : edge.w;
          var wEntry = results[w];
          var weight = weightFn(edge);
          var distance = vEntry.distance + weight;
          if (weight < 0) {
            throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
          }
          if (distance < wEntry.distance) {
            wEntry.distance = distance;
            wEntry.predecessor = v;
            pq.decrease(w, distance);
          }
        };
        g.nodes().forEach(function(v2) {
          var distance = v2 === source ? 0 : Number.POSITIVE_INFINITY;
          results[v2] = { distance };
          pq.add(v2, distance);
        });
        while (pq.size() > 0) {
          v = pq.removeMin();
          vEntry = results[v];
          if (vEntry.distance === Number.POSITIVE_INFINITY) {
            break;
          }
          edgeFn(v).forEach(updateNeighbors);
        }
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra-all.js
  var require_dijkstra_all = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
      var dijkstra = require_dijkstra();
      var _ = require_lodash3();
      module.exports = dijkstraAll;
      function dijkstraAll(g, weightFunc, edgeFunc) {
        return _.transform(g.nodes(), function(acc, v) {
          acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
        }, {});
      }
    }
  });

  // node_modules/graphlib/lib/alg/tarjan.js
  var require_tarjan = __commonJS({
    "node_modules/graphlib/lib/alg/tarjan.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = tarjan;
      function tarjan(g) {
        var index = 0;
        var stack = [];
        var visited = {};
        var results = [];
        function dfs(v) {
          var entry = visited[v] = {
            onStack: true,
            lowlink: index,
            index: index++
          };
          stack.push(v);
          g.successors(v).forEach(function(w2) {
            if (!_.has(visited, w2)) {
              dfs(w2);
              entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
            } else if (visited[w2].onStack) {
              entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
            }
          });
          if (entry.lowlink === entry.index) {
            var cmpt = [];
            var w;
            do {
              w = stack.pop();
              visited[w].onStack = false;
              cmpt.push(w);
            } while (v !== w);
            results.push(cmpt);
          }
        }
        g.nodes().forEach(function(v) {
          if (!_.has(visited, v)) {
            dfs(v);
          }
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/find-cycles.js
  var require_find_cycles = __commonJS({
    "node_modules/graphlib/lib/alg/find-cycles.js"(exports, module) {
      var _ = require_lodash3();
      var tarjan = require_tarjan();
      module.exports = findCycles;
      function findCycles(g) {
        return _.filter(tarjan(g), function(cmpt) {
          return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
        });
      }
    }
  });

  // node_modules/graphlib/lib/alg/floyd-warshall.js
  var require_floyd_warshall = __commonJS({
    "node_modules/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = floydWarshall;
      var DEFAULT_WEIGHT_FUNC = _.constant(1);
      function floydWarshall(g, weightFn, edgeFn) {
        return runFloydWarshall(
          g,
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runFloydWarshall(g, weightFn, edgeFn) {
        var results = {};
        var nodes = g.nodes();
        nodes.forEach(function(v) {
          results[v] = {};
          results[v][v] = { distance: 0 };
          nodes.forEach(function(w) {
            if (v !== w) {
              results[v][w] = { distance: Number.POSITIVE_INFINITY };
            }
          });
          edgeFn(v).forEach(function(edge) {
            var w = edge.v === v ? edge.w : edge.v;
            var d = weightFn(edge);
            results[v][w] = { distance: d, predecessor: v };
          });
        });
        nodes.forEach(function(k) {
          var rowK = results[k];
          nodes.forEach(function(i) {
            var rowI = results[i];
            nodes.forEach(function(j) {
              var ik = rowI[k];
              var kj = rowK[j];
              var ij = rowI[j];
              var altDistance = ik.distance + kj.distance;
              if (altDistance < ij.distance) {
                ij.distance = altDistance;
                ij.predecessor = kj.predecessor;
              }
            });
          });
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/topsort.js
  var require_topsort = __commonJS({
    "node_modules/graphlib/lib/alg/topsort.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = topsort;
      topsort.CycleException = CycleException;
      function topsort(g) {
        var visited = {};
        var stack = {};
        var results = [];
        function visit(node) {
          if (_.has(stack, node)) {
            throw new CycleException();
          }
          if (!_.has(visited, node)) {
            stack[node] = true;
            visited[node] = true;
            _.each(g.predecessors(node), visit);
            delete stack[node];
            results.push(node);
          }
        }
        _.each(g.sinks(), visit);
        if (_.size(visited) !== g.nodeCount()) {
          throw new CycleException();
        }
        return results;
      }
      function CycleException() {
      }
      CycleException.prototype = new Error();
    }
  });

  // node_modules/graphlib/lib/alg/is-acyclic.js
  var require_is_acyclic = __commonJS({
    "node_modules/graphlib/lib/alg/is-acyclic.js"(exports, module) {
      var topsort = require_topsort();
      module.exports = isAcyclic;
      function isAcyclic(g) {
        try {
          topsort(g);
        } catch (e) {
          if (e instanceof topsort.CycleException) {
            return false;
          }
          throw e;
        }
        return true;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dfs.js
  var require_dfs = __commonJS({
    "node_modules/graphlib/lib/alg/dfs.js"(exports, module) {
      var _ = require_lodash3();
      module.exports = dfs;
      function dfs(g, vs, order) {
        if (!_.isArray(vs)) {
          vs = [vs];
        }
        var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
        var acc = [];
        var visited = {};
        _.each(vs, function(v) {
          if (!g.hasNode(v)) {
            throw new Error("Graph does not have node: " + v);
          }
          doDfs(g, v, order === "post", visited, navigation, acc);
        });
        return acc;
      }
      function doDfs(g, v, postorder, visited, navigation, acc) {
        if (!_.has(visited, v)) {
          visited[v] = true;
          if (!postorder) {
            acc.push(v);
          }
          _.each(navigation(v), function(w) {
            doDfs(g, w, postorder, visited, navigation, acc);
          });
          if (postorder) {
            acc.push(v);
          }
        }
      }
    }
  });

  // node_modules/graphlib/lib/alg/postorder.js
  var require_postorder = __commonJS({
    "node_modules/graphlib/lib/alg/postorder.js"(exports, module) {
      var dfs = require_dfs();
      module.exports = postorder;
      function postorder(g, vs) {
        return dfs(g, vs, "post");
      }
    }
  });

  // node_modules/graphlib/lib/alg/preorder.js
  var require_preorder = __commonJS({
    "node_modules/graphlib/lib/alg/preorder.js"(exports, module) {
      var dfs = require_dfs();
      module.exports = preorder;
      function preorder(g, vs) {
        return dfs(g, vs, "pre");
      }
    }
  });

  // node_modules/graphlib/lib/alg/prim.js
  var require_prim = __commonJS({
    "node_modules/graphlib/lib/alg/prim.js"(exports, module) {
      var _ = require_lodash3();
      var Graph = require_graph();
      var PriorityQueue = require_priority_queue();
      module.exports = prim;
      function prim(g, weightFunc) {
        var result = new Graph();
        var parents = {};
        var pq = new PriorityQueue();
        var v;
        function updateNeighbors(edge) {
          var w = edge.v === v ? edge.w : edge.v;
          var pri = pq.priority(w);
          if (pri !== void 0) {
            var edgeWeight = weightFunc(edge);
            if (edgeWeight < pri) {
              parents[w] = v;
              pq.decrease(w, edgeWeight);
            }
          }
        }
        if (g.nodeCount() === 0) {
          return result;
        }
        _.each(g.nodes(), function(v2) {
          pq.add(v2, Number.POSITIVE_INFINITY);
          result.setNode(v2);
        });
        pq.decrease(g.nodes()[0], 0);
        var init = false;
        while (pq.size() > 0) {
          v = pq.removeMin();
          if (_.has(parents, v)) {
            result.setEdge(v, parents[v]);
          } else if (init) {
            throw new Error("Input graph is not connected: " + g);
          } else {
            init = true;
          }
          g.nodeEdges(v).forEach(updateNeighbors);
        }
        return result;
      }
    }
  });

  // node_modules/graphlib/lib/alg/index.js
  var require_alg = __commonJS({
    "node_modules/graphlib/lib/alg/index.js"(exports, module) {
      module.exports = {
        components: require_components(),
        dijkstra: require_dijkstra(),
        dijkstraAll: require_dijkstra_all(),
        findCycles: require_find_cycles(),
        floydWarshall: require_floyd_warshall(),
        isAcyclic: require_is_acyclic(),
        postorder: require_postorder(),
        preorder: require_preorder(),
        prim: require_prim(),
        tarjan: require_tarjan(),
        topsort: require_topsort()
      };
    }
  });

  // node_modules/graphlib/index.js
  var require_graphlib = __commonJS({
    "node_modules/graphlib/index.js"(exports, module) {
      var lib = require_lib();
      module.exports = {
        Graph: lib.Graph,
        json: require_json(),
        alg: require_alg(),
        version: lib.version
      };
    }
  });

  // node_modules/graphlib-dot/lib/graphlib.js
  var require_graphlib2 = __commonJS({
    "node_modules/graphlib-dot/lib/graphlib.js"(exports, module) {
      var graphlib;
      if (__require) {
        try {
          graphlib = require_graphlib();
        } catch (e) {
        }
      }
      if (!graphlib) {
        graphlib = window.graphlib;
      }
      module.exports = graphlib;
    }
  });

  // node_modules/graphlib-dot/lib/build-graph.js
  var require_build_graph = __commonJS({
    "node_modules/graphlib-dot/lib/build-graph.js"(exports, module) {
      "use strict";
      var _ = require_lodash2();
      var Graph = require_graphlib2().Graph;
      module.exports = buildGraph2;
      function buildGraph2(parseTree) {
        var isDirected = parseTree.type !== "graph", isMultigraph = !parseTree.strict, defaultStack = [{ node: {}, edge: {} }], id = parseTree.id, g = new Graph({ directed: isDirected, multigraph: isMultigraph, compound: true });
        g.setGraph(id === null ? {} : { id });
        _.each(parseTree.stmts, function(stmt) {
          handleStmt(g, stmt, defaultStack);
        });
        return g;
      }
      function handleStmt(g, stmt, defaultStack, sg) {
        switch (stmt.type) {
          case "node":
            handleNodeStmt(g, stmt, defaultStack, sg);
            break;
          case "edge":
            handleEdgeStmt(g, stmt, defaultStack, sg);
            break;
          case "subgraph":
            handleSubgraphStmt(g, stmt, defaultStack, sg);
            break;
          case "attr":
            handleAttrStmt(g, stmt, defaultStack);
            break;
          case "inlineAttr":
            handleInlineAttrsStmt(g, stmt, defaultStack, sg);
            break;
        }
      }
      function handleNodeStmt(g, stmt, defaultStack, sg) {
        var v = stmt.id, attrs = stmt.attrs;
        maybeCreateNode(g, v, defaultStack, sg);
        _.merge(g.node(v), attrs);
      }
      function handleEdgeStmt(g, stmt, defaultStack, sg) {
        var attrs = stmt.attrs, prev, curr;
        _.each(stmt.elems, function(elem) {
          handleStmt(g, elem, defaultStack, sg);
          switch (elem.type) {
            case "node":
              curr = [elem.id];
              break;
            case "subgraph":
              curr = collectNodeIds(elem);
              break;
          }
          _.each(prev, function(v) {
            _.each(curr, function(w) {
              var name;
              if (g.hasEdge(v, w) && g.isMultigraph()) {
                name = _.uniqueId("edge");
              }
              if (!g.hasEdge(v, w, name)) {
                g.setEdge(v, w, _.clone(_.last(defaultStack).edge), name);
              }
              _.merge(g.edge(v, w, name), attrs);
            });
          });
          prev = curr;
        });
      }
      function handleSubgraphStmt(g, stmt, defaultStack, sg) {
        var id = stmt.id;
        if (id === void 0) {
          id = generateSubgraphId(g);
        }
        defaultStack.push(_.clone(_.last(defaultStack)));
        maybeCreateNode(g, id, defaultStack, sg);
        _.each(stmt.stmts, function(s) {
          handleStmt(g, s, defaultStack, id);
        });
        if (!g.children(id).length) {
          g.removeNode(id);
        }
        defaultStack.pop();
      }
      function handleAttrStmt(g, stmt, defaultStack) {
        _.merge(_.last(defaultStack)[stmt.attrType], stmt.attrs);
      }
      function handleInlineAttrsStmt(g, stmt, defaultStack, sg) {
        _.merge(sg ? g.node(sg) : g.graph(), stmt.attrs);
      }
      function generateSubgraphId(g) {
        var id;
        do {
          id = _.uniqueId("sg");
        } while (g.hasNode(id));
        return id;
      }
      function maybeCreateNode(g, v, defaultStack, sg) {
        if (!g.hasNode(v)) {
          g.setNode(v, _.clone(_.last(defaultStack).node));
          g.setParent(v, sg);
        }
      }
      function collectNodeIds(stmt) {
        var ids = {}, stack = [], curr;
        var push = stack.push.bind(stack);
        push(stmt);
        while (stack.length) {
          curr = stack.pop();
          switch (curr.type) {
            case "node":
              ids[curr.id] = true;
              break;
            case "edge":
              _.each(curr.elems, push);
              break;
            case "subgraph":
              _.each(curr.stmts, push);
              break;
          }
        }
        return _.keys(ids);
      }
    }
  });

  // node_modules/graphlib-dot/lib/read-one.js
  var require_read_one = __commonJS({
    "node_modules/graphlib-dot/lib/read-one.js"(exports, module) {
      var grammar = require_dot_grammar();
      var buildGraph2 = require_build_graph();
      module.exports = function readOne(str) {
        var parseTree = grammar.parse(str, { startRule: "graphStmt" });
        return buildGraph2(parseTree);
      };
    }
  });

  // node_modules/graphlib-dot/lib/read-many.js
  var require_read_many = __commonJS({
    "node_modules/graphlib-dot/lib/read-many.js"(exports, module) {
      var _ = require_lodash2();
      var grammar = require_dot_grammar();
      var buildGraph2 = require_build_graph();
      module.exports = function readMany(str) {
        var parseTree = grammar.parse(str);
        return _.map(parseTree, buildGraph2);
      };
    }
  });

  // node_modules/graphlib-dot/lib/write-one.js
  var require_write_one = __commonJS({
    "node_modules/graphlib-dot/lib/write-one.js"(exports, module) {
      var _ = require_lodash2();
      module.exports = writeOne;
      var UNESCAPED_ID_PATTERN = /^[a-zA-Z\200-\377_][a-zA-Z\200-\377_0-9]*$/;
      function writeOne(g) {
        var ec = g.isDirected() ? "->" : "--";
        var writer = new Writer();
        if (!g.isMultigraph()) {
          writer.write("strict ");
        }
        writer.writeLine((g.isDirected() ? "digraph" : "graph") + " {");
        writer.indent();
        var graphAttrs = g.graph();
        if (_.isObject(graphAttrs)) {
          _.each(graphAttrs, function(v, k) {
            writer.writeLine(id(k) + "=" + id(v) + ";");
          });
        }
        writeSubgraph(g, void 0, writer);
        g.edges().forEach(function(edge) {
          writeEdge(g, edge, ec, writer);
        });
        writer.unindent();
        writer.writeLine("}");
        return writer.toString();
      }
      function writeSubgraph(g, v, writer) {
        var children2 = g.isCompound() ? g.children(v) : g.nodes();
        _.each(children2, function(w) {
          if (!g.isCompound() || !g.children(w).length) {
            writeNode(g, w, writer);
          } else {
            writer.writeLine("subgraph " + id(w) + " {");
            writer.indent();
            if (_.isObject(g.node(w))) {
              _.map(g.node(w), function(val, key) {
                writer.writeLine(id(key) + "=" + id(val) + ";");
              });
            }
            writeSubgraph(g, w, writer);
            writer.unindent();
            writer.writeLine("}");
          }
        });
      }
      function writeNode(g, v, writer) {
        writer.write(id(v));
        writeAttrs(g.node(v), writer);
        writer.writeLine();
      }
      function writeEdge(g, edge, ec, writer) {
        var v = edge.v;
        var w = edge.w;
        var attrs = g.edge(edge);
        writer.write(id(v) + " " + ec + " " + id(w));
        writeAttrs(attrs, writer);
        writer.writeLine();
      }
      function writeAttrs(attrs, writer) {
        if (_.isObject(attrs)) {
          var attrStrs = _.map(attrs, function(val, key) {
            return id(key) + "=" + id(val);
          });
          if (attrStrs.length) {
            writer.write(" [" + attrStrs.join(",") + "]");
          }
        }
      }
      function id(obj) {
        if (typeof obj === "number" || obj.toString().match(UNESCAPED_ID_PATTERN)) {
          return obj;
        }
        return '"' + obj.toString().replace(/"/g, '\\"') + '"';
      }
      function Writer() {
        this._indent = "";
        this._content = "";
        this._shouldIndent = true;
      }
      Writer.prototype.INDENT = "  ";
      Writer.prototype.indent = function() {
        this._indent += this.INDENT;
      };
      Writer.prototype.unindent = function() {
        this._indent = this._indent.slice(this.INDENT.length);
      };
      Writer.prototype.writeLine = function(line) {
        this.write((line || "") + "\n");
        this._shouldIndent = true;
      };
      Writer.prototype.write = function(str) {
        if (this._shouldIndent) {
          this._shouldIndent = false;
          this._content += this._indent;
        }
        this._content += str;
      };
      Writer.prototype.toString = function() {
        return this._content;
      };
    }
  });

  // node_modules/graphlib-dot/lib/version.js
  var require_version2 = __commonJS({
    "node_modules/graphlib-dot/lib/version.js"(exports, module) {
      module.exports = "0.6.4";
    }
  });

  // node_modules/graphlib-dot/index.js
  var require_graphlib_dot = __commonJS({
    "node_modules/graphlib-dot/index.js"(exports, module) {
      var read2 = require_read_one();
      var readMany = require_read_many();
      var write = require_write_one();
      var version = require_version2();
      module.exports = {
        graphlib: require_graphlib2(),
        read: read2,
        readMany,
        write,
        version,
        type: "dot",
        buffer: false
      };
    }
  });

  // node_modules/dagre-d3/lib/graphlib.js
  var require_graphlib3 = __commonJS({
    "node_modules/dagre-d3/lib/graphlib.js"(exports, module) {
      var graphlib;
      if (typeof __require === "function") {
        try {
          graphlib = require_graphlib();
        } catch (e) {
        }
      }
      if (!graphlib) {
        graphlib = window.graphlib;
      }
      module.exports = graphlib;
    }
  });

  // node_modules/dagre/lib/graphlib.js
  var require_graphlib4 = __commonJS({
    "node_modules/dagre/lib/graphlib.js"(exports, module) {
      var graphlib;
      if (typeof __require === "function") {
        try {
          graphlib = require_graphlib();
        } catch (e) {
        }
      }
      if (!graphlib) {
        graphlib = window.graphlib;
      }
      module.exports = graphlib;
    }
  });

  // node_modules/lodash/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "node_modules/lodash/cloneDeep.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      module.exports = cloneDeep;
    }
  });

  // node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "node_modules/lodash/_isIterateeCall.js"(exports, module) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject = require_isObject();
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      module.exports = isIterateeCall;
    }
  });

  // node_modules/lodash/defaults.js
  var require_defaults = __commonJS({
    "node_modules/lodash/defaults.js"(exports, module) {
      var baseRest = require_baseRest();
      var eq = require_eq();
      var isIterateeCall = require_isIterateeCall();
      var keysIn = require_keysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var defaults = baseRest(function(object, sources) {
        object = Object(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      module.exports = defaults;
    }
  });

  // node_modules/lodash/_createFind.js
  var require_createFind = __commonJS({
    "node_modules/lodash/_createFind.js"(exports, module) {
      var baseIteratee = require_baseIteratee();
      var isArrayLike = require_isArrayLike();
      var keys = require_keys();
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
        };
      }
      module.exports = createFind;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports, module) {
      var baseTrim = require_baseTrim();
      var isObject = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber;
    }
  });

  // node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js"(exports, module) {
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module.exports = toFinite;
    }
  });

  // node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js"(exports, module) {
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module.exports = toInteger;
    }
  });

  // node_modules/lodash/findIndex.js
  var require_findIndex = __commonJS({
    "node_modules/lodash/findIndex.js"(exports, module) {
      var baseFindIndex = require_baseFindIndex();
      var baseIteratee = require_baseIteratee();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function findIndex(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array2, baseIteratee(predicate, 3), index);
      }
      module.exports = findIndex;
    }
  });

  // node_modules/lodash/find.js
  var require_find = __commonJS({
    "node_modules/lodash/find.js"(exports, module) {
      var createFind = require_createFind();
      var findIndex = require_findIndex();
      var find2 = createFind(findIndex);
      module.exports = find2;
    }
  });

  // node_modules/lodash/flatten.js
  var require_flatten = __commonJS({
    "node_modules/lodash/flatten.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      module.exports = flatten;
    }
  });

  // node_modules/lodash/forIn.js
  var require_forIn = __commonJS({
    "node_modules/lodash/forIn.js"(exports, module) {
      var baseFor = require_baseFor();
      var castFunction = require_castFunction();
      var keysIn = require_keysIn();
      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
      }
      module.exports = forIn;
    }
  });

  // node_modules/lodash/last.js
  var require_last = __commonJS({
    "node_modules/lodash/last.js"(exports, module) {
      function last(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? array2[length - 1] : void 0;
      }
      module.exports = last;
    }
  });

  // node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result, key, iteratee(value, key, object2));
        });
        return result;
      }
      module.exports = mapValues;
    }
  });

  // node_modules/lodash/_baseExtremum.js
  var require_baseExtremum = __commonJS({
    "node_modules/lodash/_baseExtremum.js"(exports, module) {
      var isSymbol = require_isSymbol();
      function baseExtremum(array2, iteratee, comparator) {
        var index = -1, length = array2.length;
        while (++index < length) {
          var value = array2[index], current = iteratee(value);
          if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result = value;
          }
        }
        return result;
      }
      module.exports = baseExtremum;
    }
  });

  // node_modules/lodash/_baseGt.js
  var require_baseGt = __commonJS({
    "node_modules/lodash/_baseGt.js"(exports, module) {
      function baseGt(value, other) {
        return value > other;
      }
      module.exports = baseGt;
    }
  });

  // node_modules/lodash/max.js
  var require_max = __commonJS({
    "node_modules/lodash/max.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseGt = require_baseGt();
      var identity = require_identity();
      function max(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : void 0;
      }
      module.exports = max;
    }
  });

  // node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS({
    "node_modules/lodash/_assignMergeValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignMergeValue;
    }
  });

  // node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS({
    "node_modules/lodash/isPlainObject.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var getPrototype = require_getPrototype();
      var isObjectLike = require_isObjectLike();
      var objectTag = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module.exports = isPlainObject;
    }
  });

  // node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS({
    "node_modules/lodash/_safeGet.js"(exports, module) {
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      module.exports = safeGet;
    }
  });

  // node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS({
    "node_modules/lodash/toPlainObject.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      module.exports = toPlainObject;
    }
  });

  // node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS({
    "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
      var assignMergeValue = require_assignMergeValue();
      var cloneBuffer = require_cloneBuffer();
      var cloneTypedArray = require_cloneTypedArray();
      var copyArray = require_copyArray();
      var initCloneObject = require_initCloneObject();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLikeObject = require_isArrayLikeObject();
      var isBuffer = require_isBuffer();
      var isFunction = require_isFunction();
      var isObject = require_isObject();
      var isPlainObject = require_isPlainObject();
      var isTypedArray = require_isTypedArray();
      var safeGet = require_safeGet();
      var toPlainObject = require_toPlainObject();
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      module.exports = baseMergeDeep;
    }
  });

  // node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS({
    "node_modules/lodash/_baseMerge.js"(exports, module) {
      var Stack = require_Stack();
      var assignMergeValue = require_assignMergeValue();
      var baseFor = require_baseFor();
      var baseMergeDeep = require_baseMergeDeep();
      var isObject = require_isObject();
      var keysIn = require_keysIn();
      var safeGet = require_safeGet();
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      module.exports = baseMerge;
    }
  });

  // node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "node_modules/lodash/_createAssigner.js"(exports, module) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      module.exports = createAssigner;
    }
  });

  // node_modules/lodash/merge.js
  var require_merge = __commonJS({
    "node_modules/lodash/merge.js"(exports, module) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module.exports = merge;
    }
  });

  // node_modules/lodash/_baseLt.js
  var require_baseLt = __commonJS({
    "node_modules/lodash/_baseLt.js"(exports, module) {
      function baseLt(value, other) {
        return value < other;
      }
      module.exports = baseLt;
    }
  });

  // node_modules/lodash/min.js
  var require_min = __commonJS({
    "node_modules/lodash/min.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseLt = require_baseLt();
      var identity = require_identity();
      function min(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : void 0;
      }
      module.exports = min;
    }
  });

  // node_modules/lodash/minBy.js
  var require_minBy = __commonJS({
    "node_modules/lodash/minBy.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseIteratee = require_baseIteratee();
      var baseLt = require_baseLt();
      function minBy(array2, iteratee) {
        return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee, 2), baseLt) : void 0;
      }
      module.exports = minBy;
    }
  });

  // node_modules/lodash/now.js
  var require_now = __commonJS({
    "node_modules/lodash/now.js"(exports, module) {
      var root2 = require_root();
      var now = function() {
        return root2.Date.now();
      };
      module.exports = now;
    }
  });

  // node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "node_modules/lodash/_baseSet.js"(exports, module) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module.exports = baseSet;
    }
  });

  // node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "node_modules/lodash/_basePickBy.js"(exports, module) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      module.exports = basePickBy;
    }
  });

  // node_modules/lodash/_basePick.js
  var require_basePick = __commonJS({
    "node_modules/lodash/_basePick.js"(exports, module) {
      var basePickBy = require_basePickBy();
      var hasIn = require_hasIn();
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      module.exports = basePick;
    }
  });

  // node_modules/lodash/_flatRest.js
  var require_flatRest = __commonJS({
    "node_modules/lodash/_flatRest.js"(exports, module) {
      var flatten = require_flatten();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      module.exports = flatRest;
    }
  });

  // node_modules/lodash/pick.js
  var require_pick = __commonJS({
    "node_modules/lodash/pick.js"(exports, module) {
      var basePick = require_basePick();
      var flatRest = require_flatRest();
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      module.exports = pick;
    }
  });

  // node_modules/lodash/_baseRange.js
  var require_baseRange = __commonJS({
    "node_modules/lodash/_baseRange.js"(exports, module) {
      var nativeCeil = Math.ceil;
      var nativeMax = Math.max;
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index] = start;
          start += step;
        }
        return result;
      }
      module.exports = baseRange;
    }
  });

  // node_modules/lodash/_createRange.js
  var require_createRange = __commonJS({
    "node_modules/lodash/_createRange.js"(exports, module) {
      var baseRange = require_baseRange();
      var isIterateeCall = require_isIterateeCall();
      var toFinite = require_toFinite();
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = void 0;
          }
          start = toFinite(start);
          if (end === void 0) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      module.exports = createRange;
    }
  });

  // node_modules/lodash/range.js
  var require_range = __commonJS({
    "node_modules/lodash/range.js"(exports, module) {
      var createRange = require_createRange();
      var range = createRange();
      module.exports = range;
    }
  });

  // node_modules/lodash/_baseSortBy.js
  var require_baseSortBy = __commonJS({
    "node_modules/lodash/_baseSortBy.js"(exports, module) {
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      module.exports = baseSortBy;
    }
  });

  // node_modules/lodash/_compareAscending.js
  var require_compareAscending = __commonJS({
    "node_modules/lodash/_compareAscending.js"(exports, module) {
      var isSymbol = require_isSymbol();
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      module.exports = compareAscending;
    }
  });

  // node_modules/lodash/_compareMultiple.js
  var require_compareMultiple = __commonJS({
    "node_modules/lodash/_compareMultiple.js"(exports, module) {
      var compareAscending = require_compareAscending();
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      module.exports = compareMultiple;
    }
  });

  // node_modules/lodash/_baseOrderBy.js
  var require_baseOrderBy = __commonJS({
    "node_modules/lodash/_baseOrderBy.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseGet = require_baseGet();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var baseSortBy = require_baseSortBy();
      var baseUnary = require_baseUnary();
      var compareMultiple = require_compareMultiple();
      var identity = require_identity();
      var isArray = require_isArray();
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee) {
            if (isArray(iteratee)) {
              return function(value) {
                return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
              };
            }
            return iteratee;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        var result = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      module.exports = baseOrderBy;
    }
  });

  // node_modules/lodash/sortBy.js
  var require_sortBy = __commonJS({
    "node_modules/lodash/sortBy.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      var baseOrderBy = require_baseOrderBy();
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      module.exports = sortBy;
    }
  });

  // node_modules/lodash/uniqueId.js
  var require_uniqueId = __commonJS({
    "node_modules/lodash/uniqueId.js"(exports, module) {
      var toString = require_toString();
      var idCounter = 0;
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      module.exports = uniqueId;
    }
  });

  // node_modules/lodash/_baseZipObject.js
  var require_baseZipObject = __commonJS({
    "node_modules/lodash/_baseZipObject.js"(exports, module) {
      function baseZipObject(props, values, assignFunc) {
        var index = -1, length = props.length, valsLength = values.length, result = {};
        while (++index < length) {
          var value = index < valsLength ? values[index] : void 0;
          assignFunc(result, props[index], value);
        }
        return result;
      }
      module.exports = baseZipObject;
    }
  });

  // node_modules/lodash/zipObject.js
  var require_zipObject = __commonJS({
    "node_modules/lodash/zipObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseZipObject = require_baseZipObject();
      function zipObject(props, values) {
        return baseZipObject(props || [], values || [], assignValue);
      }
      module.exports = zipObject;
    }
  });

  // node_modules/dagre/lib/lodash.js
  var require_lodash4 = __commonJS({
    "node_modules/dagre/lib/lodash.js"(exports, module) {
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            cloneDeep: require_cloneDeep(),
            constant: require_constant(),
            defaults: require_defaults(),
            each: require_each(),
            filter: require_filter(),
            find: require_find(),
            flatten: require_flatten(),
            forEach: require_forEach(),
            forIn: require_forIn(),
            has: require_has(),
            isUndefined: require_isUndefined(),
            last: require_last(),
            map: require_map(),
            mapValues: require_mapValues(),
            max: require_max(),
            merge: require_merge(),
            min: require_min(),
            minBy: require_minBy(),
            now: require_now(),
            pick: require_pick(),
            range: require_range(),
            reduce: require_reduce(),
            sortBy: require_sortBy(),
            uniqueId: require_uniqueId(),
            values: require_values(),
            zipObject: require_zipObject()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/dagre/lib/data/list.js
  var require_list = __commonJS({
    "node_modules/dagre/lib/data/list.js"(exports, module) {
      module.exports = List;
      function List() {
        var sentinel = {};
        sentinel._next = sentinel._prev = sentinel;
        this._sentinel = sentinel;
      }
      List.prototype.dequeue = function() {
        var sentinel = this._sentinel;
        var entry = sentinel._prev;
        if (entry !== sentinel) {
          unlink(entry);
          return entry;
        }
      };
      List.prototype.enqueue = function(entry) {
        var sentinel = this._sentinel;
        if (entry._prev && entry._next) {
          unlink(entry);
        }
        entry._next = sentinel._next;
        sentinel._next._prev = entry;
        sentinel._next = entry;
        entry._prev = sentinel;
      };
      List.prototype.toString = function() {
        var strs = [];
        var sentinel = this._sentinel;
        var curr = sentinel._prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks));
          curr = curr._prev;
        }
        return "[" + strs.join(", ") + "]";
      };
      function unlink(entry) {
        entry._prev._next = entry._next;
        entry._next._prev = entry._prev;
        delete entry._next;
        delete entry._prev;
      }
      function filterOutLinks(k, v) {
        if (k !== "_next" && k !== "_prev") {
          return v;
        }
      }
    }
  });

  // node_modules/dagre/lib/greedy-fas.js
  var require_greedy_fas = __commonJS({
    "node_modules/dagre/lib/greedy-fas.js"(exports, module) {
      var _ = require_lodash4();
      var Graph = require_graphlib4().Graph;
      var List = require_list();
      module.exports = greedyFAS;
      var DEFAULT_WEIGHT_FN = _.constant(1);
      function greedyFAS(g, weightFn) {
        if (g.nodeCount() <= 1) {
          return [];
        }
        var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
        var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
        return _.flatten(_.map(results, function(e) {
          return g.outEdges(e.v, e.w);
        }), true);
      }
      function doGreedyFAS(g, buckets, zeroIdx) {
        var results = [];
        var sources = buckets[buckets.length - 1];
        var sinks = buckets[0];
        var entry;
        while (g.nodeCount()) {
          while (entry = sinks.dequeue()) {
            removeNode(g, buckets, zeroIdx, entry);
          }
          while (entry = sources.dequeue()) {
            removeNode(g, buckets, zeroIdx, entry);
          }
          if (g.nodeCount()) {
            for (var i = buckets.length - 2; i > 0; --i) {
              entry = buckets[i].dequeue();
              if (entry) {
                results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
                break;
              }
            }
          }
        }
        return results;
      }
      function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
        var results = collectPredecessors ? [] : void 0;
        _.forEach(g.inEdges(entry.v), function(edge) {
          var weight = g.edge(edge);
          var uEntry = g.node(edge.v);
          if (collectPredecessors) {
            results.push({ v: edge.v, w: edge.w });
          }
          uEntry.out -= weight;
          assignBucket(buckets, zeroIdx, uEntry);
        });
        _.forEach(g.outEdges(entry.v), function(edge) {
          var weight = g.edge(edge);
          var w = edge.w;
          var wEntry = g.node(w);
          wEntry["in"] -= weight;
          assignBucket(buckets, zeroIdx, wEntry);
        });
        g.removeNode(entry.v);
        return results;
      }
      function buildState(g, weightFn) {
        var fasGraph = new Graph();
        var maxIn = 0;
        var maxOut = 0;
        _.forEach(g.nodes(), function(v) {
          fasGraph.setNode(v, { v, "in": 0, out: 0 });
        });
        _.forEach(g.edges(), function(e) {
          var prevWeight = fasGraph.edge(e.v, e.w) || 0;
          var weight = weightFn(e);
          var edgeWeight = prevWeight + weight;
          fasGraph.setEdge(e.v, e.w, edgeWeight);
          maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
          maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
        });
        var buckets = _.range(maxOut + maxIn + 3).map(function() {
          return new List();
        });
        var zeroIdx = maxIn + 1;
        _.forEach(fasGraph.nodes(), function(v) {
          assignBucket(buckets, zeroIdx, fasGraph.node(v));
        });
        return { graph: fasGraph, buckets, zeroIdx };
      }
      function assignBucket(buckets, zeroIdx, entry) {
        if (!entry.out) {
          buckets[0].enqueue(entry);
        } else if (!entry["in"]) {
          buckets[buckets.length - 1].enqueue(entry);
        } else {
          buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
        }
      }
    }
  });

  // node_modules/dagre/lib/acyclic.js
  var require_acyclic = __commonJS({
    "node_modules/dagre/lib/acyclic.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var greedyFAS = require_greedy_fas();
      module.exports = {
        run,
        undo
      };
      function run(g) {
        var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
        _.forEach(fas, function(e) {
          var label = g.edge(e);
          g.removeEdge(e);
          label.forwardName = e.name;
          label.reversed = true;
          g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
        });
        function weightFn(g2) {
          return function(e) {
            return g2.edge(e).weight;
          };
        }
      }
      function dfsFAS(g) {
        var fas = [];
        var stack = {};
        var visited = {};
        function dfs(v) {
          if (_.has(visited, v)) {
            return;
          }
          visited[v] = true;
          stack[v] = true;
          _.forEach(g.outEdges(v), function(e) {
            if (_.has(stack, e.w)) {
              fas.push(e);
            } else {
              dfs(e.w);
            }
          });
          delete stack[v];
        }
        _.forEach(g.nodes(), dfs);
        return fas;
      }
      function undo(g) {
        _.forEach(g.edges(), function(e) {
          var label = g.edge(e);
          if (label.reversed) {
            g.removeEdge(e);
            var forwardName = label.forwardName;
            delete label.reversed;
            delete label.forwardName;
            g.setEdge(e.w, e.v, label, forwardName);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/util.js
  var require_util = __commonJS({
    "node_modules/dagre/lib/util.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var Graph = require_graphlib4().Graph;
      module.exports = {
        addDummyNode,
        simplify,
        asNonCompoundGraph,
        successorWeights,
        predecessorWeights,
        intersectRect,
        buildLayerMatrix,
        normalizeRanks,
        removeEmptyRanks,
        addBorderNode,
        maxRank,
        partition,
        time,
        notime
      };
      function addDummyNode(g, type, attrs, name) {
        var v;
        do {
          v = _.uniqueId(name);
        } while (g.hasNode(v));
        attrs.dummy = type;
        g.setNode(v, attrs);
        return v;
      }
      function simplify(g) {
        var simplified = new Graph().setGraph(g.graph());
        _.forEach(g.nodes(), function(v) {
          simplified.setNode(v, g.node(v));
        });
        _.forEach(g.edges(), function(e) {
          var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
          var label = g.edge(e);
          simplified.setEdge(e.v, e.w, {
            weight: simpleLabel.weight + label.weight,
            minlen: Math.max(simpleLabel.minlen, label.minlen)
          });
        });
        return simplified;
      }
      function asNonCompoundGraph(g) {
        var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
        _.forEach(g.nodes(), function(v) {
          if (!g.children(v).length) {
            simplified.setNode(v, g.node(v));
          }
        });
        _.forEach(g.edges(), function(e) {
          simplified.setEdge(e, g.edge(e));
        });
        return simplified;
      }
      function successorWeights(g) {
        var weightMap = _.map(g.nodes(), function(v) {
          var sucs = {};
          _.forEach(g.outEdges(v), function(e) {
            sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
          });
          return sucs;
        });
        return _.zipObject(g.nodes(), weightMap);
      }
      function predecessorWeights(g) {
        var weightMap = _.map(g.nodes(), function(v) {
          var preds = {};
          _.forEach(g.inEdges(v), function(e) {
            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
          });
          return preds;
        });
        return _.zipObject(g.nodes(), weightMap);
      }
      function intersectRect(rect, point) {
        var x = rect.x;
        var y = rect.y;
        var dx = point.x - x;
        var dy = point.y - y;
        var w = rect.width / 2;
        var h = rect.height / 2;
        if (!dx && !dy) {
          throw new Error("Not possible to find intersection inside of the rectangle");
        }
        var sx, sy;
        if (Math.abs(dy) * w > Math.abs(dx) * h) {
          if (dy < 0) {
            h = -h;
          }
          sx = h * dx / dy;
          sy = h;
        } else {
          if (dx < 0) {
            w = -w;
          }
          sx = w;
          sy = w * dy / dx;
        }
        return { x: x + sx, y: y + sy };
      }
      function buildLayerMatrix(g) {
        var layering = _.map(_.range(maxRank(g) + 1), function() {
          return [];
        });
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          var rank = node.rank;
          if (!_.isUndefined(rank)) {
            layering[rank][node.order] = v;
          }
        });
        return layering;
      }
      function normalizeRanks(g) {
        var min = _.min(_.map(g.nodes(), function(v) {
          return g.node(v).rank;
        }));
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (_.has(node, "rank")) {
            node.rank -= min;
          }
        });
      }
      function removeEmptyRanks(g) {
        var offset = _.min(_.map(g.nodes(), function(v) {
          return g.node(v).rank;
        }));
        var layers = [];
        _.forEach(g.nodes(), function(v) {
          var rank = g.node(v).rank - offset;
          if (!layers[rank]) {
            layers[rank] = [];
          }
          layers[rank].push(v);
        });
        var delta = 0;
        var nodeRankFactor = g.graph().nodeRankFactor;
        _.forEach(layers, function(vs, i) {
          if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
            --delta;
          } else if (delta) {
            _.forEach(vs, function(v) {
              g.node(v).rank += delta;
            });
          }
        });
      }
      function addBorderNode(g, prefix, rank, order) {
        var node = {
          width: 0,
          height: 0
        };
        if (arguments.length >= 4) {
          node.rank = rank;
          node.order = order;
        }
        return addDummyNode(g, "border", node, prefix);
      }
      function maxRank(g) {
        return _.max(_.map(g.nodes(), function(v) {
          var rank = g.node(v).rank;
          if (!_.isUndefined(rank)) {
            return rank;
          }
        }));
      }
      function partition(collection, fn) {
        var result = { lhs: [], rhs: [] };
        _.forEach(collection, function(value) {
          if (fn(value)) {
            result.lhs.push(value);
          } else {
            result.rhs.push(value);
          }
        });
        return result;
      }
      function time(name, fn) {
        var start = _.now();
        try {
          return fn();
        } finally {
          console.log(name + " time: " + (_.now() - start) + "ms");
        }
      }
      function notime(name, fn) {
        return fn();
      }
    }
  });

  // node_modules/dagre/lib/normalize.js
  var require_normalize = __commonJS({
    "node_modules/dagre/lib/normalize.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var util = require_util();
      module.exports = {
        run,
        undo
      };
      function run(g) {
        g.graph().dummyChains = [];
        _.forEach(g.edges(), function(edge) {
          normalizeEdge(g, edge);
        });
      }
      function normalizeEdge(g, e) {
        var v = e.v;
        var vRank = g.node(v).rank;
        var w = e.w;
        var wRank = g.node(w).rank;
        var name = e.name;
        var edgeLabel = g.edge(e);
        var labelRank = edgeLabel.labelRank;
        if (wRank === vRank + 1)
          return;
        g.removeEdge(e);
        var dummy, attrs, i;
        for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
          edgeLabel.points = [];
          attrs = {
            width: 0,
            height: 0,
            edgeLabel,
            edgeObj: e,
            rank: vRank
          };
          dummy = util.addDummyNode(g, "edge", attrs, "_d");
          if (vRank === labelRank) {
            attrs.width = edgeLabel.width;
            attrs.height = edgeLabel.height;
            attrs.dummy = "edge-label";
            attrs.labelpos = edgeLabel.labelpos;
          }
          g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
          if (i === 0) {
            g.graph().dummyChains.push(dummy);
          }
          v = dummy;
        }
        g.setEdge(v, w, { weight: edgeLabel.weight }, name);
      }
      function undo(g) {
        _.forEach(g.graph().dummyChains, function(v) {
          var node = g.node(v);
          var origLabel = node.edgeLabel;
          var w;
          g.setEdge(node.edgeObj, origLabel);
          while (node.dummy) {
            w = g.successors(v)[0];
            g.removeNode(v);
            origLabel.points.push({ x: node.x, y: node.y });
            if (node.dummy === "edge-label") {
              origLabel.x = node.x;
              origLabel.y = node.y;
              origLabel.width = node.width;
              origLabel.height = node.height;
            }
            v = w;
            node = g.node(v);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/rank/util.js
  var require_util2 = __commonJS({
    "node_modules/dagre/lib/rank/util.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      module.exports = {
        longestPath,
        slack
      };
      function longestPath(g) {
        var visited = {};
        function dfs(v) {
          var label = g.node(v);
          if (_.has(visited, v)) {
            return label.rank;
          }
          visited[v] = true;
          var rank = _.min(_.map(g.outEdges(v), function(e) {
            return dfs(e.w) - g.edge(e).minlen;
          }));
          if (rank === Number.POSITIVE_INFINITY || rank === void 0 || rank === null) {
            rank = 0;
          }
          return label.rank = rank;
        }
        _.forEach(g.sources(), dfs);
      }
      function slack(g, e) {
        return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
      }
    }
  });

  // node_modules/dagre/lib/rank/feasible-tree.js
  var require_feasible_tree = __commonJS({
    "node_modules/dagre/lib/rank/feasible-tree.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var Graph = require_graphlib4().Graph;
      var slack = require_util2().slack;
      module.exports = feasibleTree;
      function feasibleTree(g) {
        var t = new Graph({ directed: false });
        var start = g.nodes()[0];
        var size = g.nodeCount();
        t.setNode(start, {});
        var edge, delta;
        while (tightTree(t, g) < size) {
          edge = findMinSlackEdge(t, g);
          delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
          shiftRanks(t, g, delta);
        }
        return t;
      }
      function tightTree(t, g) {
        function dfs(v) {
          _.forEach(g.nodeEdges(v), function(e) {
            var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
            if (!t.hasNode(w) && !slack(g, e)) {
              t.setNode(w, {});
              t.setEdge(v, w, {});
              dfs(w);
            }
          });
        }
        _.forEach(t.nodes(), dfs);
        return t.nodeCount();
      }
      function findMinSlackEdge(t, g) {
        return _.minBy(g.edges(), function(e) {
          if (t.hasNode(e.v) !== t.hasNode(e.w)) {
            return slack(g, e);
          }
        });
      }
      function shiftRanks(t, g, delta) {
        _.forEach(t.nodes(), function(v) {
          g.node(v).rank += delta;
        });
      }
    }
  });

  // node_modules/dagre/lib/rank/network-simplex.js
  var require_network_simplex = __commonJS({
    "node_modules/dagre/lib/rank/network-simplex.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var feasibleTree = require_feasible_tree();
      var slack = require_util2().slack;
      var initRank = require_util2().longestPath;
      var preorder = require_graphlib4().alg.preorder;
      var postorder = require_graphlib4().alg.postorder;
      var simplify = require_util().simplify;
      module.exports = networkSimplex;
      networkSimplex.initLowLimValues = initLowLimValues;
      networkSimplex.initCutValues = initCutValues;
      networkSimplex.calcCutValue = calcCutValue;
      networkSimplex.leaveEdge = leaveEdge;
      networkSimplex.enterEdge = enterEdge;
      networkSimplex.exchangeEdges = exchangeEdges;
      function networkSimplex(g) {
        g = simplify(g);
        initRank(g);
        var t = feasibleTree(g);
        initLowLimValues(t);
        initCutValues(t, g);
        var e, f;
        while (e = leaveEdge(t)) {
          f = enterEdge(t, g, e);
          exchangeEdges(t, g, e, f);
        }
      }
      function initCutValues(t, g) {
        var vs = postorder(t, t.nodes());
        vs = vs.slice(0, vs.length - 1);
        _.forEach(vs, function(v) {
          assignCutValue(t, g, v);
        });
      }
      function assignCutValue(t, g, child) {
        var childLab = t.node(child);
        var parent = childLab.parent;
        t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
      }
      function calcCutValue(t, g, child) {
        var childLab = t.node(child);
        var parent = childLab.parent;
        var childIsTail = true;
        var graphEdge = g.edge(child, parent);
        var cutValue = 0;
        if (!graphEdge) {
          childIsTail = false;
          graphEdge = g.edge(parent, child);
        }
        cutValue = graphEdge.weight;
        _.forEach(g.nodeEdges(child), function(e) {
          var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
          if (other !== parent) {
            var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
            cutValue += pointsToHead ? otherWeight : -otherWeight;
            if (isTreeEdge(t, child, other)) {
              var otherCutValue = t.edge(child, other).cutvalue;
              cutValue += pointsToHead ? -otherCutValue : otherCutValue;
            }
          }
        });
        return cutValue;
      }
      function initLowLimValues(tree, root2) {
        if (arguments.length < 2) {
          root2 = tree.nodes()[0];
        }
        dfsAssignLowLim(tree, {}, 1, root2);
      }
      function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
        var low = nextLim;
        var label = tree.node(v);
        visited[v] = true;
        _.forEach(tree.neighbors(v), function(w) {
          if (!_.has(visited, w)) {
            nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
          }
        });
        label.low = low;
        label.lim = nextLim++;
        if (parent) {
          label.parent = parent;
        } else {
          delete label.parent;
        }
        return nextLim;
      }
      function leaveEdge(tree) {
        return _.find(tree.edges(), function(e) {
          return tree.edge(e).cutvalue < 0;
        });
      }
      function enterEdge(t, g, edge) {
        var v = edge.v;
        var w = edge.w;
        if (!g.hasEdge(v, w)) {
          v = edge.w;
          w = edge.v;
        }
        var vLabel = t.node(v);
        var wLabel = t.node(w);
        var tailLabel = vLabel;
        var flip = false;
        if (vLabel.lim > wLabel.lim) {
          tailLabel = wLabel;
          flip = true;
        }
        var candidates = _.filter(g.edges(), function(edge2) {
          return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
        });
        return _.minBy(candidates, function(edge2) {
          return slack(g, edge2);
        });
      }
      function exchangeEdges(t, g, e, f) {
        var v = e.v;
        var w = e.w;
        t.removeEdge(v, w);
        t.setEdge(f.v, f.w, {});
        initLowLimValues(t);
        initCutValues(t, g);
        updateRanks(t, g);
      }
      function updateRanks(t, g) {
        var root2 = _.find(t.nodes(), function(v) {
          return !g.node(v).parent;
        });
        var vs = preorder(t, root2);
        vs = vs.slice(1);
        _.forEach(vs, function(v) {
          var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
          if (!edge) {
            edge = g.edge(parent, v);
            flipped = true;
          }
          g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
        });
      }
      function isTreeEdge(tree, u, v) {
        return tree.hasEdge(u, v);
      }
      function isDescendant(tree, vLabel, rootLabel) {
        return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
      }
    }
  });

  // node_modules/dagre/lib/rank/index.js
  var require_rank = __commonJS({
    "node_modules/dagre/lib/rank/index.js"(exports, module) {
      "use strict";
      var rankUtil = require_util2();
      var longestPath = rankUtil.longestPath;
      var feasibleTree = require_feasible_tree();
      var networkSimplex = require_network_simplex();
      module.exports = rank;
      function rank(g) {
        switch (g.graph().ranker) {
          case "network-simplex":
            networkSimplexRanker(g);
            break;
          case "tight-tree":
            tightTreeRanker(g);
            break;
          case "longest-path":
            longestPathRanker(g);
            break;
          default:
            networkSimplexRanker(g);
        }
      }
      var longestPathRanker = longestPath;
      function tightTreeRanker(g) {
        longestPath(g);
        feasibleTree(g);
      }
      function networkSimplexRanker(g) {
        networkSimplex(g);
      }
    }
  });

  // node_modules/dagre/lib/parent-dummy-chains.js
  var require_parent_dummy_chains = __commonJS({
    "node_modules/dagre/lib/parent-dummy-chains.js"(exports, module) {
      var _ = require_lodash4();
      module.exports = parentDummyChains;
      function parentDummyChains(g) {
        var postorderNums = postorder(g);
        _.forEach(g.graph().dummyChains, function(v) {
          var node = g.node(v);
          var edgeObj = node.edgeObj;
          var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
          var path = pathData.path;
          var lca = pathData.lca;
          var pathIdx = 0;
          var pathV = path[pathIdx];
          var ascending2 = true;
          while (v !== edgeObj.w) {
            node = g.node(v);
            if (ascending2) {
              while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
                pathIdx++;
              }
              if (pathV === lca) {
                ascending2 = false;
              }
            }
            if (!ascending2) {
              while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
                pathIdx++;
              }
              pathV = path[pathIdx];
            }
            g.setParent(v, pathV);
            v = g.successors(v)[0];
          }
        });
      }
      function findPath(g, postorderNums, v, w) {
        var vPath = [];
        var wPath = [];
        var low = Math.min(postorderNums[v].low, postorderNums[w].low);
        var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
        var parent;
        var lca;
        parent = v;
        do {
          parent = g.parent(parent);
          vPath.push(parent);
        } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
        lca = parent;
        parent = w;
        while ((parent = g.parent(parent)) !== lca) {
          wPath.push(parent);
        }
        return { path: vPath.concat(wPath.reverse()), lca };
      }
      function postorder(g) {
        var result = {};
        var lim = 0;
        function dfs(v) {
          var low = lim;
          _.forEach(g.children(v), dfs);
          result[v] = { low, lim: lim++ };
        }
        _.forEach(g.children(), dfs);
        return result;
      }
    }
  });

  // node_modules/dagre/lib/nesting-graph.js
  var require_nesting_graph = __commonJS({
    "node_modules/dagre/lib/nesting-graph.js"(exports, module) {
      var _ = require_lodash4();
      var util = require_util();
      module.exports = {
        run,
        cleanup
      };
      function run(g) {
        var root2 = util.addDummyNode(g, "root", {}, "_root");
        var depths = treeDepths(g);
        var height = _.max(_.values(depths)) - 1;
        var nodeSep = 2 * height + 1;
        g.graph().nestingRoot = root2;
        _.forEach(g.edges(), function(e) {
          g.edge(e).minlen *= nodeSep;
        });
        var weight = sumWeights(g) + 1;
        _.forEach(g.children(), function(child) {
          dfs(g, root2, nodeSep, weight, height, depths, child);
        });
        g.graph().nodeRankFactor = nodeSep;
      }
      function dfs(g, root2, nodeSep, weight, height, depths, v) {
        var children2 = g.children(v);
        if (!children2.length) {
          if (v !== root2) {
            g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
          }
          return;
        }
        var top = util.addBorderNode(g, "_bt");
        var bottom = util.addBorderNode(g, "_bb");
        var label = g.node(v);
        g.setParent(top, v);
        label.borderTop = top;
        g.setParent(bottom, v);
        label.borderBottom = bottom;
        _.forEach(children2, function(child) {
          dfs(g, root2, nodeSep, weight, height, depths, child);
          var childNode = g.node(child);
          var childTop = childNode.borderTop ? childNode.borderTop : child;
          var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
          var thisWeight = childNode.borderTop ? weight : 2 * weight;
          var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
          g.setEdge(top, childTop, {
            weight: thisWeight,
            minlen,
            nestingEdge: true
          });
          g.setEdge(childBottom, bottom, {
            weight: thisWeight,
            minlen,
            nestingEdge: true
          });
        });
        if (!g.parent(v)) {
          g.setEdge(root2, top, { weight: 0, minlen: height + depths[v] });
        }
      }
      function treeDepths(g) {
        var depths = {};
        function dfs2(v, depth) {
          var children2 = g.children(v);
          if (children2 && children2.length) {
            _.forEach(children2, function(child) {
              dfs2(child, depth + 1);
            });
          }
          depths[v] = depth;
        }
        _.forEach(g.children(), function(v) {
          dfs2(v, 1);
        });
        return depths;
      }
      function sumWeights(g) {
        return _.reduce(g.edges(), function(acc, e) {
          return acc + g.edge(e).weight;
        }, 0);
      }
      function cleanup(g) {
        var graphLabel = g.graph();
        g.removeNode(graphLabel.nestingRoot);
        delete graphLabel.nestingRoot;
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.nestingEdge) {
            g.removeEdge(e);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/add-border-segments.js
  var require_add_border_segments = __commonJS({
    "node_modules/dagre/lib/add-border-segments.js"(exports, module) {
      var _ = require_lodash4();
      var util = require_util();
      module.exports = addBorderSegments;
      function addBorderSegments(g) {
        function dfs(v) {
          var children2 = g.children(v);
          var node = g.node(v);
          if (children2.length) {
            _.forEach(children2, dfs);
          }
          if (_.has(node, "minRank")) {
            node.borderLeft = [];
            node.borderRight = [];
            for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
              addBorderNode(g, "borderLeft", "_bl", v, node, rank);
              addBorderNode(g, "borderRight", "_br", v, node, rank);
            }
          }
        }
        _.forEach(g.children(), dfs);
      }
      function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
        var label = { width: 0, height: 0, rank, borderType: prop };
        var prev = sgNode[prop][rank - 1];
        var curr = util.addDummyNode(g, "border", label, prefix);
        sgNode[prop][rank] = curr;
        g.setParent(curr, sg);
        if (prev) {
          g.setEdge(prev, curr, { weight: 1 });
        }
      }
    }
  });

  // node_modules/dagre/lib/coordinate-system.js
  var require_coordinate_system = __commonJS({
    "node_modules/dagre/lib/coordinate-system.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      module.exports = {
        adjust,
        undo
      };
      function adjust(g) {
        var rankDir = g.graph().rankdir.toLowerCase();
        if (rankDir === "lr" || rankDir === "rl") {
          swapWidthHeight(g);
        }
      }
      function undo(g) {
        var rankDir = g.graph().rankdir.toLowerCase();
        if (rankDir === "bt" || rankDir === "rl") {
          reverseY(g);
        }
        if (rankDir === "lr" || rankDir === "rl") {
          swapXY(g);
          swapWidthHeight(g);
        }
      }
      function swapWidthHeight(g) {
        _.forEach(g.nodes(), function(v) {
          swapWidthHeightOne(g.node(v));
        });
        _.forEach(g.edges(), function(e) {
          swapWidthHeightOne(g.edge(e));
        });
      }
      function swapWidthHeightOne(attrs) {
        var w = attrs.width;
        attrs.width = attrs.height;
        attrs.height = w;
      }
      function reverseY(g) {
        _.forEach(g.nodes(), function(v) {
          reverseYOne(g.node(v));
        });
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _.forEach(edge.points, reverseYOne);
          if (_.has(edge, "y")) {
            reverseYOne(edge);
          }
        });
      }
      function reverseYOne(attrs) {
        attrs.y = -attrs.y;
      }
      function swapXY(g) {
        _.forEach(g.nodes(), function(v) {
          swapXYOne(g.node(v));
        });
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _.forEach(edge.points, swapXYOne);
          if (_.has(edge, "x")) {
            swapXYOne(edge);
          }
        });
      }
      function swapXYOne(attrs) {
        var x = attrs.x;
        attrs.x = attrs.y;
        attrs.y = x;
      }
    }
  });

  // node_modules/dagre/lib/order/init-order.js
  var require_init_order = __commonJS({
    "node_modules/dagre/lib/order/init-order.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      module.exports = initOrder;
      function initOrder(g) {
        var visited = {};
        var simpleNodes = _.filter(g.nodes(), function(v) {
          return !g.children(v).length;
        });
        var maxRank = _.max(_.map(simpleNodes, function(v) {
          return g.node(v).rank;
        }));
        var layers = _.map(_.range(maxRank + 1), function() {
          return [];
        });
        function dfs(v) {
          if (_.has(visited, v))
            return;
          visited[v] = true;
          var node = g.node(v);
          layers[node.rank].push(v);
          _.forEach(g.successors(v), dfs);
        }
        var orderedVs = _.sortBy(simpleNodes, function(v) {
          return g.node(v).rank;
        });
        _.forEach(orderedVs, dfs);
        return layers;
      }
    }
  });

  // node_modules/dagre/lib/order/cross-count.js
  var require_cross_count = __commonJS({
    "node_modules/dagre/lib/order/cross-count.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      module.exports = crossCount;
      function crossCount(g, layering) {
        var cc = 0;
        for (var i = 1; i < layering.length; ++i) {
          cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
        }
        return cc;
      }
      function twoLayerCrossCount(g, northLayer, southLayer) {
        var southPos = _.zipObject(
          southLayer,
          _.map(southLayer, function(v, i) {
            return i;
          })
        );
        var southEntries = _.flatten(_.map(northLayer, function(v) {
          return _.sortBy(_.map(g.outEdges(v), function(e) {
            return { pos: southPos[e.w], weight: g.edge(e).weight };
          }), "pos");
        }), true);
        var firstIndex = 1;
        while (firstIndex < southLayer.length)
          firstIndex <<= 1;
        var treeSize = 2 * firstIndex - 1;
        firstIndex -= 1;
        var tree = _.map(new Array(treeSize), function() {
          return 0;
        });
        var cc = 0;
        _.forEach(southEntries.forEach(function(entry) {
          var index = entry.pos + firstIndex;
          tree[index] += entry.weight;
          var weightSum = 0;
          while (index > 0) {
            if (index % 2) {
              weightSum += tree[index + 1];
            }
            index = index - 1 >> 1;
            tree[index] += entry.weight;
          }
          cc += entry.weight * weightSum;
        }));
        return cc;
      }
    }
  });

  // node_modules/dagre/lib/order/barycenter.js
  var require_barycenter = __commonJS({
    "node_modules/dagre/lib/order/barycenter.js"(exports, module) {
      var _ = require_lodash4();
      module.exports = barycenter;
      function barycenter(g, movable) {
        return _.map(movable, function(v) {
          var inV = g.inEdges(v);
          if (!inV.length) {
            return { v };
          } else {
            var result = _.reduce(inV, function(acc, e) {
              var edge = g.edge(e), nodeU = g.node(e.v);
              return {
                sum: acc.sum + edge.weight * nodeU.order,
                weight: acc.weight + edge.weight
              };
            }, { sum: 0, weight: 0 });
            return {
              v,
              barycenter: result.sum / result.weight,
              weight: result.weight
            };
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/order/resolve-conflicts.js
  var require_resolve_conflicts = __commonJS({
    "node_modules/dagre/lib/order/resolve-conflicts.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      module.exports = resolveConflicts;
      function resolveConflicts(entries, cg) {
        var mappedEntries = {};
        _.forEach(entries, function(entry, i) {
          var tmp = mappedEntries[entry.v] = {
            indegree: 0,
            "in": [],
            out: [],
            vs: [entry.v],
            i
          };
          if (!_.isUndefined(entry.barycenter)) {
            tmp.barycenter = entry.barycenter;
            tmp.weight = entry.weight;
          }
        });
        _.forEach(cg.edges(), function(e) {
          var entryV = mappedEntries[e.v];
          var entryW = mappedEntries[e.w];
          if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
            entryW.indegree++;
            entryV.out.push(mappedEntries[e.w]);
          }
        });
        var sourceSet = _.filter(mappedEntries, function(entry) {
          return !entry.indegree;
        });
        return doResolveConflicts(sourceSet);
      }
      function doResolveConflicts(sourceSet) {
        var entries = [];
        function handleIn(vEntry) {
          return function(uEntry) {
            if (uEntry.merged) {
              return;
            }
            if (_.isUndefined(uEntry.barycenter) || _.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
              mergeEntries(vEntry, uEntry);
            }
          };
        }
        function handleOut(vEntry) {
          return function(wEntry) {
            wEntry["in"].push(vEntry);
            if (--wEntry.indegree === 0) {
              sourceSet.push(wEntry);
            }
          };
        }
        while (sourceSet.length) {
          var entry = sourceSet.pop();
          entries.push(entry);
          _.forEach(entry["in"].reverse(), handleIn(entry));
          _.forEach(entry.out, handleOut(entry));
        }
        return _.map(
          _.filter(entries, function(entry2) {
            return !entry2.merged;
          }),
          function(entry2) {
            return _.pick(entry2, ["vs", "i", "barycenter", "weight"]);
          }
        );
      }
      function mergeEntries(target, source) {
        var sum = 0;
        var weight = 0;
        if (target.weight) {
          sum += target.barycenter * target.weight;
          weight += target.weight;
        }
        if (source.weight) {
          sum += source.barycenter * source.weight;
          weight += source.weight;
        }
        target.vs = source.vs.concat(target.vs);
        target.barycenter = sum / weight;
        target.weight = weight;
        target.i = Math.min(source.i, target.i);
        source.merged = true;
      }
    }
  });

  // node_modules/dagre/lib/order/sort.js
  var require_sort = __commonJS({
    "node_modules/dagre/lib/order/sort.js"(exports, module) {
      var _ = require_lodash4();
      var util = require_util();
      module.exports = sort;
      function sort(entries, biasRight) {
        var parts = util.partition(entries, function(entry) {
          return _.has(entry, "barycenter");
        });
        var sortable = parts.lhs, unsortable = _.sortBy(parts.rhs, function(entry) {
          return -entry.i;
        }), vs = [], sum = 0, weight = 0, vsIndex = 0;
        sortable.sort(compareWithBias(!!biasRight));
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
        _.forEach(sortable, function(entry) {
          vsIndex += entry.vs.length;
          vs.push(entry.vs);
          sum += entry.barycenter * entry.weight;
          weight += entry.weight;
          vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
        });
        var result = { vs: _.flatten(vs, true) };
        if (weight) {
          result.barycenter = sum / weight;
          result.weight = weight;
        }
        return result;
      }
      function consumeUnsortable(vs, unsortable, index) {
        var last;
        while (unsortable.length && (last = _.last(unsortable)).i <= index) {
          unsortable.pop();
          vs.push(last.vs);
          index++;
        }
        return index;
      }
      function compareWithBias(bias) {
        return function(entryV, entryW) {
          if (entryV.barycenter < entryW.barycenter) {
            return -1;
          } else if (entryV.barycenter > entryW.barycenter) {
            return 1;
          }
          return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
        };
      }
    }
  });

  // node_modules/dagre/lib/order/sort-subgraph.js
  var require_sort_subgraph = __commonJS({
    "node_modules/dagre/lib/order/sort-subgraph.js"(exports, module) {
      var _ = require_lodash4();
      var barycenter = require_barycenter();
      var resolveConflicts = require_resolve_conflicts();
      var sort = require_sort();
      module.exports = sortSubgraph;
      function sortSubgraph(g, v, cg, biasRight) {
        var movable = g.children(v);
        var node = g.node(v);
        var bl = node ? node.borderLeft : void 0;
        var br = node ? node.borderRight : void 0;
        var subgraphs = {};
        if (bl) {
          movable = _.filter(movable, function(w) {
            return w !== bl && w !== br;
          });
        }
        var barycenters = barycenter(g, movable);
        _.forEach(barycenters, function(entry) {
          if (g.children(entry.v).length) {
            var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
            subgraphs[entry.v] = subgraphResult;
            if (_.has(subgraphResult, "barycenter")) {
              mergeBarycenters(entry, subgraphResult);
            }
          }
        });
        var entries = resolveConflicts(barycenters, cg);
        expandSubgraphs(entries, subgraphs);
        var result = sort(entries, biasRight);
        if (bl) {
          result.vs = _.flatten([bl, result.vs, br], true);
          if (g.predecessors(bl).length) {
            var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
            if (!_.has(result, "barycenter")) {
              result.barycenter = 0;
              result.weight = 0;
            }
            result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
            result.weight += 2;
          }
        }
        return result;
      }
      function expandSubgraphs(entries, subgraphs) {
        _.forEach(entries, function(entry) {
          entry.vs = _.flatten(entry.vs.map(function(v) {
            if (subgraphs[v]) {
              return subgraphs[v].vs;
            }
            return v;
          }), true);
        });
      }
      function mergeBarycenters(target, other) {
        if (!_.isUndefined(target.barycenter)) {
          target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
          target.weight += other.weight;
        } else {
          target.barycenter = other.barycenter;
          target.weight = other.weight;
        }
      }
    }
  });

  // node_modules/dagre/lib/order/build-layer-graph.js
  var require_build_layer_graph = __commonJS({
    "node_modules/dagre/lib/order/build-layer-graph.js"(exports, module) {
      var _ = require_lodash4();
      var Graph = require_graphlib4().Graph;
      module.exports = buildLayerGraph;
      function buildLayerGraph(g, rank, relationship) {
        var root2 = createRootNode(g), result = new Graph({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v) {
          return g.node(v);
        });
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v), parent = g.parent(v);
          if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
            result.setNode(v);
            result.setParent(v, parent || root2);
            _.forEach(g[relationship](v), function(e) {
              var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_.isUndefined(edge) ? edge.weight : 0;
              result.setEdge(u, v, { weight: g.edge(e).weight + weight });
            });
            if (_.has(node, "minRank")) {
              result.setNode(v, {
                borderLeft: node.borderLeft[rank],
                borderRight: node.borderRight[rank]
              });
            }
          }
        });
        return result;
      }
      function createRootNode(g) {
        var v;
        while (g.hasNode(v = _.uniqueId("_root")))
          ;
        return v;
      }
    }
  });

  // node_modules/dagre/lib/order/add-subgraph-constraints.js
  var require_add_subgraph_constraints = __commonJS({
    "node_modules/dagre/lib/order/add-subgraph-constraints.js"(exports, module) {
      var _ = require_lodash4();
      module.exports = addSubgraphConstraints;
      function addSubgraphConstraints(g, cg, vs) {
        var prev = {}, rootPrev;
        _.forEach(vs, function(v) {
          var child = g.parent(v), parent, prevChild;
          while (child) {
            parent = g.parent(child);
            if (parent) {
              prevChild = prev[parent];
              prev[parent] = child;
            } else {
              prevChild = rootPrev;
              rootPrev = child;
            }
            if (prevChild && prevChild !== child) {
              cg.setEdge(prevChild, child);
              return;
            }
            child = parent;
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/order/index.js
  var require_order = __commonJS({
    "node_modules/dagre/lib/order/index.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var initOrder = require_init_order();
      var crossCount = require_cross_count();
      var sortSubgraph = require_sort_subgraph();
      var buildLayerGraph = require_build_layer_graph();
      var addSubgraphConstraints = require_add_subgraph_constraints();
      var Graph = require_graphlib4().Graph;
      var util = require_util();
      module.exports = order;
      function order(g) {
        var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");
        var layering = initOrder(g);
        assignOrder(g, layering);
        var bestCC = Number.POSITIVE_INFINITY, best;
        for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
          sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
          layering = util.buildLayerMatrix(g);
          var cc = crossCount(g, layering);
          if (cc < bestCC) {
            lastBest = 0;
            best = _.cloneDeep(layering);
            bestCC = cc;
          }
        }
        assignOrder(g, best);
      }
      function buildLayerGraphs(g, ranks, relationship) {
        return _.map(ranks, function(rank) {
          return buildLayerGraph(g, rank, relationship);
        });
      }
      function sweepLayerGraphs(layerGraphs, biasRight) {
        var cg = new Graph();
        _.forEach(layerGraphs, function(lg) {
          var root2 = lg.graph().root;
          var sorted = sortSubgraph(lg, root2, cg, biasRight);
          _.forEach(sorted.vs, function(v, i) {
            lg.node(v).order = i;
          });
          addSubgraphConstraints(lg, cg, sorted.vs);
        });
      }
      function assignOrder(g, layering) {
        _.forEach(layering, function(layer) {
          _.forEach(layer, function(v, i) {
            g.node(v).order = i;
          });
        });
      }
    }
  });

  // node_modules/dagre/lib/position/bk.js
  var require_bk = __commonJS({
    "node_modules/dagre/lib/position/bk.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var Graph = require_graphlib4().Graph;
      var util = require_util();
      module.exports = {
        positionX,
        findType1Conflicts,
        findType2Conflicts,
        addConflict,
        hasConflict,
        verticalAlignment,
        horizontalCompaction,
        alignCoordinates,
        findSmallestWidthAlignment,
        balance
      };
      function findType1Conflicts(g, layering) {
        var conflicts = {};
        function visitLayer(prevLayer, layer) {
          var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _.last(layer);
          _.forEach(layer, function(v, i) {
            var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
            if (w || v === lastNode) {
              _.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
                _.forEach(g.predecessors(scanNode), function(u) {
                  var uLabel = g.node(u), uPos = uLabel.order;
                  if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                    addConflict(conflicts, u, scanNode);
                  }
                });
              });
              scanPos = i + 1;
              k0 = k1;
            }
          });
          return layer;
        }
        _.reduce(layering, visitLayer);
        return conflicts;
      }
      function findType2Conflicts(g, layering) {
        var conflicts = {};
        function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
          var v;
          _.forEach(_.range(southPos, southEnd), function(i) {
            v = south[i];
            if (g.node(v).dummy) {
              _.forEach(g.predecessors(v), function(u) {
                var uNode = g.node(u);
                if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                  addConflict(conflicts, u, v);
                }
              });
            }
          });
        }
        function visitLayer(north, south) {
          var prevNorthPos = -1, nextNorthPos, southPos = 0;
          _.forEach(south, function(v, southLookahead) {
            if (g.node(v).dummy === "border") {
              var predecessors = g.predecessors(v);
              if (predecessors.length) {
                nextNorthPos = g.node(predecessors[0]).order;
                scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
                southPos = southLookahead;
                prevNorthPos = nextNorthPos;
              }
            }
            scan(south, southPos, south.length, nextNorthPos, north.length);
          });
          return south;
        }
        _.reduce(layering, visitLayer);
        return conflicts;
      }
      function findOtherInnerSegmentNode(g, v) {
        if (g.node(v).dummy) {
          return _.find(g.predecessors(v), function(u) {
            return g.node(u).dummy;
          });
        }
      }
      function addConflict(conflicts, v, w) {
        if (v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        var conflictsV = conflicts[v];
        if (!conflictsV) {
          conflicts[v] = conflictsV = {};
        }
        conflictsV[w] = true;
      }
      function hasConflict(conflicts, v, w) {
        if (v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        return _.has(conflicts[v], w);
      }
      function verticalAlignment(g, layering, conflicts, neighborFn) {
        var root2 = {}, align = {}, pos = {};
        _.forEach(layering, function(layer) {
          _.forEach(layer, function(v, order) {
            root2[v] = v;
            align[v] = v;
            pos[v] = order;
          });
        });
        _.forEach(layering, function(layer) {
          var prevIdx = -1;
          _.forEach(layer, function(v) {
            var ws = neighborFn(v);
            if (ws.length) {
              ws = _.sortBy(ws, function(w2) {
                return pos[w2];
              });
              var mp = (ws.length - 1) / 2;
              for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
                var w = ws[i];
                if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
                  align[w] = v;
                  align[v] = root2[v] = root2[w];
                  prevIdx = pos[w];
                }
              }
            }
          });
        });
        return { root: root2, align };
      }
      function horizontalCompaction(g, layering, root2, align, reverseSep) {
        var xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
        function iterate(setXsFunc, nextNodesFunc) {
          var stack = blockG.nodes();
          var elem = stack.pop();
          var visited = {};
          while (elem) {
            if (visited[elem]) {
              setXsFunc(elem);
            } else {
              visited[elem] = true;
              stack.push(elem);
              stack = stack.concat(nextNodesFunc(elem));
            }
            elem = stack.pop();
          }
        }
        function pass1(elem) {
          xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
            return Math.max(acc, xs[e.v] + blockG.edge(e));
          }, 0);
        }
        function pass2(elem) {
          var min = blockG.outEdges(elem).reduce(function(acc, e) {
            return Math.min(acc, xs[e.w] - blockG.edge(e));
          }, Number.POSITIVE_INFINITY);
          var node = g.node(elem);
          if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
            xs[elem] = Math.max(xs[elem], min);
          }
        }
        iterate(pass1, blockG.predecessors.bind(blockG));
        iterate(pass2, blockG.successors.bind(blockG));
        _.forEach(align, function(v) {
          xs[v] = xs[root2[v]];
        });
        return xs;
      }
      function buildBlockGraph(g, layering, root2, reverseSep) {
        var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
        _.forEach(layering, function(layer) {
          var u;
          _.forEach(layer, function(v) {
            var vRoot = root2[v];
            blockGraph.setNode(vRoot);
            if (u) {
              var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
              blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
            }
            u = v;
          });
        });
        return blockGraph;
      }
      function findSmallestWidthAlignment(g, xss) {
        return _.minBy(_.values(xss), function(xs) {
          var max = Number.NEGATIVE_INFINITY;
          var min = Number.POSITIVE_INFINITY;
          _.forIn(xs, function(x, v) {
            var halfWidth = width(g, v) / 2;
            max = Math.max(x + halfWidth, max);
            min = Math.min(x - halfWidth, min);
          });
          return max - min;
        });
      }
      function alignCoordinates(xss, alignTo) {
        var alignToVals = _.values(alignTo), alignToMin = _.min(alignToVals), alignToMax = _.max(alignToVals);
        _.forEach(["u", "d"], function(vert) {
          _.forEach(["l", "r"], function(horiz) {
            var alignment = vert + horiz, xs = xss[alignment], delta;
            if (xs === alignTo)
              return;
            var xsVals = _.values(xs);
            delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);
            if (delta) {
              xss[alignment] = _.mapValues(xs, function(x) {
                return x + delta;
              });
            }
          });
        });
      }
      function balance(xss, align) {
        return _.mapValues(xss.ul, function(ignore, v) {
          if (align) {
            return xss[align.toLowerCase()][v];
          } else {
            var xs = _.sortBy(_.map(xss, v));
            return (xs[1] + xs[2]) / 2;
          }
        });
      }
      function positionX(g) {
        var layering = util.buildLayerMatrix(g);
        var conflicts = _.merge(
          findType1Conflicts(g, layering),
          findType2Conflicts(g, layering)
        );
        var xss = {};
        var adjustedLayering;
        _.forEach(["u", "d"], function(vert) {
          adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
          _.forEach(["l", "r"], function(horiz) {
            if (horiz === "r") {
              adjustedLayering = _.map(adjustedLayering, function(inner) {
                return _.values(inner).reverse();
              });
            }
            var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
            var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
            var xs = horizontalCompaction(
              g,
              adjustedLayering,
              align.root,
              align.align,
              horiz === "r"
            );
            if (horiz === "r") {
              xs = _.mapValues(xs, function(x) {
                return -x;
              });
            }
            xss[vert + horiz] = xs;
          });
        });
        var smallestWidth = findSmallestWidthAlignment(g, xss);
        alignCoordinates(xss, smallestWidth);
        return balance(xss, g.graph().align);
      }
      function sep(nodeSep, edgeSep, reverseSep) {
        return function(g, v, w) {
          var vLabel = g.node(v);
          var wLabel = g.node(w);
          var sum = 0;
          var delta;
          sum += vLabel.width / 2;
          if (_.has(vLabel, "labelpos")) {
            switch (vLabel.labelpos.toLowerCase()) {
              case "l":
                delta = -vLabel.width / 2;
                break;
              case "r":
                delta = vLabel.width / 2;
                break;
            }
          }
          if (delta) {
            sum += reverseSep ? delta : -delta;
          }
          delta = 0;
          sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
          sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
          sum += wLabel.width / 2;
          if (_.has(wLabel, "labelpos")) {
            switch (wLabel.labelpos.toLowerCase()) {
              case "l":
                delta = wLabel.width / 2;
                break;
              case "r":
                delta = -wLabel.width / 2;
                break;
            }
          }
          if (delta) {
            sum += reverseSep ? delta : -delta;
          }
          delta = 0;
          return sum;
        };
      }
      function width(g, v) {
        return g.node(v).width;
      }
    }
  });

  // node_modules/dagre/lib/position/index.js
  var require_position = __commonJS({
    "node_modules/dagre/lib/position/index.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var util = require_util();
      var positionX = require_bk().positionX;
      module.exports = position;
      function position(g) {
        g = util.asNonCompoundGraph(g);
        positionY(g);
        _.forEach(positionX(g), function(x, v) {
          g.node(v).x = x;
        });
      }
      function positionY(g) {
        var layering = util.buildLayerMatrix(g);
        var rankSep = g.graph().ranksep;
        var prevY = 0;
        _.forEach(layering, function(layer) {
          var maxHeight = _.max(_.map(layer, function(v) {
            return g.node(v).height;
          }));
          _.forEach(layer, function(v) {
            g.node(v).y = prevY + maxHeight / 2;
          });
          prevY += maxHeight + rankSep;
        });
      }
    }
  });

  // node_modules/dagre/lib/layout.js
  var require_layout = __commonJS({
    "node_modules/dagre/lib/layout.js"(exports, module) {
      "use strict";
      var _ = require_lodash4();
      var acyclic = require_acyclic();
      var normalize = require_normalize();
      var rank = require_rank();
      var normalizeRanks = require_util().normalizeRanks;
      var parentDummyChains = require_parent_dummy_chains();
      var removeEmptyRanks = require_util().removeEmptyRanks;
      var nestingGraph = require_nesting_graph();
      var addBorderSegments = require_add_border_segments();
      var coordinateSystem = require_coordinate_system();
      var order = require_order();
      var position = require_position();
      var util = require_util();
      var Graph = require_graphlib4().Graph;
      module.exports = layout;
      function layout(g, opts) {
        var time = opts && opts.debugTiming ? util.time : util.notime;
        time("layout", function() {
          var layoutGraph = time("  buildLayoutGraph", function() {
            return buildLayoutGraph(g);
          });
          time("  runLayout", function() {
            runLayout(layoutGraph, time);
          });
          time("  updateInputGraph", function() {
            updateInputGraph(g, layoutGraph);
          });
        });
      }
      function runLayout(g, time) {
        time("    makeSpaceForEdgeLabels", function() {
          makeSpaceForEdgeLabels(g);
        });
        time("    removeSelfEdges", function() {
          removeSelfEdges(g);
        });
        time("    acyclic", function() {
          acyclic.run(g);
        });
        time("    nestingGraph.run", function() {
          nestingGraph.run(g);
        });
        time("    rank", function() {
          rank(util.asNonCompoundGraph(g));
        });
        time("    injectEdgeLabelProxies", function() {
          injectEdgeLabelProxies(g);
        });
        time("    removeEmptyRanks", function() {
          removeEmptyRanks(g);
        });
        time("    nestingGraph.cleanup", function() {
          nestingGraph.cleanup(g);
        });
        time("    normalizeRanks", function() {
          normalizeRanks(g);
        });
        time("    assignRankMinMax", function() {
          assignRankMinMax(g);
        });
        time("    removeEdgeLabelProxies", function() {
          removeEdgeLabelProxies(g);
        });
        time("    normalize.run", function() {
          normalize.run(g);
        });
        time("    parentDummyChains", function() {
          parentDummyChains(g);
        });
        time("    addBorderSegments", function() {
          addBorderSegments(g);
        });
        time("    order", function() {
          order(g);
        });
        time("    insertSelfEdges", function() {
          insertSelfEdges(g);
        });
        time("    adjustCoordinateSystem", function() {
          coordinateSystem.adjust(g);
        });
        time("    position", function() {
          position(g);
        });
        time("    positionSelfEdges", function() {
          positionSelfEdges(g);
        });
        time("    removeBorderNodes", function() {
          removeBorderNodes(g);
        });
        time("    normalize.undo", function() {
          normalize.undo(g);
        });
        time("    fixupEdgeLabelCoords", function() {
          fixupEdgeLabelCoords(g);
        });
        time("    undoCoordinateSystem", function() {
          coordinateSystem.undo(g);
        });
        time("    translateGraph", function() {
          translateGraph(g);
        });
        time("    assignNodeIntersects", function() {
          assignNodeIntersects(g);
        });
        time("    reversePoints", function() {
          reversePointsForReversedEdges(g);
        });
        time("    acyclic.undo", function() {
          acyclic.undo(g);
        });
      }
      function updateInputGraph(inputGraph, layoutGraph) {
        _.forEach(inputGraph.nodes(), function(v) {
          var inputLabel = inputGraph.node(v);
          var layoutLabel = layoutGraph.node(v);
          if (inputLabel) {
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
            if (layoutGraph.children(v).length) {
              inputLabel.width = layoutLabel.width;
              inputLabel.height = layoutLabel.height;
            }
          }
        });
        _.forEach(inputGraph.edges(), function(e) {
          var inputLabel = inputGraph.edge(e);
          var layoutLabel = layoutGraph.edge(e);
          inputLabel.points = layoutLabel.points;
          if (_.has(layoutLabel, "x")) {
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
          }
        });
        inputGraph.graph().width = layoutGraph.graph().width;
        inputGraph.graph().height = layoutGraph.graph().height;
      }
      var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
      var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
      var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
      var nodeNumAttrs = ["width", "height"];
      var nodeDefaults = { width: 0, height: 0 };
      var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
      var edgeDefaults = {
        minlen: 1,
        weight: 1,
        width: 0,
        height: 0,
        labeloffset: 10,
        labelpos: "r"
      };
      var edgeAttrs = ["labelpos"];
      function buildLayoutGraph(inputGraph) {
        var g = new Graph({ multigraph: true, compound: true });
        var graph = canonicalize(inputGraph.graph());
        g.setGraph(_.merge(
          {},
          graphDefaults,
          selectNumberAttrs(graph, graphNumAttrs),
          _.pick(graph, graphAttrs)
        ));
        _.forEach(inputGraph.nodes(), function(v) {
          var node = canonicalize(inputGraph.node(v));
          g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
          g.setParent(v, inputGraph.parent(v));
        });
        _.forEach(inputGraph.edges(), function(e) {
          var edge = canonicalize(inputGraph.edge(e));
          g.setEdge(e, _.merge(
            {},
            edgeDefaults,
            selectNumberAttrs(edge, edgeNumAttrs),
            _.pick(edge, edgeAttrs)
          ));
        });
        return g;
      }
      function makeSpaceForEdgeLabels(g) {
        var graph = g.graph();
        graph.ranksep /= 2;
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          edge.minlen *= 2;
          if (edge.labelpos.toLowerCase() !== "c") {
            if (graph.rankdir === "TB" || graph.rankdir === "BT") {
              edge.width += edge.labeloffset;
            } else {
              edge.height += edge.labeloffset;
            }
          }
        });
      }
      function injectEdgeLabelProxies(g) {
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.width && edge.height) {
            var v = g.node(e.v);
            var w = g.node(e.w);
            var label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
            util.addDummyNode(g, "edge-proxy", label, "_ep");
          }
        });
      }
      function assignRankMinMax(g) {
        var maxRank = 0;
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.borderTop) {
            node.minRank = g.node(node.borderTop).rank;
            node.maxRank = g.node(node.borderBottom).rank;
            maxRank = _.max(maxRank, node.maxRank);
          }
        });
        g.graph().maxRank = maxRank;
      }
      function removeEdgeLabelProxies(g) {
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.dummy === "edge-proxy") {
            g.edge(node.e).labelRank = node.rank;
            g.removeNode(v);
          }
        });
      }
      function translateGraph(g) {
        var minX = Number.POSITIVE_INFINITY;
        var maxX = 0;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = 0;
        var graphLabel = g.graph();
        var marginX = graphLabel.marginx || 0;
        var marginY = graphLabel.marginy || 0;
        function getExtremes(attrs) {
          var x = attrs.x;
          var y = attrs.y;
          var w = attrs.width;
          var h = attrs.height;
          minX = Math.min(minX, x - w / 2);
          maxX = Math.max(maxX, x + w / 2);
          minY = Math.min(minY, y - h / 2);
          maxY = Math.max(maxY, y + h / 2);
        }
        _.forEach(g.nodes(), function(v) {
          getExtremes(g.node(v));
        });
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (_.has(edge, "x")) {
            getExtremes(edge);
          }
        });
        minX -= marginX;
        minY -= marginY;
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          node.x -= minX;
          node.y -= minY;
        });
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _.forEach(edge.points, function(p) {
            p.x -= minX;
            p.y -= minY;
          });
          if (_.has(edge, "x")) {
            edge.x -= minX;
          }
          if (_.has(edge, "y")) {
            edge.y -= minY;
          }
        });
        graphLabel.width = maxX - minX + marginX;
        graphLabel.height = maxY - minY + marginY;
      }
      function assignNodeIntersects(g) {
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          var nodeV = g.node(e.v);
          var nodeW = g.node(e.w);
          var p1, p2;
          if (!edge.points) {
            edge.points = [];
            p1 = nodeW;
            p2 = nodeV;
          } else {
            p1 = edge.points[0];
            p2 = edge.points[edge.points.length - 1];
          }
          edge.points.unshift(util.intersectRect(nodeV, p1));
          edge.points.push(util.intersectRect(nodeW, p2));
        });
      }
      function fixupEdgeLabelCoords(g) {
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (_.has(edge, "x")) {
            if (edge.labelpos === "l" || edge.labelpos === "r") {
              edge.width -= edge.labeloffset;
            }
            switch (edge.labelpos) {
              case "l":
                edge.x -= edge.width / 2 + edge.labeloffset;
                break;
              case "r":
                edge.x += edge.width / 2 + edge.labeloffset;
                break;
            }
          }
        });
      }
      function reversePointsForReversedEdges(g) {
        _.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.reversed) {
            edge.points.reverse();
          }
        });
      }
      function removeBorderNodes(g) {
        _.forEach(g.nodes(), function(v) {
          if (g.children(v).length) {
            var node = g.node(v);
            var t = g.node(node.borderTop);
            var b = g.node(node.borderBottom);
            var l = g.node(_.last(node.borderLeft));
            var r = g.node(_.last(node.borderRight));
            node.width = Math.abs(r.x - l.x);
            node.height = Math.abs(b.y - t.y);
            node.x = l.x + node.width / 2;
            node.y = t.y + node.height / 2;
          }
        });
        _.forEach(g.nodes(), function(v) {
          if (g.node(v).dummy === "border") {
            g.removeNode(v);
          }
        });
      }
      function removeSelfEdges(g) {
        _.forEach(g.edges(), function(e) {
          if (e.v === e.w) {
            var node = g.node(e.v);
            if (!node.selfEdges) {
              node.selfEdges = [];
            }
            node.selfEdges.push({ e, label: g.edge(e) });
            g.removeEdge(e);
          }
        });
      }
      function insertSelfEdges(g) {
        var layers = util.buildLayerMatrix(g);
        _.forEach(layers, function(layer) {
          var orderShift = 0;
          _.forEach(layer, function(v, i) {
            var node = g.node(v);
            node.order = i + orderShift;
            _.forEach(node.selfEdges, function(selfEdge) {
              util.addDummyNode(g, "selfedge", {
                width: selfEdge.label.width,
                height: selfEdge.label.height,
                rank: node.rank,
                order: i + ++orderShift,
                e: selfEdge.e,
                label: selfEdge.label
              }, "_se");
            });
            delete node.selfEdges;
          });
        });
      }
      function positionSelfEdges(g) {
        _.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.dummy === "selfedge") {
            var selfNode = g.node(node.e.v);
            var x = selfNode.x + selfNode.width / 2;
            var y = selfNode.y;
            var dx = node.x - x;
            var dy = selfNode.height / 2;
            g.setEdge(node.e, node.label);
            g.removeNode(v);
            node.label.points = [
              { x: x + 2 * dx / 3, y: y - dy },
              { x: x + 5 * dx / 6, y: y - dy },
              { x: x + dx, y },
              { x: x + 5 * dx / 6, y: y + dy },
              { x: x + 2 * dx / 3, y: y + dy }
            ];
            node.label.x = node.x;
            node.label.y = node.y;
          }
        });
      }
      function selectNumberAttrs(obj, attrs) {
        return _.mapValues(_.pick(obj, attrs), Number);
      }
      function canonicalize(attrs) {
        var newAttrs = {};
        _.forEach(attrs, function(v, k) {
          newAttrs[k.toLowerCase()] = v;
        });
        return newAttrs;
      }
    }
  });

  // node_modules/dagre/lib/debug.js
  var require_debug = __commonJS({
    "node_modules/dagre/lib/debug.js"(exports, module) {
      var _ = require_lodash4();
      var util = require_util();
      var Graph = require_graphlib4().Graph;
      module.exports = {
        debugOrdering
      };
      function debugOrdering(g) {
        var layerMatrix = util.buildLayerMatrix(g);
        var h = new Graph({ compound: true, multigraph: true }).setGraph({});
        _.forEach(g.nodes(), function(v) {
          h.setNode(v, { label: v });
          h.setParent(v, "layer" + g.node(v).rank);
        });
        _.forEach(g.edges(), function(e) {
          h.setEdge(e.v, e.w, {}, e.name);
        });
        _.forEach(layerMatrix, function(layer, i) {
          var layerV = "layer" + i;
          h.setNode(layerV, { rank: "same" });
          _.reduce(layer, function(u, v) {
            h.setEdge(u, v, { style: "invis" });
            return v;
          });
        });
        return h;
      }
    }
  });

  // node_modules/dagre/lib/version.js
  var require_version3 = __commonJS({
    "node_modules/dagre/lib/version.js"(exports, module) {
      module.exports = "0.8.5";
    }
  });

  // node_modules/dagre/index.js
  var require_dagre = __commonJS({
    "node_modules/dagre/index.js"(exports, module) {
      module.exports = {
        graphlib: require_graphlib4(),
        layout: require_layout(),
        debug: require_debug(),
        util: {
          time: require_util().time,
          notime: require_util().notime
        },
        version: require_version3()
      };
    }
  });

  // node_modules/dagre-d3/lib/dagre.js
  var require_dagre2 = __commonJS({
    "node_modules/dagre-d3/lib/dagre.js"(exports, module) {
      var dagre;
      if (typeof __require === "function") {
        try {
          dagre = require_dagre();
        } catch (e) {
        }
      }
      if (!dagre) {
        dagre = window.dagre;
      }
      module.exports = dagre;
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-node.js
  var require_intersect_node = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-node.js"(exports, module) {
      module.exports = intersectNode;
      function intersectNode(node, point) {
        return node.intersect(point);
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-ellipse.js
  var require_intersect_ellipse = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-ellipse.js"(exports, module) {
      module.exports = intersectEllipse;
      function intersectEllipse(node, rx, ry, point) {
        var cx = node.x;
        var cy = node.y;
        var px = cx - point.x;
        var py = cy - point.y;
        var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
        var dx = Math.abs(rx * ry * px / det);
        if (point.x < cx) {
          dx = -dx;
        }
        var dy = Math.abs(rx * ry * py / det);
        if (point.y < cy) {
          dy = -dy;
        }
        return { x: cx + dx, y: cy + dy };
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-circle.js
  var require_intersect_circle = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-circle.js"(exports, module) {
      var intersectEllipse = require_intersect_ellipse();
      module.exports = intersectCircle;
      function intersectCircle(node, rx, point) {
        return intersectEllipse(node, rx, rx, point);
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-line.js
  var require_intersect_line = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-line.js"(exports, module) {
      module.exports = intersectLine;
      function intersectLine(p1, p2, q1, q2) {
        var a1, a2, b1, b2, c1, c2;
        var r1, r2, r3, r4;
        var denom, offset, num;
        var x, y;
        a1 = p2.y - p1.y;
        b1 = p1.x - p2.x;
        c1 = p2.x * p1.y - p1.x * p2.y;
        r3 = a1 * q1.x + b1 * q1.y + c1;
        r4 = a1 * q2.x + b1 * q2.y + c1;
        if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
          return;
        }
        a2 = q2.y - q1.y;
        b2 = q1.x - q2.x;
        c2 = q2.x * q1.y - q1.x * q2.y;
        r1 = a2 * p1.x + b2 * p1.y + c2;
        r2 = a2 * p2.x + b2 * p2.y + c2;
        if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
          return;
        }
        denom = a1 * b2 - a2 * b1;
        if (denom === 0) {
          return;
        }
        offset = Math.abs(denom / 2);
        num = b1 * c2 - b2 * c1;
        x = num < 0 ? (num - offset) / denom : (num + offset) / denom;
        num = a2 * c1 - a1 * c2;
        y = num < 0 ? (num - offset) / denom : (num + offset) / denom;
        return { x, y };
      }
      function sameSign(r1, r2) {
        return r1 * r2 > 0;
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-polygon.js
  var require_intersect_polygon = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-polygon.js"(exports, module) {
      var intersectLine = require_intersect_line();
      module.exports = intersectPolygon;
      function intersectPolygon(node, polyPoints, point) {
        var x1 = node.x;
        var y1 = node.y;
        var intersections = [];
        var minX = Number.POSITIVE_INFINITY;
        var minY = Number.POSITIVE_INFINITY;
        polyPoints.forEach(function(entry) {
          minX = Math.min(minX, entry.x);
          minY = Math.min(minY, entry.y);
        });
        var left = x1 - node.width / 2 - minX;
        var top = y1 - node.height / 2 - minY;
        for (var i = 0; i < polyPoints.length; i++) {
          var p1 = polyPoints[i];
          var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
          var intersect = intersectLine(
            node,
            point,
            { x: left + p1.x, y: top + p1.y },
            { x: left + p2.x, y: top + p2.y }
          );
          if (intersect) {
            intersections.push(intersect);
          }
        }
        if (!intersections.length) {
          console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", node);
          return node;
        }
        if (intersections.length > 1) {
          intersections.sort(function(p, q) {
            var pdx = p.x - point.x;
            var pdy = p.y - point.y;
            var distp = Math.sqrt(pdx * pdx + pdy * pdy);
            var qdx = q.x - point.x;
            var qdy = q.y - point.y;
            var distq = Math.sqrt(qdx * qdx + qdy * qdy);
            return distp < distq ? -1 : distp === distq ? 0 : 1;
          });
        }
        return intersections[0];
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/intersect-rect.js
  var require_intersect_rect = __commonJS({
    "node_modules/dagre-d3/lib/intersect/intersect-rect.js"(exports, module) {
      module.exports = intersectRect;
      function intersectRect(node, point) {
        var x = node.x;
        var y = node.y;
        var dx = point.x - x;
        var dy = point.y - y;
        var w = node.width / 2;
        var h = node.height / 2;
        var sx, sy;
        if (Math.abs(dy) * w > Math.abs(dx) * h) {
          if (dy < 0) {
            h = -h;
          }
          sx = dy === 0 ? 0 : h * dx / dy;
          sy = h;
        } else {
          if (dx < 0) {
            w = -w;
          }
          sx = w;
          sy = dx === 0 ? 0 : w * dy / dx;
        }
        return { x: x + sx, y: y + sy };
      }
    }
  });

  // node_modules/dagre-d3/lib/intersect/index.js
  var require_intersect = __commonJS({
    "node_modules/dagre-d3/lib/intersect/index.js"(exports, module) {
      module.exports = {
        node: require_intersect_node(),
        circle: require_intersect_circle(),
        ellipse: require_intersect_ellipse(),
        polygon: require_intersect_polygon(),
        rect: require_intersect_rect()
      };
    }
  });

  // node_modules/dagre-d3/lib/lodash.js
  var require_lodash5 = __commonJS({
    "node_modules/dagre-d3/lib/lodash.js"(exports, module) {
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            defaults: require_defaults(),
            each: require_each(),
            isFunction: require_isFunction(),
            isPlainObject: require_isPlainObject(),
            pick: require_pick(),
            has: require_has(),
            range: require_range(),
            uniqueId: require_uniqueId()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/dagre-d3/node_modules/d3-array/dist/d3-array.js
  var require_d3_array = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-array/dist/d3-array.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        function ascending2(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        function bisector(compare) {
          if (compare.length === 1)
            compare = ascendingComparator(compare);
          return {
            left: function(a, x, lo, hi) {
              if (lo == null)
                lo = 0;
              if (hi == null)
                hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0)
                  lo = mid + 1;
                else
                  hi = mid;
              }
              return lo;
            },
            right: function(a, x, lo, hi) {
              if (lo == null)
                lo = 0;
              if (hi == null)
                hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0)
                  hi = mid;
                else
                  lo = mid + 1;
              }
              return lo;
            }
          };
        }
        function ascendingComparator(f) {
          return function(d, x) {
            return ascending2(f(d), x);
          };
        }
        var ascendingBisect = bisector(ascending2);
        var bisectRight = ascendingBisect.right;
        var bisectLeft = ascendingBisect.left;
        function pairs(array3, f) {
          if (f == null)
            f = pair;
          var i = 0, n = array3.length - 1, p = array3[0], pairs2 = new Array(n < 0 ? 0 : n);
          while (i < n)
            pairs2[i] = f(p, p = array3[++i]);
          return pairs2;
        }
        function pair(a, b) {
          return [a, b];
        }
        function cross(values0, values1, reduce) {
          var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
          if (reduce == null)
            reduce = pair;
          for (i0 = i = 0; i0 < n0; ++i0) {
            for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
              values[i] = reduce(value0, values1[i1]);
            }
          }
          return values;
        }
        function descending(a, b) {
          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        }
        function number(x) {
          return x === null ? NaN : +x;
        }
        function variance(values, valueof) {
          var n = values.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i]))) {
                delta = value - mean2;
                mean2 += delta / ++m;
                sum2 += delta * (value - mean2);
              }
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values)))) {
                delta = value - mean2;
                mean2 += delta / ++m;
                sum2 += delta * (value - mean2);
              }
            }
          }
          if (m > 1)
            return sum2 / (m - 1);
        }
        function deviation(array3, f) {
          var v = variance(array3, f);
          return v ? Math.sqrt(v) : v;
        }
        function extent(values, valueof) {
          var n = values.length, i = -1, value, min2, max2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                min2 = max2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null) {
                    if (min2 > value)
                      min2 = value;
                    if (max2 < value)
                      max2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min2 = max2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null) {
                    if (min2 > value)
                      min2 = value;
                    if (max2 < value)
                      max2 = value;
                  }
                }
              }
            }
          }
          return [min2, max2];
        }
        var array2 = Array.prototype;
        var slice = array2.slice;
        var map = array2.map;
        function constant(x) {
          return function() {
            return x;
          };
        }
        function identity(x) {
          return x;
        }
        function range(start, stop, step) {
          start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
          var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
          while (++i < n) {
            range2[i] = start + i * step;
          }
          return range2;
        }
        var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
        function ticks(start, stop, count) {
          var reverse, i = -1, n, ticks2, step;
          stop = +stop, start = +start, count = +count;
          if (start === stop && count > 0)
            return [start];
          if (reverse = stop < start)
            n = start, start = stop, stop = n;
          if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))
            return [];
          if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks2 = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n)
              ticks2[i] = (start + i) * step;
          } else {
            start = Math.floor(start * step);
            stop = Math.ceil(stop * step);
            ticks2 = new Array(n = Math.ceil(start - stop + 1));
            while (++i < n)
              ticks2[i] = (start - i) / step;
          }
          if (reverse)
            ticks2.reverse();
          return ticks2;
        }
        function tickIncrement(start, stop, count) {
          var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
          return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
        }
        function tickStep(start, stop, count) {
          var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
          if (error >= e10)
            step1 *= 10;
          else if (error >= e5)
            step1 *= 5;
          else if (error >= e2)
            step1 *= 2;
          return stop < start ? -step1 : step1;
        }
        function sturges(values) {
          return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
        }
        function histogram() {
          var value = identity, domain = extent, threshold = sturges;
          function histogram2(data) {
            var i, n = data.length, x, values = new Array(n);
            for (i = 0; i < n; ++i) {
              values[i] = value(data[i], i, data);
            }
            var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
            if (!Array.isArray(tz)) {
              tz = tickStep(x0, x1, tz);
              tz = range(Math.ceil(x0 / tz) * tz, x1, tz);
            }
            var m = tz.length;
            while (tz[0] <= x0)
              tz.shift(), --m;
            while (tz[m - 1] > x1)
              tz.pop(), --m;
            var bins = new Array(m + 1), bin;
            for (i = 0; i <= m; ++i) {
              bin = bins[i] = [];
              bin.x0 = i > 0 ? tz[i - 1] : x0;
              bin.x1 = i < m ? tz[i] : x1;
            }
            for (i = 0; i < n; ++i) {
              x = values[i];
              if (x0 <= x && x <= x1) {
                bins[bisectRight(tz, x, 0, m)].push(data[i]);
              }
            }
            return bins;
          }
          histogram2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram2) : value;
          };
          histogram2.domain = function(_) {
            return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram2) : domain;
          };
          histogram2.thresholds = function(_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram2) : threshold;
          };
          return histogram2;
        }
        function quantile(values, p, valueof) {
          if (valueof == null)
            valueof = number;
          if (!(n = values.length))
            return;
          if ((p = +p) <= 0 || n < 2)
            return +valueof(values[0], 0, values);
          if (p >= 1)
            return +valueof(values[n - 1], n - 1, values);
          var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
          return value0 + (value1 - value0) * (i - i0);
        }
        function freedmanDiaconis(values, min2, max2) {
          values = map.call(values, number).sort(ascending2);
          return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
        }
        function scott(values, min2, max2) {
          return Math.ceil((max2 - min2) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
        }
        function max(values, valueof) {
          var n = values.length, i = -1, value, max2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                max2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null && value > max2) {
                    max2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                max2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && value > max2) {
                    max2 = value;
                  }
                }
              }
            }
          }
          return max2;
        }
        function mean(values, valueof) {
          var n = values.length, m = n, i = -1, value, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i])))
                sum2 += value;
              else
                --m;
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values))))
                sum2 += value;
              else
                --m;
            }
          }
          if (m)
            return sum2 / m;
        }
        function median(values, valueof) {
          var n = values.length, i = -1, value, numbers = [];
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i]))) {
                numbers.push(value);
              }
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values)))) {
                numbers.push(value);
              }
            }
          }
          return quantile(numbers.sort(ascending2), 0.5);
        }
        function merge(arrays) {
          var n = arrays.length, m, i = -1, j = 0, merged, array3;
          while (++i < n)
            j += arrays[i].length;
          merged = new Array(j);
          while (--n >= 0) {
            array3 = arrays[n];
            m = array3.length;
            while (--m >= 0) {
              merged[--j] = array3[m];
            }
          }
          return merged;
        }
        function min(values, valueof) {
          var n = values.length, i = -1, value, min2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                min2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null && min2 > value) {
                    min2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && min2 > value) {
                    min2 = value;
                  }
                }
              }
            }
          }
          return min2;
        }
        function permute(array3, indexes) {
          var i = indexes.length, permutes = new Array(i);
          while (i--)
            permutes[i] = array3[indexes[i]];
          return permutes;
        }
        function scan(values, compare) {
          if (!(n = values.length))
            return;
          var n, i = 0, j = 0, xi, xj = values[j];
          if (compare == null)
            compare = ascending2;
          while (++i < n) {
            if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
              xj = xi, j = i;
            }
          }
          if (compare(xj, xj) === 0)
            return j;
        }
        function shuffle(array3, i0, i1) {
          var m = (i1 == null ? array3.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array3[m + i0];
            array3[m + i0] = array3[i + i0];
            array3[i + i0] = t;
          }
          return array3;
        }
        function sum(values, valueof) {
          var n = values.length, i = -1, value, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (value = +values[i])
                sum2 += value;
            }
          } else {
            while (++i < n) {
              if (value = +valueof(values[i], i, values))
                sum2 += value;
            }
          }
          return sum2;
        }
        function transpose(matrix) {
          if (!(n = matrix.length))
            return [];
          for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
              row[j] = matrix[j][i];
            }
          }
          return transpose2;
        }
        function length(d) {
          return d.length;
        }
        function zip() {
          return transpose(arguments);
        }
        exports2.bisect = bisectRight;
        exports2.bisectRight = bisectRight;
        exports2.bisectLeft = bisectLeft;
        exports2.ascending = ascending2;
        exports2.bisector = bisector;
        exports2.cross = cross;
        exports2.descending = descending;
        exports2.deviation = deviation;
        exports2.extent = extent;
        exports2.histogram = histogram;
        exports2.thresholdFreedmanDiaconis = freedmanDiaconis;
        exports2.thresholdScott = scott;
        exports2.thresholdSturges = sturges;
        exports2.max = max;
        exports2.mean = mean;
        exports2.median = median;
        exports2.merge = merge;
        exports2.min = min;
        exports2.pairs = pairs;
        exports2.permute = permute;
        exports2.quantile = quantile;
        exports2.range = range;
        exports2.scan = scan;
        exports2.shuffle = shuffle;
        exports2.sum = sum;
        exports2.ticks = ticks;
        exports2.tickIncrement = tickIncrement;
        exports2.tickStep = tickStep;
        exports2.transpose = transpose;
        exports2.variance = variance;
        exports2.zip = zip;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-axis/dist/d3-axis.js
  var require_d3_axis = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-axis/dist/d3-axis.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        var slice = Array.prototype.slice;
        function identity(x) {
          return x;
        }
        var top = 1, right = 2, bottom = 3, left = 4, epsilon = 1e-6;
        function translateX(x) {
          return "translate(" + (x + 0.5) + ",0)";
        }
        function translateY(y) {
          return "translate(0," + (y + 0.5) + ")";
        }
        function number(scale) {
          return function(d) {
            return +scale(d);
          };
        }
        function center(scale) {
          var offset = Math.max(0, scale.bandwidth() - 1) / 2;
          if (scale.round())
            offset = Math.round(offset);
          return function(d) {
            return +scale(d) + offset;
          };
        }
        function entering() {
          return !this.__axis;
        }
        function axis(orient, scale) {
          var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
          function axis2(context) {
            var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center : number)(scale.copy()), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
            path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
            tick = tick.merge(tickEnter);
            line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
            text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
            if (context !== selection2) {
              path = path.transition(context);
              tick = tick.transition(context);
              line = line.transition(context);
              text = text.transition(context);
              tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
                return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
              });
              tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
                var p = this.parentNode.__axis;
                return transform(p && isFinite(p = p(d)) ? p : position(d));
              });
            }
            tickExit.remove();
            path.attr("d", orient === left || orient == right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
            tick.attr("opacity", 1).attr("transform", function(d) {
              return transform(position(d));
            });
            line.attr(x + "2", k * tickSizeInner);
            text.attr(x, k * spacing).text(format);
            selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
            selection2.each(function() {
              this.__axis = position;
            });
          }
          axis2.scale = function(_) {
            return arguments.length ? (scale = _, axis2) : scale;
          };
          axis2.ticks = function() {
            return tickArguments = slice.call(arguments), axis2;
          };
          axis2.tickArguments = function(_) {
            return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis2) : tickArguments.slice();
          };
          axis2.tickValues = function(_) {
            return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis2) : tickValues && tickValues.slice();
          };
          axis2.tickFormat = function(_) {
            return arguments.length ? (tickFormat = _, axis2) : tickFormat;
          };
          axis2.tickSize = function(_) {
            return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
          };
          axis2.tickSizeInner = function(_) {
            return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
          };
          axis2.tickSizeOuter = function(_) {
            return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
          };
          axis2.tickPadding = function(_) {
            return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
          };
          return axis2;
        }
        function axisTop(scale) {
          return axis(top, scale);
        }
        function axisRight(scale) {
          return axis(right, scale);
        }
        function axisBottom(scale) {
          return axis(bottom, scale);
        }
        function axisLeft(scale) {
          return axis(left, scale);
        }
        exports2.axisTop = axisTop;
        exports2.axisRight = axisRight;
        exports2.axisBottom = axisBottom;
        exports2.axisLeft = axisLeft;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-dispatch/dist/d3-dispatch.js
  var require_d3_dispatch = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-dispatch/dist/d3-dispatch.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var noop = { value: function() {
        } };
        function dispatch() {
          for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
              throw new Error("illegal type: " + t);
            _[t] = [];
          }
          return new Dispatch(_);
        }
        function Dispatch(_) {
          this._ = _;
        }
        function parseTypenames2(typenames, types) {
          return typenames.trim().split(/^|\s+/).map(function(t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
              name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
              throw new Error("unknown type: " + t);
            return { type: t, name };
          });
        }
        Dispatch.prototype = dispatch.prototype = {
          constructor: Dispatch,
          on: function(typename, callback) {
            var _ = this._, T = parseTypenames2(typename + "", _), t, i = -1, n = T.length;
            if (arguments.length < 2) {
              while (++i < n)
                if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
                  return t;
              return;
            }
            if (callback != null && typeof callback !== "function")
              throw new Error("invalid callback: " + callback);
            while (++i < n) {
              if (t = (typename = T[i]).type)
                _[t] = set(_[t], typename.name, callback);
              else if (callback == null)
                for (t in _)
                  _[t] = set(_[t], typename.name, null);
            }
            return this;
          },
          copy: function() {
            var copy = {}, _ = this._;
            for (var t in _)
              copy[t] = _[t].slice();
            return new Dispatch(copy);
          },
          call: function(type, that) {
            if ((n = arguments.length - 2) > 0)
              for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
              throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
              t[i].value.apply(that, args);
          },
          apply: function(type, that, args) {
            if (!this._.hasOwnProperty(type))
              throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
              t[i].value.apply(that, args);
          }
        };
        function get(type, name) {
          for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
              return c.value;
            }
          }
        }
        function set(type, name, callback) {
          for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
              type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
              break;
            }
          }
          if (callback != null)
            type.push({ name, value: callback });
          return type;
        }
        exports2.dispatch = dispatch;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-selection/dist/d3-selection.js
  var require_d3_selection = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-selection/dist/d3-selection.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var xhtml2 = "http://www.w3.org/1999/xhtml";
        var namespaces = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: xhtml2,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/"
        };
        function namespace(name) {
          var prefix = name += "", i = prefix.indexOf(":");
          if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
          return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
        }
        function creatorInherit2(name) {
          return function() {
            var document2 = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml2 && document2.documentElement.namespaceURI === xhtml2 ? document2.createElement(name) : document2.createElementNS(uri, name);
          };
        }
        function creatorFixed2(fullname) {
          return function() {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
          };
        }
        function creator(name) {
          var fullname = namespace(name);
          return (fullname.local ? creatorFixed2 : creatorInherit2)(fullname);
        }
        function none2() {
        }
        function selector(selector2) {
          return selector2 == null ? none2 : function() {
            return this.querySelector(selector2);
          };
        }
        function selection_select(select2) {
          if (typeof select2 !== "function")
            select2 = selector(select2);
          for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
              if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
                if ("__data__" in node)
                  subnode.__data__ = node.__data__;
                subgroup[i] = subnode;
              }
            }
          }
          return new Selection2(subgroups, this._parents);
        }
        function empty2() {
          return [];
        }
        function selectorAll(selector2) {
          return selector2 == null ? empty2 : function() {
            return this.querySelectorAll(selector2);
          };
        }
        function selection_selectAll(select2) {
          if (typeof select2 !== "function")
            select2 = selectorAll(select2);
          for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
              if (node = group[i]) {
                subgroups.push(select2.call(node, node.__data__, i, group));
                parents.push(node);
              }
            }
          }
          return new Selection2(subgroups, parents);
        }
        function matcher(selector2) {
          return function() {
            return this.matches(selector2);
          };
        }
        function selection_filter(match) {
          if (typeof match !== "function")
            match = matcher(match);
          for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
              if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                subgroup.push(node);
              }
            }
          }
          return new Selection2(subgroups, this._parents);
        }
        function sparse(update) {
          return new Array(update.length);
        }
        function selection_enter() {
          return new Selection2(this._enter || this._groups.map(sparse), this._parents);
        }
        function EnterNode2(parent, datum2) {
          this.ownerDocument = parent.ownerDocument;
          this.namespaceURI = parent.namespaceURI;
          this._next = null;
          this._parent = parent;
          this.__data__ = datum2;
        }
        EnterNode2.prototype = {
          constructor: EnterNode2,
          appendChild: function(child) {
            return this._parent.insertBefore(child, this._next);
          },
          insertBefore: function(child, next) {
            return this._parent.insertBefore(child, next);
          },
          querySelector: function(selector2) {
            return this._parent.querySelector(selector2);
          },
          querySelectorAll: function(selector2) {
            return this._parent.querySelectorAll(selector2);
          }
        };
        function constant(x) {
          return function() {
            return x;
          };
        }
        var keyPrefix = "$";
        function bindIndex2(parent, group, enter, update, exit, data) {
          var i = 0, node, groupLength = group.length, dataLength = data.length;
          for (; i < dataLength; ++i) {
            if (node = group[i]) {
              node.__data__ = data[i];
              update[i] = node;
            } else {
              enter[i] = new EnterNode2(parent, data[i]);
            }
          }
          for (; i < groupLength; ++i) {
            if (node = group[i]) {
              exit[i] = node;
            }
          }
        }
        function bindKey2(parent, group, enter, update, exit, data, key) {
          var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
          for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
              keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
              if (keyValue in nodeByKeyValue) {
                exit[i] = node;
              } else {
                nodeByKeyValue[keyValue] = node;
              }
            }
          }
          for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
              update[i] = node;
              node.__data__ = data[i];
              nodeByKeyValue[keyValue] = null;
            } else {
              enter[i] = new EnterNode2(parent, data[i]);
            }
          }
          for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
              exit[i] = node;
            }
          }
        }
        function selection_data(value, key) {
          if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function(d) {
              data[++j] = d;
            });
            return data;
          }
          var bind = key ? bindKey2 : bindIndex2, parents = this._parents, groups = this._groups;
          if (typeof value !== "function")
            value = constant(value);
          for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
              if (previous = enterGroup[i0]) {
                if (i0 >= i1)
                  i1 = i0 + 1;
                while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                  ;
                previous._next = next || null;
              }
            }
          }
          update = new Selection2(update, parents);
          update._enter = enter;
          update._exit = exit;
          return update;
        }
        function selection_exit() {
          return new Selection2(this._exit || this._groups.map(sparse), this._parents);
        }
        function selection_join(onenter, onupdate, onexit) {
          var enter = this.enter(), update = this, exit = this.exit();
          enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
          if (onupdate != null)
            update = onupdate(update);
          if (onexit == null)
            exit.remove();
          else
            onexit(exit);
          return enter && update ? enter.merge(update).order() : update;
        }
        function selection_merge(selection3) {
          for (var groups0 = this._groups, groups1 = selection3._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
              if (node = group0[i] || group1[i]) {
                merge[i] = node;
              }
            }
          }
          for (; j < m0; ++j) {
            merges[j] = groups0[j];
          }
          return new Selection2(merges, this._parents);
        }
        function selection_order() {
          for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
              if (node = group[i]) {
                if (next && node.compareDocumentPosition(next) ^ 4)
                  next.parentNode.insertBefore(node, next);
                next = node;
              }
            }
          }
          return this;
        }
        function selection_sort(compare) {
          if (!compare)
            compare = ascending2;
          function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
          }
          for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
              if (node = group[i]) {
                sortgroup[i] = node;
              }
            }
            sortgroup.sort(compareNode);
          }
          return new Selection2(sortgroups, this._parents).order();
        }
        function ascending2(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        function selection_call() {
          var callback = arguments[0];
          arguments[0] = this;
          callback.apply(null, arguments);
          return this;
        }
        function selection_nodes() {
          var nodes = new Array(this.size()), i = -1;
          this.each(function() {
            nodes[++i] = this;
          });
          return nodes;
        }
        function selection_node() {
          for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
              var node = group[i];
              if (node)
                return node;
            }
          }
          return null;
        }
        function selection_size() {
          var size = 0;
          this.each(function() {
            ++size;
          });
          return size;
        }
        function selection_empty() {
          return !this.node();
        }
        function selection_each(callback) {
          for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
              if (node = group[i])
                callback.call(node, node.__data__, i, group);
            }
          }
          return this;
        }
        function attrRemove2(name) {
          return function() {
            this.removeAttribute(name);
          };
        }
        function attrRemoveNS2(fullname) {
          return function() {
            this.removeAttributeNS(fullname.space, fullname.local);
          };
        }
        function attrConstant2(name, value) {
          return function() {
            this.setAttribute(name, value);
          };
        }
        function attrConstantNS2(fullname, value) {
          return function() {
            this.setAttributeNS(fullname.space, fullname.local, value);
          };
        }
        function attrFunction2(name, value) {
          return function() {
            var v = value.apply(this, arguments);
            if (v == null)
              this.removeAttribute(name);
            else
              this.setAttribute(name, v);
          };
        }
        function attrFunctionNS2(fullname, value) {
          return function() {
            var v = value.apply(this, arguments);
            if (v == null)
              this.removeAttributeNS(fullname.space, fullname.local);
            else
              this.setAttributeNS(fullname.space, fullname.local, v);
          };
        }
        function selection_attr(name, value) {
          var fullname = namespace(name);
          if (arguments.length < 2) {
            var node = this.node();
            return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
          }
          return this.each((value == null ? fullname.local ? attrRemoveNS2 : attrRemove2 : typeof value === "function" ? fullname.local ? attrFunctionNS2 : attrFunction2 : fullname.local ? attrConstantNS2 : attrConstant2)(fullname, value));
        }
        function defaultView(node) {
          return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
        }
        function styleRemove2(name) {
          return function() {
            this.style.removeProperty(name);
          };
        }
        function styleConstant2(name, value, priority) {
          return function() {
            this.style.setProperty(name, value, priority);
          };
        }
        function styleFunction2(name, value, priority) {
          return function() {
            var v = value.apply(this, arguments);
            if (v == null)
              this.style.removeProperty(name);
            else
              this.style.setProperty(name, v, priority);
          };
        }
        function selection_style(name, value, priority) {
          return arguments.length > 1 ? this.each((value == null ? styleRemove2 : typeof value === "function" ? styleFunction2 : styleConstant2)(name, value, priority == null ? "" : priority)) : styleValue2(this.node(), name);
        }
        function styleValue2(node, name) {
          return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
        }
        function propertyRemove2(name) {
          return function() {
            delete this[name];
          };
        }
        function propertyConstant2(name, value) {
          return function() {
            this[name] = value;
          };
        }
        function propertyFunction2(name, value) {
          return function() {
            var v = value.apply(this, arguments);
            if (v == null)
              delete this[name];
            else
              this[name] = v;
          };
        }
        function selection_property(name, value) {
          return arguments.length > 1 ? this.each((value == null ? propertyRemove2 : typeof value === "function" ? propertyFunction2 : propertyConstant2)(name, value)) : this.node()[name];
        }
        function classArray2(string) {
          return string.trim().split(/^|\s+/);
        }
        function classList2(node) {
          return node.classList || new ClassList2(node);
        }
        function ClassList2(node) {
          this._node = node;
          this._names = classArray2(node.getAttribute("class") || "");
        }
        ClassList2.prototype = {
          add: function(name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
              this._names.push(name);
              this._node.setAttribute("class", this._names.join(" "));
            }
          },
          remove: function(name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
              this._names.splice(i, 1);
              this._node.setAttribute("class", this._names.join(" "));
            }
          },
          contains: function(name) {
            return this._names.indexOf(name) >= 0;
          }
        };
        function classedAdd2(node, names) {
          var list = classList2(node), i = -1, n = names.length;
          while (++i < n)
            list.add(names[i]);
        }
        function classedRemove2(node, names) {
          var list = classList2(node), i = -1, n = names.length;
          while (++i < n)
            list.remove(names[i]);
        }
        function classedTrue2(names) {
          return function() {
            classedAdd2(this, names);
          };
        }
        function classedFalse2(names) {
          return function() {
            classedRemove2(this, names);
          };
        }
        function classedFunction2(names, value) {
          return function() {
            (value.apply(this, arguments) ? classedAdd2 : classedRemove2)(this, names);
          };
        }
        function selection_classed(name, value) {
          var names = classArray2(name + "");
          if (arguments.length < 2) {
            var list = classList2(this.node()), i = -1, n = names.length;
            while (++i < n)
              if (!list.contains(names[i]))
                return false;
            return true;
          }
          return this.each((typeof value === "function" ? classedFunction2 : value ? classedTrue2 : classedFalse2)(names, value));
        }
        function textRemove2() {
          this.textContent = "";
        }
        function textConstant2(value) {
          return function() {
            this.textContent = value;
          };
        }
        function textFunction2(value) {
          return function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
          };
        }
        function selection_text(value) {
          return arguments.length ? this.each(value == null ? textRemove2 : (typeof value === "function" ? textFunction2 : textConstant2)(value)) : this.node().textContent;
        }
        function htmlRemove2() {
          this.innerHTML = "";
        }
        function htmlConstant2(value) {
          return function() {
            this.innerHTML = value;
          };
        }
        function htmlFunction2(value) {
          return function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
          };
        }
        function selection_html(value) {
          return arguments.length ? this.each(value == null ? htmlRemove2 : (typeof value === "function" ? htmlFunction2 : htmlConstant2)(value)) : this.node().innerHTML;
        }
        function raise2() {
          if (this.nextSibling)
            this.parentNode.appendChild(this);
        }
        function selection_raise() {
          return this.each(raise2);
        }
        function lower2() {
          if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
        }
        function selection_lower() {
          return this.each(lower2);
        }
        function selection_append(name) {
          var create2 = typeof name === "function" ? name : creator(name);
          return this.select(function() {
            return this.appendChild(create2.apply(this, arguments));
          });
        }
        function constantNull2() {
          return null;
        }
        function selection_insert(name, before) {
          var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull2 : typeof before === "function" ? before : selector(before);
          return this.select(function() {
            return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
          });
        }
        function remove2() {
          var parent = this.parentNode;
          if (parent)
            parent.removeChild(this);
        }
        function selection_remove() {
          return this.each(remove2);
        }
        function selection_cloneShallow2() {
          var clone = this.cloneNode(false), parent = this.parentNode;
          return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
        }
        function selection_cloneDeep2() {
          var clone = this.cloneNode(true), parent = this.parentNode;
          return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
        }
        function selection_clone(deep) {
          return this.select(deep ? selection_cloneDeep2 : selection_cloneShallow2);
        }
        function selection_datum(value) {
          return arguments.length ? this.property("__data__", value) : this.node().__data__;
        }
        var filterEvents = {};
        exports2.event = null;
        if (typeof document !== "undefined") {
          var element = document.documentElement;
          if (!("onmouseenter" in element)) {
            filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
          }
        }
        function filterContextListener(listener, index, group) {
          listener = contextListener2(listener, index, group);
          return function(event) {
            var related = event.relatedTarget;
            if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
              listener.call(this, event);
            }
          };
        }
        function contextListener2(listener, index, group) {
          return function(event1) {
            var event0 = exports2.event;
            exports2.event = event1;
            try {
              listener.call(this, this.__data__, index, group);
            } finally {
              exports2.event = event0;
            }
          };
        }
        function parseTypenames2(typenames) {
          return typenames.trim().split(/^|\s+/).map(function(t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
              name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name };
          });
        }
        function onRemove2(typename) {
          return function() {
            var on = this.__on;
            if (!on)
              return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
              if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                this.removeEventListener(o.type, o.listener, o.capture);
              } else {
                on[++i] = o;
              }
            }
            if (++i)
              on.length = i;
            else
              delete this.__on;
          };
        }
        function onAdd2(typename, value, capture) {
          var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener2;
          return function(d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
              for (var j = 0, m = on.length; j < m; ++j) {
                if ((o = on[j]).type === typename.type && o.name === typename.name) {
                  this.removeEventListener(o.type, o.listener, o.capture);
                  this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                  o.value = value;
                  return;
                }
              }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value, listener, capture };
            if (!on)
              this.__on = [o];
            else
              on.push(o);
          };
        }
        function selection_on(typename, value, capture) {
          var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
          if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
              for (var j = 0, m = on.length, o; j < m; ++j) {
                for (i = 0, o = on[j]; i < n; ++i) {
                  if ((t = typenames[i]).type === o.type && t.name === o.name) {
                    return o.value;
                  }
                }
              }
            return;
          }
          on = value ? onAdd2 : onRemove2;
          if (capture == null)
            capture = false;
          for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
          return this;
        }
        function customEvent(event1, listener, that, args) {
          var event0 = exports2.event;
          event1.sourceEvent = exports2.event;
          exports2.event = event1;
          try {
            return listener.apply(that, args);
          } finally {
            exports2.event = event0;
          }
        }
        function dispatchEvent2(node, type, params) {
          var window2 = defaultView(node), event = window2.CustomEvent;
          if (typeof event === "function") {
            event = new event(type, params);
          } else {
            event = window2.document.createEvent("Event");
            if (params)
              event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
              event.initEvent(type, false, false);
          }
          node.dispatchEvent(event);
        }
        function dispatchConstant2(type, params) {
          return function() {
            return dispatchEvent2(this, type, params);
          };
        }
        function dispatchFunction2(type, params) {
          return function() {
            return dispatchEvent2(this, type, params.apply(this, arguments));
          };
        }
        function selection_dispatch(type, params) {
          return this.each((typeof params === "function" ? dispatchFunction2 : dispatchConstant2)(type, params));
        }
        var root2 = [null];
        function Selection2(groups, parents) {
          this._groups = groups;
          this._parents = parents;
        }
        function selection2() {
          return new Selection2([[document.documentElement]], root2);
        }
        Selection2.prototype = selection2.prototype = {
          constructor: Selection2,
          select: selection_select,
          selectAll: selection_selectAll,
          filter: selection_filter,
          data: selection_data,
          enter: selection_enter,
          exit: selection_exit,
          join: selection_join,
          merge: selection_merge,
          order: selection_order,
          sort: selection_sort,
          call: selection_call,
          nodes: selection_nodes,
          node: selection_node,
          size: selection_size,
          empty: selection_empty,
          each: selection_each,
          attr: selection_attr,
          style: selection_style,
          property: selection_property,
          classed: selection_classed,
          text: selection_text,
          html: selection_html,
          raise: selection_raise,
          lower: selection_lower,
          append: selection_append,
          insert: selection_insert,
          remove: selection_remove,
          clone: selection_clone,
          datum: selection_datum,
          on: selection_on,
          dispatch: selection_dispatch
        };
        function select(selector2) {
          return typeof selector2 === "string" ? new Selection2([[document.querySelector(selector2)]], [document.documentElement]) : new Selection2([[selector2]], root2);
        }
        function create(name) {
          return select(creator(name).call(document.documentElement));
        }
        var nextId = 0;
        function local() {
          return new Local();
        }
        function Local() {
          this._ = "@" + (++nextId).toString(36);
        }
        Local.prototype = local.prototype = {
          constructor: Local,
          get: function(node) {
            var id = this._;
            while (!(id in node))
              if (!(node = node.parentNode))
                return;
            return node[id];
          },
          set: function(node, value) {
            return node[this._] = value;
          },
          remove: function(node) {
            return this._ in node && delete node[this._];
          },
          toString: function() {
            return this._;
          }
        };
        function sourceEvent() {
          var current = exports2.event, source;
          while (source = current.sourceEvent)
            current = source;
          return current;
        }
        function point(node, event) {
          var svg = node.ownerSVGElement || node;
          if (svg.createSVGPoint) {
            var point2 = svg.createSVGPoint();
            point2.x = event.clientX, point2.y = event.clientY;
            point2 = point2.matrixTransform(node.getScreenCTM().inverse());
            return [point2.x, point2.y];
          }
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
        function mouse(node) {
          var event = sourceEvent();
          if (event.changedTouches)
            event = event.changedTouches[0];
          return point(node, event);
        }
        function selectAll(selector2) {
          return typeof selector2 === "string" ? new Selection2([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection2([selector2 == null ? [] : selector2], root2);
        }
        function touch(node, touches2, identifier) {
          if (arguments.length < 3)
            identifier = touches2, touches2 = sourceEvent().changedTouches;
          for (var i = 0, n = touches2 ? touches2.length : 0, touch2; i < n; ++i) {
            if ((touch2 = touches2[i]).identifier === identifier) {
              return point(node, touch2);
            }
          }
          return null;
        }
        function touches(node, touches2) {
          if (touches2 == null)
            touches2 = sourceEvent().touches;
          for (var i = 0, n = touches2 ? touches2.length : 0, points = new Array(n); i < n; ++i) {
            points[i] = point(node, touches2[i]);
          }
          return points;
        }
        exports2.clientPoint = point;
        exports2.create = create;
        exports2.creator = creator;
        exports2.customEvent = customEvent;
        exports2.local = local;
        exports2.matcher = matcher;
        exports2.mouse = mouse;
        exports2.namespace = namespace;
        exports2.namespaces = namespaces;
        exports2.select = select;
        exports2.selectAll = selectAll;
        exports2.selection = selection2;
        exports2.selector = selector;
        exports2.selectorAll = selectorAll;
        exports2.style = styleValue2;
        exports2.touch = touch;
        exports2.touches = touches;
        exports2.window = defaultView;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-drag/dist/d3-drag.js
  var require_d3_drag = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-drag/dist/d3-drag.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_dispatch(), require_d3_selection()) : typeof define === "function" && define.amd ? define(["exports", "d3-dispatch", "d3-selection"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3));
      })(exports, function(exports2, d3Dispatch, d3Selection) {
        "use strict";
        function nopropagation() {
          d3Selection.event.stopImmediatePropagation();
        }
        function noevent() {
          d3Selection.event.preventDefault();
          d3Selection.event.stopImmediatePropagation();
        }
        function nodrag(view) {
          var root2 = view.document.documentElement, selection2 = d3Selection.select(view).on("dragstart.drag", noevent, true);
          if ("onselectstart" in root2) {
            selection2.on("selectstart.drag", noevent, true);
          } else {
            root2.__noselect = root2.style.MozUserSelect;
            root2.style.MozUserSelect = "none";
          }
        }
        function yesdrag(view, noclick) {
          var root2 = view.document.documentElement, selection2 = d3Selection.select(view).on("dragstart.drag", null);
          if (noclick) {
            selection2.on("click.drag", noevent, true);
            setTimeout(function() {
              selection2.on("click.drag", null);
            }, 0);
          }
          if ("onselectstart" in root2) {
            selection2.on("selectstart.drag", null);
          } else {
            root2.style.MozUserSelect = root2.__noselect;
            delete root2.__noselect;
          }
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
          this.target = target;
          this.type = type;
          this.subject = subject;
          this.identifier = id;
          this.active = active;
          this.x = x;
          this.y = y;
          this.dx = dx;
          this.dy = dy;
          this._ = dispatch;
        }
        DragEvent.prototype.on = function() {
          var value = this._.on.apply(this._, arguments);
          return value === this._ ? this : value;
        };
        function defaultFilter() {
          return !d3Selection.event.ctrlKey && !d3Selection.event.button;
        }
        function defaultContainer() {
          return this.parentNode;
        }
        function defaultSubject(d) {
          return d == null ? { x: d3Selection.event.x, y: d3Selection.event.y } : d;
        }
        function defaultTouchable() {
          return navigator.maxTouchPoints || "ontouchstart" in this;
        }
        function drag() {
          var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = d3Dispatch.dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
          function drag2(selection2) {
            selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
          }
          function mousedowned() {
            if (touchending || !filter2.apply(this, arguments))
              return;
            var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
            if (!gesture)
              return;
            d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
            nodrag(d3Selection.event.view);
            nopropagation();
            mousemoving = false;
            mousedownx = d3Selection.event.clientX;
            mousedowny = d3Selection.event.clientY;
            gesture("start");
          }
          function mousemoved() {
            noevent();
            if (!mousemoving) {
              var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
              mousemoving = dx * dx + dy * dy > clickDistance2;
            }
            gestures.mouse("drag");
          }
          function mouseupped() {
            d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
            yesdrag(d3Selection.event.view, mousemoving);
            noevent();
            gestures.mouse("end");
          }
          function touchstarted() {
            if (!filter2.apply(this, arguments))
              return;
            var touches = d3Selection.event.changedTouches, c = container.apply(this, arguments), n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
              if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
                nopropagation();
                gesture("start");
              }
            }
          }
          function touchmoved() {
            var touches = d3Selection.event.changedTouches, n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
              if (gesture = gestures[touches[i].identifier]) {
                noevent();
                gesture("drag");
              }
            }
          }
          function touchended() {
            var touches = d3Selection.event.changedTouches, n = touches.length, i, gesture;
            if (touchending)
              clearTimeout(touchending);
            touchending = setTimeout(function() {
              touchending = null;
            }, 500);
            for (i = 0; i < n; ++i) {
              if (gesture = gestures[touches[i].identifier]) {
                nopropagation();
                gesture("end");
              }
            }
          }
          function beforestart(id, container2, point, that, args) {
            var p = point(container2, id), s, dx, dy, sublisteners = listeners.copy();
            if (!d3Selection.customEvent(new DragEvent(drag2, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
              if ((d3Selection.event.subject = s = subject.apply(that, args)) == null)
                return false;
              dx = s.x - p[0] || 0;
              dy = s.y - p[1] || 0;
              return true;
            }))
              return;
            return function gesture(type) {
              var p0 = p, n;
              switch (type) {
                case "start":
                  gestures[id] = gesture, n = active++;
                  break;
                case "end":
                  delete gestures[id], --active;
                case "drag":
                  p = point(container2, id), n = active;
                  break;
              }
              d3Selection.customEvent(new DragEvent(drag2, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
            };
          }
          drag2.filter = function(_) {
            return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), drag2) : filter2;
          };
          drag2.container = function(_) {
            return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag2) : container;
          };
          drag2.subject = function(_) {
            return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag2) : subject;
          };
          drag2.touchable = function(_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag2) : touchable;
          };
          drag2.on = function() {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? drag2 : value;
          };
          drag2.clickDistance = function(_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
          };
          return drag2;
        }
        exports2.drag = drag;
        exports2.dragDisable = nodrag;
        exports2.dragEnable = yesdrag;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-color/dist/d3-color.js
  var require_d3_color = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-color/dist/d3-color.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function define2(constructor, factory, prototype) {
          constructor.prototype = factory.prototype = prototype;
          prototype.constructor = constructor;
        }
        function extend(parent, definition) {
          var prototype = Object.create(parent.prototype);
          for (var key in definition)
            prototype[key] = definition[key];
          return prototype;
        }
        function Color() {
        }
        var darker = 0.7;
        var brighter = 1 / darker;
        var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
        var named = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        };
        define2(Color, color, {
          copy: function(channels) {
            return Object.assign(new this.constructor(), this, channels);
          },
          displayable: function() {
            return this.rgb().displayable();
          },
          hex: color_formatHex,
          formatHex: color_formatHex,
          formatHsl: color_formatHsl,
          formatRgb: color_formatRgb,
          toString: color_formatRgb
        });
        function color_formatHex() {
          return this.rgb().formatHex();
        }
        function color_formatHsl() {
          return hslConvert(this).formatHsl();
        }
        function color_formatRgb() {
          return this.rgb().formatRgb();
        }
        function color(format) {
          var m, l;
          format = (format + "").trim().toLowerCase();
          return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
        }
        function rgbn(n) {
          return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
        }
        function rgba(r, g, b, a) {
          if (a <= 0)
            r = g = b = NaN;
          return new Rgb(r, g, b, a);
        }
        function rgbConvert(o) {
          if (!(o instanceof Color))
            o = color(o);
          if (!o)
            return new Rgb();
          o = o.rgb();
          return new Rgb(o.r, o.g, o.b, o.opacity);
        }
        function rgb(r, g, b, opacity) {
          return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
        }
        function Rgb(r, g, b, opacity) {
          this.r = +r;
          this.g = +g;
          this.b = +b;
          this.opacity = +opacity;
        }
        define2(Rgb, rgb, extend(Color, {
          brighter: function(k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
          },
          darker: function(k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
          },
          rgb: function() {
            return this;
          },
          displayable: function() {
            return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
          },
          hex: rgb_formatHex,
          formatHex: rgb_formatHex,
          formatRgb: rgb_formatRgb,
          toString: rgb_formatRgb
        }));
        function rgb_formatHex() {
          return "#" + hex(this.r) + hex(this.g) + hex(this.b);
        }
        function rgb_formatRgb() {
          var a = this.opacity;
          a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
          return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
        }
        function hex(value) {
          value = Math.max(0, Math.min(255, Math.round(value) || 0));
          return (value < 16 ? "0" : "") + value.toString(16);
        }
        function hsla(h, s, l, a) {
          if (a <= 0)
            h = s = l = NaN;
          else if (l <= 0 || l >= 1)
            h = s = NaN;
          else if (s <= 0)
            h = NaN;
          return new Hsl(h, s, l, a);
        }
        function hslConvert(o) {
          if (o instanceof Hsl)
            return new Hsl(o.h, o.s, o.l, o.opacity);
          if (!(o instanceof Color))
            o = color(o);
          if (!o)
            return new Hsl();
          if (o instanceof Hsl)
            return o;
          o = o.rgb();
          var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
          if (s) {
            if (r === max)
              h = (g - b) / s + (g < b) * 6;
            else if (g === max)
              h = (b - r) / s + 2;
            else
              h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
          } else {
            s = l > 0 && l < 1 ? 0 : h;
          }
          return new Hsl(h, s, l, o.opacity);
        }
        function hsl(h, s, l, opacity) {
          return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
        }
        function Hsl(h, s, l, opacity) {
          this.h = +h;
          this.s = +s;
          this.l = +l;
          this.opacity = +opacity;
        }
        define2(Hsl, hsl, extend(Color, {
          brighter: function(k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
          },
          darker: function(k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
          },
          rgb: function() {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb(
              hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
              hsl2rgb(h, m1, m2),
              hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
              this.opacity
            );
          },
          displayable: function() {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
          },
          formatHsl: function() {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
          }
        }));
        function hsl2rgb(h, m1, m2) {
          return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
        }
        var deg2rad = Math.PI / 180;
        var rad2deg = 180 / Math.PI;
        var K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1;
        function labConvert(o) {
          if (o instanceof Lab)
            return new Lab(o.l, o.a, o.b, o.opacity);
          if (o instanceof Hcl)
            return hcl2lab(o);
          if (!(o instanceof Rgb))
            o = rgbConvert(o);
          var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
          if (r === g && g === b)
            x = z = y;
          else {
            x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
            z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
          }
          return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
        }
        function gray(l, opacity) {
          return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
        }
        function lab(l, a, b, opacity) {
          return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
        }
        function Lab(l, a, b, opacity) {
          this.l = +l;
          this.a = +a;
          this.b = +b;
          this.opacity = +opacity;
        }
        define2(Lab, lab, extend(Color, {
          brighter: function(k) {
            return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
          },
          darker: function(k) {
            return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
          },
          rgb: function() {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            x = Xn * lab2xyz(x);
            y = Yn * lab2xyz(y);
            z = Zn * lab2xyz(z);
            return new Rgb(
              lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
              lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
              lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
              this.opacity
            );
          }
        }));
        function xyz2lab(t) {
          return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
        }
        function lab2xyz(t) {
          return t > t1 ? t * t * t : t2 * (t - t0);
        }
        function lrgb2rgb(x) {
          return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
        }
        function rgb2lrgb(x) {
          return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
        }
        function hclConvert(o) {
          if (o instanceof Hcl)
            return new Hcl(o.h, o.c, o.l, o.opacity);
          if (!(o instanceof Lab))
            o = labConvert(o);
          if (o.a === 0 && o.b === 0)
            return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
          var h = Math.atan2(o.b, o.a) * rad2deg;
          return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
        }
        function lch(l, c, h, opacity) {
          return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
        }
        function hcl(h, c, l, opacity) {
          return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
        }
        function Hcl(h, c, l, opacity) {
          this.h = +h;
          this.c = +c;
          this.l = +l;
          this.opacity = +opacity;
        }
        function hcl2lab(o) {
          if (isNaN(o.h))
            return new Lab(o.l, 0, 0, o.opacity);
          var h = o.h * deg2rad;
          return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
        }
        define2(Hcl, hcl, extend(Color, {
          brighter: function(k) {
            return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
          },
          darker: function(k) {
            return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
          },
          rgb: function() {
            return hcl2lab(this).rgb();
          }
        }));
        var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
        function cubehelixConvert(o) {
          if (o instanceof Cubehelix)
            return new Cubehelix(o.h, o.s, o.l, o.opacity);
          if (!(o instanceof Rgb))
            o = rgbConvert(o);
          var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
          return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
        }
        function cubehelix(h, s, l, opacity) {
          return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
        }
        function Cubehelix(h, s, l, opacity) {
          this.h = +h;
          this.s = +s;
          this.l = +l;
          this.opacity = +opacity;
        }
        define2(Cubehelix, cubehelix, extend(Color, {
          brighter: function(k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
          },
          darker: function(k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
          },
          rgb: function() {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb(
              255 * (l + a * (A * cosh + B * sinh)),
              255 * (l + a * (C * cosh + D * sinh)),
              255 * (l + a * (E * cosh)),
              this.opacity
            );
          }
        }));
        exports2.color = color;
        exports2.cubehelix = cubehelix;
        exports2.gray = gray;
        exports2.hcl = hcl;
        exports2.hsl = hsl;
        exports2.lab = lab;
        exports2.lch = lch;
        exports2.rgb = rgb;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-interpolate/dist/d3-interpolate.js
  var require_d3_interpolate = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-interpolate/dist/d3-interpolate.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_color()) : typeof define === "function" && define.amd ? define(["exports", "d3-color"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Color) {
        "use strict";
        function basis(t1, v0, v1, v2, v3) {
          var t2 = t1 * t1, t3 = t2 * t1;
          return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
        }
        function basis$1(values) {
          var n = values.length - 1;
          return function(t) {
            var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
            return basis((t - i / n) * n, v0, v1, v2, v3);
          };
        }
        function basisClosed(values) {
          var n = values.length;
          return function(t) {
            var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
            return basis((t - i / n) * n, v0, v1, v2, v3);
          };
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function linear(a, d) {
          return function(t) {
            return a + t * d;
          };
        }
        function exponential(a, b, y) {
          return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
            return Math.pow(a + t * b, y);
          };
        }
        function hue(a, b) {
          var d = b - a;
          return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
        }
        function gamma(y) {
          return (y = +y) === 1 ? nogamma : function(a, b) {
            return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
          };
        }
        function nogamma(a, b) {
          var d = b - a;
          return d ? linear(a, d) : constant(isNaN(a) ? b : a);
        }
        var rgb = function rgbGamma(y) {
          var color = gamma(y);
          function rgb2(start, end) {
            var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
            return function(t) {
              start.r = r(t);
              start.g = g(t);
              start.b = b(t);
              start.opacity = opacity(t);
              return start + "";
            };
          }
          rgb2.gamma = rgbGamma;
          return rgb2;
        }(1);
        function rgbSpline(spline) {
          return function(colors) {
            var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
            for (i = 0; i < n; ++i) {
              color = d3Color.rgb(colors[i]);
              r[i] = color.r || 0;
              g[i] = color.g || 0;
              b[i] = color.b || 0;
            }
            r = spline(r);
            g = spline(g);
            b = spline(b);
            color.opacity = 1;
            return function(t) {
              color.r = r(t);
              color.g = g(t);
              color.b = b(t);
              return color + "";
            };
          };
        }
        var rgbBasis = rgbSpline(basis$1);
        var rgbBasisClosed = rgbSpline(basisClosed);
        function numberArray(a, b) {
          if (!b)
            b = [];
          var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
          return function(t) {
            for (i = 0; i < n; ++i)
              c[i] = a[i] * (1 - t) + b[i] * t;
            return c;
          };
        }
        function isNumberArray(x) {
          return ArrayBuffer.isView(x) && !(x instanceof DataView);
        }
        function array2(a, b) {
          return (isNumberArray(b) ? numberArray : genericArray)(a, b);
        }
        function genericArray(a, b) {
          var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
          for (i = 0; i < na; ++i)
            x[i] = value(a[i], b[i]);
          for (; i < nb; ++i)
            c[i] = b[i];
          return function(t) {
            for (i = 0; i < na; ++i)
              c[i] = x[i](t);
            return c;
          };
        }
        function date(a, b) {
          var d = new Date();
          return a = +a, b = +b, function(t) {
            return d.setTime(a * (1 - t) + b * t), d;
          };
        }
        function number(a, b) {
          return a = +a, b = +b, function(t) {
            return a * (1 - t) + b * t;
          };
        }
        function object(a, b) {
          var i = {}, c = {}, k;
          if (a === null || typeof a !== "object")
            a = {};
          if (b === null || typeof b !== "object")
            b = {};
          for (k in b) {
            if (k in a) {
              i[k] = value(a[k], b[k]);
            } else {
              c[k] = b[k];
            }
          }
          return function(t) {
            for (k in i)
              c[k] = i[k](t);
            return c;
          };
        }
        var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
        function zero(b) {
          return function() {
            return b;
          };
        }
        function one(b) {
          return function(t) {
            return b(t) + "";
          };
        }
        function string(a, b) {
          var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
          a = a + "", b = b + "";
          while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
            if ((bs = bm.index) > bi) {
              bs = b.slice(bi, bs);
              if (s[i])
                s[i] += bs;
              else
                s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
              if (s[i])
                s[i] += bm;
              else
                s[++i] = bm;
            } else {
              s[++i] = null;
              q.push({ i, x: number(am, bm) });
            }
            bi = reB.lastIndex;
          }
          if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
              s[i] += bs;
            else
              s[++i] = bs;
          }
          return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
            for (var i2 = 0, o; i2 < b; ++i2)
              s[(o = q[i2]).i] = o.x(t);
            return s.join("");
          });
        }
        function value(a, b) {
          var t = typeof b, c;
          return b == null || t === "boolean" ? constant(b) : (t === "number" ? number : t === "string" ? (c = d3Color.color(b)) ? (b = c, rgb) : string : b instanceof d3Color.color ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : number)(a, b);
        }
        function discrete(range) {
          var n = range.length;
          return function(t) {
            return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
          };
        }
        function hue$1(a, b) {
          var i = hue(+a, +b);
          return function(t) {
            var x = i(t);
            return x - 360 * Math.floor(x / 360);
          };
        }
        function round(a, b) {
          return a = +a, b = +b, function(t) {
            return Math.round(a * (1 - t) + b * t);
          };
        }
        var degrees = 180 / Math.PI;
        var identity = {
          translateX: 0,
          translateY: 0,
          rotate: 0,
          skewX: 0,
          scaleX: 1,
          scaleY: 1
        };
        function decompose(a, b, c, d, e, f) {
          var scaleX, scaleY, skewX;
          if (scaleX = Math.sqrt(a * a + b * b))
            a /= scaleX, b /= scaleX;
          if (skewX = a * c + b * d)
            c -= a * skewX, d -= b * skewX;
          if (scaleY = Math.sqrt(c * c + d * d))
            c /= scaleY, d /= scaleY, skewX /= scaleY;
          if (a * d < b * c)
            a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
          return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees,
            skewX: Math.atan(skewX) * degrees,
            scaleX,
            scaleY
          };
        }
        var cssNode, cssRoot, cssView, svgNode;
        function parseCss(value2) {
          if (value2 === "none")
            return identity;
          if (!cssNode)
            cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
          cssNode.style.transform = value2;
          value2 = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
          cssRoot.removeChild(cssNode);
          value2 = value2.slice(7, -1).split(",");
          return decompose(+value2[0], +value2[1], +value2[2], +value2[3], +value2[4], +value2[5]);
        }
        function parseSvg(value2) {
          if (value2 == null)
            return identity;
          if (!svgNode)
            svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
          svgNode.setAttribute("transform", value2);
          if (!(value2 = svgNode.transform.baseVal.consolidate()))
            return identity;
          value2 = value2.matrix;
          return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
        }
        function interpolateTransform(parse2, pxComma, pxParen, degParen) {
          function pop(s) {
            return s.length ? s.pop() + " " : "";
          }
          function translate(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
              var i = s.push("translate(", null, pxComma, null, pxParen);
              q.push({ i: i - 4, x: number(xa, xb) }, { i: i - 2, x: number(ya, yb) });
            } else if (xb || yb) {
              s.push("translate(" + xb + pxComma + yb + pxParen);
            }
          }
          function rotate(a, b, s, q) {
            if (a !== b) {
              if (a - b > 180)
                b += 360;
              else if (b - a > 180)
                a += 360;
              q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b) });
            } else if (b) {
              s.push(pop(s) + "rotate(" + b + degParen);
            }
          }
          function skewX(a, b, s, q) {
            if (a !== b) {
              q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b) });
            } else if (b) {
              s.push(pop(s) + "skewX(" + b + degParen);
            }
          }
          function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
              var i = s.push(pop(s) + "scale(", null, ",", null, ")");
              q.push({ i: i - 4, x: number(xa, xb) }, { i: i - 2, x: number(ya, yb) });
            } else if (xb !== 1 || yb !== 1) {
              s.push(pop(s) + "scale(" + xb + "," + yb + ")");
            }
          }
          return function(a, b) {
            var s = [], q = [];
            a = parse2(a), b = parse2(b);
            translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
            rotate(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null;
            return function(t) {
              var i = -1, n = q.length, o;
              while (++i < n)
                s[(o = q[i]).i] = o.x(t);
              return s.join("");
            };
          };
        }
        var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
        var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
        var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2 = 1e-12;
        function cosh(x) {
          return ((x = Math.exp(x)) + 1 / x) / 2;
        }
        function sinh(x) {
          return ((x = Math.exp(x)) - 1 / x) / 2;
        }
        function tanh(x) {
          return ((x = Math.exp(2 * x)) - 1) / (x + 1);
        }
        function zoom(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
          if (d2 < epsilon2) {
            S = Math.log(w1 / w0) / rho;
            i = function(t) {
              return [
                ux0 + t * dx,
                uy0 + t * dy,
                w0 * Math.exp(rho * t * S)
              ];
            };
          } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;
            i = function(t) {
              var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
              return [
                ux0 + u * dx,
                uy0 + u * dy,
                w0 * coshr0 / cosh(rho * s + r0)
              ];
            };
          }
          i.duration = S * 1e3;
          return i;
        }
        function hsl(hue2) {
          return function(start, end) {
            var h = hue2((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
            return function(t) {
              start.h = h(t);
              start.s = s(t);
              start.l = l(t);
              start.opacity = opacity(t);
              return start + "";
            };
          };
        }
        var hsl$1 = hsl(hue);
        var hslLong = hsl(nogamma);
        function lab(start, end) {
          var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l), a = nogamma(start.a, end.a), b = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.l = l(t);
            start.a = a(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
          };
        }
        function hcl(hue2) {
          return function(start, end) {
            var h = hue2((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
            return function(t) {
              start.h = h(t);
              start.c = c(t);
              start.l = l(t);
              start.opacity = opacity(t);
              return start + "";
            };
          };
        }
        var hcl$1 = hcl(hue);
        var hclLong = hcl(nogamma);
        function cubehelix(hue2) {
          return function cubehelixGamma(y) {
            y = +y;
            function cubehelix2(start, end) {
              var h = hue2((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
              return function(t) {
                start.h = h(t);
                start.s = s(t);
                start.l = l(Math.pow(t, y));
                start.opacity = opacity(t);
                return start + "";
              };
            }
            cubehelix2.gamma = cubehelixGamma;
            return cubehelix2;
          }(1);
        }
        var cubehelix$1 = cubehelix(hue);
        var cubehelixLong = cubehelix(nogamma);
        function piecewise(interpolate, values) {
          var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
          while (i < n)
            I[i] = interpolate(v, v = values[++i]);
          return function(t) {
            var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
            return I[i2](t - i2);
          };
        }
        function quantize(interpolator, n) {
          var samples = new Array(n);
          for (var i = 0; i < n; ++i)
            samples[i] = interpolator(i / (n - 1));
          return samples;
        }
        exports2.interpolate = value;
        exports2.interpolateArray = array2;
        exports2.interpolateBasis = basis$1;
        exports2.interpolateBasisClosed = basisClosed;
        exports2.interpolateCubehelix = cubehelix$1;
        exports2.interpolateCubehelixLong = cubehelixLong;
        exports2.interpolateDate = date;
        exports2.interpolateDiscrete = discrete;
        exports2.interpolateHcl = hcl$1;
        exports2.interpolateHclLong = hclLong;
        exports2.interpolateHsl = hsl$1;
        exports2.interpolateHslLong = hslLong;
        exports2.interpolateHue = hue$1;
        exports2.interpolateLab = lab;
        exports2.interpolateNumber = number;
        exports2.interpolateNumberArray = numberArray;
        exports2.interpolateObject = object;
        exports2.interpolateRgb = rgb;
        exports2.interpolateRgbBasis = rgbBasis;
        exports2.interpolateRgbBasisClosed = rgbBasisClosed;
        exports2.interpolateRound = round;
        exports2.interpolateString = string;
        exports2.interpolateTransformCss = interpolateTransformCss;
        exports2.interpolateTransformSvg = interpolateTransformSvg;
        exports2.interpolateZoom = zoom;
        exports2.piecewise = piecewise;
        exports2.quantize = quantize;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-timer/dist/d3-timer.js
  var require_d3_timer = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-timer/dist/d3-timer.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var frame = 0, timeout = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
          setTimeout(f, 17);
        };
        function now() {
          return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
        }
        function clearNow() {
          clockNow = 0;
        }
        function Timer() {
          this._call = this._time = this._next = null;
        }
        Timer.prototype = timer.prototype = {
          constructor: Timer,
          restart: function(callback, delay, time) {
            if (typeof callback !== "function")
              throw new TypeError("callback is not a function");
            time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail !== this) {
              if (taskTail)
                taskTail._next = this;
              else
                taskHead = this;
              taskTail = this;
            }
            this._call = callback;
            this._time = time;
            sleep();
          },
          stop: function() {
            if (this._call) {
              this._call = null;
              this._time = Infinity;
              sleep();
            }
          }
        };
        function timer(callback, delay, time) {
          var t = new Timer();
          t.restart(callback, delay, time);
          return t;
        }
        function timerFlush() {
          now();
          ++frame;
          var t = taskHead, e;
          while (t) {
            if ((e = clockNow - t._time) >= 0)
              t._call.call(null, e);
            t = t._next;
          }
          --frame;
        }
        function wake() {
          clockNow = (clockLast = clock.now()) + clockSkew;
          frame = timeout = 0;
          try {
            timerFlush();
          } finally {
            frame = 0;
            nap();
            clockNow = 0;
          }
        }
        function poke() {
          var now2 = clock.now(), delay = now2 - clockLast;
          if (delay > pokeDelay)
            clockSkew -= delay, clockLast = now2;
        }
        function nap() {
          var t0, t1 = taskHead, t2, time = Infinity;
          while (t1) {
            if (t1._call) {
              if (time > t1._time)
                time = t1._time;
              t0 = t1, t1 = t1._next;
            } else {
              t2 = t1._next, t1._next = null;
              t1 = t0 ? t0._next = t2 : taskHead = t2;
            }
          }
          taskTail = t0;
          sleep(time);
        }
        function sleep(time) {
          if (frame)
            return;
          if (timeout)
            timeout = clearTimeout(timeout);
          var delay = time - clockNow;
          if (delay > 24) {
            if (time < Infinity)
              timeout = setTimeout(wake, time - clock.now() - clockSkew);
            if (interval)
              interval = clearInterval(interval);
          } else {
            if (!interval)
              clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
            frame = 1, setFrame(wake);
          }
        }
        function timeout$1(callback, delay, time) {
          var t = new Timer();
          delay = delay == null ? 0 : +delay;
          t.restart(function(elapsed) {
            t.stop();
            callback(elapsed + delay);
          }, delay, time);
          return t;
        }
        function interval$1(callback, delay, time) {
          var t = new Timer(), total = delay;
          if (delay == null)
            return t.restart(callback, delay, time), t;
          delay = +delay, time = time == null ? now() : +time;
          t.restart(function tick(elapsed) {
            elapsed += total;
            t.restart(tick, total += delay, time);
            callback(elapsed);
          }, delay, time);
          return t;
        }
        exports2.interval = interval$1;
        exports2.now = now;
        exports2.timeout = timeout$1;
        exports2.timer = timer;
        exports2.timerFlush = timerFlush;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-ease/dist/d3-ease.js
  var require_d3_ease = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-ease/dist/d3-ease.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function linear(t) {
          return +t;
        }
        function quadIn(t) {
          return t * t;
        }
        function quadOut(t) {
          return t * (2 - t);
        }
        function quadInOut(t) {
          return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
        }
        function cubicIn(t) {
          return t * t * t;
        }
        function cubicOut(t) {
          return --t * t * t + 1;
        }
        function cubicInOut(t) {
          return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
        }
        var exponent = 3;
        var polyIn = function custom(e) {
          e = +e;
          function polyIn2(t) {
            return Math.pow(t, e);
          }
          polyIn2.exponent = custom;
          return polyIn2;
        }(exponent);
        var polyOut = function custom(e) {
          e = +e;
          function polyOut2(t) {
            return 1 - Math.pow(1 - t, e);
          }
          polyOut2.exponent = custom;
          return polyOut2;
        }(exponent);
        var polyInOut = function custom(e) {
          e = +e;
          function polyInOut2(t) {
            return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
          }
          polyInOut2.exponent = custom;
          return polyInOut2;
        }(exponent);
        var pi = Math.PI, halfPi = pi / 2;
        function sinIn(t) {
          return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
        }
        function sinOut(t) {
          return Math.sin(t * halfPi);
        }
        function sinInOut(t) {
          return (1 - Math.cos(pi * t)) / 2;
        }
        function tpmt(x) {
          return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
        }
        function expIn(t) {
          return tpmt(1 - +t);
        }
        function expOut(t) {
          return 1 - tpmt(t);
        }
        function expInOut(t) {
          return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
        }
        function circleIn(t) {
          return 1 - Math.sqrt(1 - t * t);
        }
        function circleOut(t) {
          return Math.sqrt(1 - --t * t);
        }
        function circleInOut(t) {
          return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
        }
        var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
        function bounceIn(t) {
          return 1 - bounceOut(1 - t);
        }
        function bounceOut(t) {
          return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
        }
        function bounceInOut(t) {
          return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
        }
        var overshoot = 1.70158;
        var backIn = function custom(s) {
          s = +s;
          function backIn2(t) {
            return (t = +t) * t * (s * (t - 1) + t);
          }
          backIn2.overshoot = custom;
          return backIn2;
        }(overshoot);
        var backOut = function custom(s) {
          s = +s;
          function backOut2(t) {
            return --t * t * ((t + 1) * s + t) + 1;
          }
          backOut2.overshoot = custom;
          return backOut2;
        }(overshoot);
        var backInOut = function custom(s) {
          s = +s;
          function backInOut2(t) {
            return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
          }
          backInOut2.overshoot = custom;
          return backInOut2;
        }(overshoot);
        var tau = 2 * Math.PI, amplitude = 1, period = 0.3;
        var elasticIn = function custom(a, p) {
          var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
          function elasticIn2(t) {
            return a * tpmt(- --t) * Math.sin((s - t) / p);
          }
          elasticIn2.amplitude = function(a2) {
            return custom(a2, p * tau);
          };
          elasticIn2.period = function(p2) {
            return custom(a, p2);
          };
          return elasticIn2;
        }(amplitude, period);
        var elasticOut = function custom(a, p) {
          var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
          function elasticOut2(t) {
            return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
          }
          elasticOut2.amplitude = function(a2) {
            return custom(a2, p * tau);
          };
          elasticOut2.period = function(p2) {
            return custom(a, p2);
          };
          return elasticOut2;
        }(amplitude, period);
        var elasticInOut = function custom(a, p) {
          var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
          function elasticInOut2(t) {
            return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
          }
          elasticInOut2.amplitude = function(a2) {
            return custom(a2, p * tau);
          };
          elasticInOut2.period = function(p2) {
            return custom(a, p2);
          };
          return elasticInOut2;
        }(amplitude, period);
        exports2.easeBack = backInOut;
        exports2.easeBackIn = backIn;
        exports2.easeBackInOut = backInOut;
        exports2.easeBackOut = backOut;
        exports2.easeBounce = bounceOut;
        exports2.easeBounceIn = bounceIn;
        exports2.easeBounceInOut = bounceInOut;
        exports2.easeBounceOut = bounceOut;
        exports2.easeCircle = circleInOut;
        exports2.easeCircleIn = circleIn;
        exports2.easeCircleInOut = circleInOut;
        exports2.easeCircleOut = circleOut;
        exports2.easeCubic = cubicInOut;
        exports2.easeCubicIn = cubicIn;
        exports2.easeCubicInOut = cubicInOut;
        exports2.easeCubicOut = cubicOut;
        exports2.easeElastic = elasticOut;
        exports2.easeElasticIn = elasticIn;
        exports2.easeElasticInOut = elasticInOut;
        exports2.easeElasticOut = elasticOut;
        exports2.easeExp = expInOut;
        exports2.easeExpIn = expIn;
        exports2.easeExpInOut = expInOut;
        exports2.easeExpOut = expOut;
        exports2.easeLinear = linear;
        exports2.easePoly = polyInOut;
        exports2.easePolyIn = polyIn;
        exports2.easePolyInOut = polyInOut;
        exports2.easePolyOut = polyOut;
        exports2.easeQuad = quadInOut;
        exports2.easeQuadIn = quadIn;
        exports2.easeQuadInOut = quadInOut;
        exports2.easeQuadOut = quadOut;
        exports2.easeSin = sinInOut;
        exports2.easeSinIn = sinIn;
        exports2.easeSinInOut = sinInOut;
        exports2.easeSinOut = sinOut;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-transition/dist/d3-transition.js
  var require_d3_transition = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-transition/dist/d3-transition.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_selection(), require_d3_dispatch(), require_d3_timer(), require_d3_interpolate(), require_d3_color(), require_d3_ease()) : typeof define === "function" && define.amd ? define(["exports", "d3-selection", "d3-dispatch", "d3-timer", "d3-interpolate", "d3-color", "d3-ease"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3));
      })(exports, function(exports2, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) {
        "use strict";
        var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
        var emptyTween = [];
        var CREATED = 0;
        var SCHEDULED = 1;
        var STARTING = 2;
        var STARTED = 3;
        var RUNNING = 4;
        var ENDING = 5;
        var ENDED = 6;
        function schedule(node, name, id2, index, group, timing) {
          var schedules = node.__transition;
          if (!schedules)
            node.__transition = {};
          else if (id2 in schedules)
            return;
          create(node, id2, {
            name,
            index,
            group,
            on: emptyOn,
            tween: emptyTween,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED
          });
        }
        function init(node, id2) {
          var schedule2 = get(node, id2);
          if (schedule2.state > CREATED)
            throw new Error("too late; already scheduled");
          return schedule2;
        }
        function set(node, id2) {
          var schedule2 = get(node, id2);
          if (schedule2.state > STARTED)
            throw new Error("too late; already running");
          return schedule2;
        }
        function get(node, id2) {
          var schedule2 = node.__transition;
          if (!schedule2 || !(schedule2 = schedule2[id2]))
            throw new Error("transition not found");
          return schedule2;
        }
        function create(node, id2, self2) {
          var schedules = node.__transition, tween;
          schedules[id2] = self2;
          self2.timer = d3Timer.timer(schedule2, 0, self2.time);
          function schedule2(elapsed) {
            self2.state = SCHEDULED;
            self2.timer.restart(start2, self2.delay, self2.time);
            if (self2.delay <= elapsed)
              start2(elapsed - self2.delay);
          }
          function start2(elapsed) {
            var i, j, n, o;
            if (self2.state !== SCHEDULED)
              return stop();
            for (i in schedules) {
              o = schedules[i];
              if (o.name !== self2.name)
                continue;
              if (o.state === STARTED)
                return d3Timer.timeout(start2);
              if (o.state === RUNNING) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("interrupt", node, node.__data__, o.index, o.group);
                delete schedules[i];
              } else if (+i < id2) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("cancel", node, node.__data__, o.index, o.group);
                delete schedules[i];
              }
            }
            d3Timer.timeout(function() {
              if (self2.state === STARTED) {
                self2.state = RUNNING;
                self2.timer.restart(tick, self2.delay, self2.time);
                tick(elapsed);
              }
            });
            self2.state = STARTING;
            self2.on.call("start", node, node.__data__, self2.index, self2.group);
            if (self2.state !== STARTING)
              return;
            self2.state = STARTED;
            tween = new Array(n = self2.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
              if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
                tween[++j] = o;
              }
            }
            tween.length = j + 1;
          }
          function tick(elapsed) {
            var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
            while (++i < n) {
              tween[i].call(node, t);
            }
            if (self2.state === ENDING) {
              self2.on.call("end", node, node.__data__, self2.index, self2.group);
              stop();
            }
          }
          function stop() {
            self2.state = ENDED;
            self2.timer.stop();
            delete schedules[id2];
            for (var i in schedules)
              return;
            delete node.__transition;
          }
        }
        function interrupt(node, name) {
          var schedules = node.__transition, schedule2, active2, empty2 = true, i;
          if (!schedules)
            return;
          name = name == null ? null : name + "";
          for (i in schedules) {
            if ((schedule2 = schedules[i]).name !== name) {
              empty2 = false;
              continue;
            }
            active2 = schedule2.state > STARTING && schedule2.state < ENDING;
            schedule2.state = ENDED;
            schedule2.timer.stop();
            schedule2.on.call(active2 ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
            delete schedules[i];
          }
          if (empty2)
            delete node.__transition;
        }
        function selection_interrupt(name) {
          return this.each(function() {
            interrupt(this, name);
          });
        }
        function tweenRemove(id2, name) {
          var tween0, tween1;
          return function() {
            var schedule2 = set(this, id2), tween = schedule2.tween;
            if (tween !== tween0) {
              tween1 = tween0 = tween;
              for (var i = 0, n = tween1.length; i < n; ++i) {
                if (tween1[i].name === name) {
                  tween1 = tween1.slice();
                  tween1.splice(i, 1);
                  break;
                }
              }
            }
            schedule2.tween = tween1;
          };
        }
        function tweenFunction(id2, name, value) {
          var tween0, tween1;
          if (typeof value !== "function")
            throw new Error();
          return function() {
            var schedule2 = set(this, id2), tween = schedule2.tween;
            if (tween !== tween0) {
              tween1 = (tween0 = tween).slice();
              for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
                if (tween1[i].name === name) {
                  tween1[i] = t;
                  break;
                }
              }
              if (i === n)
                tween1.push(t);
            }
            schedule2.tween = tween1;
          };
        }
        function transition_tween(name, value) {
          var id2 = this._id;
          name += "";
          if (arguments.length < 2) {
            var tween = get(this.node(), id2).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
              if ((t = tween[i]).name === name) {
                return t.value;
              }
            }
            return null;
          }
          return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
        }
        function tweenValue(transition2, name, value) {
          var id2 = transition2._id;
          transition2.each(function() {
            var schedule2 = set(this, id2);
            (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
          });
          return function(node) {
            return get(node, id2).value[name];
          };
        }
        function interpolate(a, b) {
          var c;
          return (typeof b === "number" ? d3Interpolate.interpolateNumber : b instanceof d3Color.color ? d3Interpolate.interpolateRgb : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb) : d3Interpolate.interpolateString)(a, b);
        }
        function attrRemove2(name) {
          return function() {
            this.removeAttribute(name);
          };
        }
        function attrRemoveNS2(fullname) {
          return function() {
            this.removeAttributeNS(fullname.space, fullname.local);
          };
        }
        function attrConstant2(name, interpolate2, value1) {
          var string00, string1 = value1 + "", interpolate0;
          return function() {
            var string0 = this.getAttribute(name);
            return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
          };
        }
        function attrConstantNS2(fullname, interpolate2, value1) {
          var string00, string1 = value1 + "", interpolate0;
          return function() {
            var string0 = this.getAttributeNS(fullname.space, fullname.local);
            return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
          };
        }
        function attrFunction2(name, interpolate2, value) {
          var string00, string10, interpolate0;
          return function() {
            var string0, value1 = value(this), string1;
            if (value1 == null)
              return void this.removeAttribute(name);
            string0 = this.getAttribute(name);
            string1 = value1 + "";
            return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
          };
        }
        function attrFunctionNS2(fullname, interpolate2, value) {
          var string00, string10, interpolate0;
          return function() {
            var string0, value1 = value(this), string1;
            if (value1 == null)
              return void this.removeAttributeNS(fullname.space, fullname.local);
            string0 = this.getAttributeNS(fullname.space, fullname.local);
            string1 = value1 + "";
            return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
          };
        }
        function transition_attr(name, value) {
          var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
          return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
        }
        function attrInterpolate(name, i) {
          return function(t) {
            this.setAttribute(name, i.call(this, t));
          };
        }
        function attrInterpolateNS(fullname, i) {
          return function(t) {
            this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
          };
        }
        function attrTweenNS(fullname, value) {
          var t0, i0;
          function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
              t0 = (i0 = i) && attrInterpolateNS(fullname, i);
            return t0;
          }
          tween._value = value;
          return tween;
        }
        function attrTween(name, value) {
          var t0, i0;
          function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
              t0 = (i0 = i) && attrInterpolate(name, i);
            return t0;
          }
          tween._value = value;
          return tween;
        }
        function transition_attrTween(name, value) {
          var key = "attr." + name;
          if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
          if (value == null)
            return this.tween(key, null);
          if (typeof value !== "function")
            throw new Error();
          var fullname = d3Selection.namespace(name);
          return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
        }
        function delayFunction(id2, value) {
          return function() {
            init(this, id2).delay = +value.apply(this, arguments);
          };
        }
        function delayConstant(id2, value) {
          return value = +value, function() {
            init(this, id2).delay = value;
          };
        }
        function transition_delay(value) {
          var id2 = this._id;
          return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
        }
        function durationFunction(id2, value) {
          return function() {
            set(this, id2).duration = +value.apply(this, arguments);
          };
        }
        function durationConstant(id2, value) {
          return value = +value, function() {
            set(this, id2).duration = value;
          };
        }
        function transition_duration(value) {
          var id2 = this._id;
          return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
        }
        function easeConstant(id2, value) {
          if (typeof value !== "function")
            throw new Error();
          return function() {
            set(this, id2).ease = value;
          };
        }
        function transition_ease(value) {
          var id2 = this._id;
          return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
        }
        function transition_filter(match) {
          if (typeof match !== "function")
            match = d3Selection.matcher(match);
          for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
              if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                subgroup.push(node);
              }
            }
          }
          return new Transition(subgroups, this._parents, this._name, this._id);
        }
        function transition_merge(transition2) {
          if (transition2._id !== this._id)
            throw new Error();
          for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
              if (node = group0[i] || group1[i]) {
                merge[i] = node;
              }
            }
          }
          for (; j < m0; ++j) {
            merges[j] = groups0[j];
          }
          return new Transition(merges, this._parents, this._name, this._id);
        }
        function start(name) {
          return (name + "").trim().split(/^|\s+/).every(function(t) {
            var i = t.indexOf(".");
            if (i >= 0)
              t = t.slice(0, i);
            return !t || t === "start";
          });
        }
        function onFunction(id2, name, listener) {
          var on0, on1, sit = start(name) ? init : set;
          return function() {
            var schedule2 = sit(this, id2), on = schedule2.on;
            if (on !== on0)
              (on1 = (on0 = on).copy()).on(name, listener);
            schedule2.on = on1;
          };
        }
        function transition_on(name, listener) {
          var id2 = this._id;
          return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
        }
        function removeFunction(id2) {
          return function() {
            var parent = this.parentNode;
            for (var i in this.__transition)
              if (+i !== id2)
                return;
            if (parent)
              parent.removeChild(this);
          };
        }
        function transition_remove() {
          return this.on("end.remove", removeFunction(this._id));
        }
        function transition_select(select) {
          var name = this._name, id2 = this._id;
          if (typeof select !== "function")
            select = d3Selection.selector(select);
          for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
              if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                if ("__data__" in node)
                  subnode.__data__ = node.__data__;
                subgroup[i] = subnode;
                schedule(subgroup[i], name, id2, i, subgroup, get(node, id2));
              }
            }
          }
          return new Transition(subgroups, this._parents, name, id2);
        }
        function transition_selectAll(select) {
          var name = this._name, id2 = this._id;
          if (typeof select !== "function")
            select = d3Selection.selectorAll(select);
          for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
              if (node = group[i]) {
                for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
                  if (child = children2[k]) {
                    schedule(child, name, id2, k, children2, inherit2);
                  }
                }
                subgroups.push(children2);
                parents.push(node);
              }
            }
          }
          return new Transition(subgroups, parents, name, id2);
        }
        var Selection2 = d3Selection.selection.prototype.constructor;
        function transition_selection() {
          return new Selection2(this._groups, this._parents);
        }
        function styleNull(name, interpolate2) {
          var string00, string10, interpolate0;
          return function() {
            var string0 = d3Selection.style(this, name), string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
            return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
          };
        }
        function styleRemove2(name) {
          return function() {
            this.style.removeProperty(name);
          };
        }
        function styleConstant2(name, interpolate2, value1) {
          var string00, string1 = value1 + "", interpolate0;
          return function() {
            var string0 = d3Selection.style(this, name);
            return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
          };
        }
        function styleFunction2(name, interpolate2, value) {
          var string00, string10, interpolate0;
          return function() {
            var string0 = d3Selection.style(this, name), value1 = value(this), string1 = value1 + "";
            if (value1 == null)
              string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
            return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
          };
        }
        function styleMaybeRemove(id2, name) {
          var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
          return function() {
            var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
            if (on !== on0 || listener0 !== listener)
              (on1 = (on0 = on).copy()).on(event, listener0 = listener);
            schedule2.on = on1;
          };
        }
        function transition_style(name, value, priority) {
          var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
          return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
        }
        function styleInterpolate(name, i, priority) {
          return function(t) {
            this.style.setProperty(name, i.call(this, t), priority);
          };
        }
        function styleTween(name, value, priority) {
          var t, i0;
          function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
              t = (i0 = i) && styleInterpolate(name, i, priority);
            return t;
          }
          tween._value = value;
          return tween;
        }
        function transition_styleTween(name, value, priority) {
          var key = "style." + (name += "");
          if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
          if (value == null)
            return this.tween(key, null);
          if (typeof value !== "function")
            throw new Error();
          return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
        }
        function textConstant2(value) {
          return function() {
            this.textContent = value;
          };
        }
        function textFunction2(value) {
          return function() {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
          };
        }
        function transition_text(value) {
          return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
        }
        function textInterpolate(i) {
          return function(t) {
            this.textContent = i.call(this, t);
          };
        }
        function textTween(value) {
          var t0, i0;
          function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
              t0 = (i0 = i) && textInterpolate(i);
            return t0;
          }
          tween._value = value;
          return tween;
        }
        function transition_textTween(value) {
          var key = "text";
          if (arguments.length < 1)
            return (key = this.tween(key)) && key._value;
          if (value == null)
            return this.tween(key, null);
          if (typeof value !== "function")
            throw new Error();
          return this.tween(key, textTween(value));
        }
        function transition_transition() {
          var name = this._name, id0 = this._id, id1 = newId();
          for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
              if (node = group[i]) {
                var inherit2 = get(node, id0);
                schedule(node, name, id1, i, group, {
                  time: inherit2.time + inherit2.delay + inherit2.duration,
                  delay: 0,
                  duration: inherit2.duration,
                  ease: inherit2.ease
                });
              }
            }
          }
          return new Transition(groups, this._parents, name, id1);
        }
        function transition_end() {
          var on0, on1, that = this, id2 = that._id, size = that.size();
          return new Promise(function(resolve, reject) {
            var cancel = { value: reject }, end = { value: function() {
              if (--size === 0)
                resolve();
            } };
            that.each(function() {
              var schedule2 = set(this, id2), on = schedule2.on;
              if (on !== on0) {
                on1 = (on0 = on).copy();
                on1._.cancel.push(cancel);
                on1._.interrupt.push(cancel);
                on1._.end.push(end);
              }
              schedule2.on = on1;
            });
          });
        }
        var id = 0;
        function Transition(groups, parents, name, id2) {
          this._groups = groups;
          this._parents = parents;
          this._name = name;
          this._id = id2;
        }
        function transition(name) {
          return d3Selection.selection().transition(name);
        }
        function newId() {
          return ++id;
        }
        var selection_prototype = d3Selection.selection.prototype;
        Transition.prototype = transition.prototype = {
          constructor: Transition,
          select: transition_select,
          selectAll: transition_selectAll,
          filter: transition_filter,
          merge: transition_merge,
          selection: transition_selection,
          transition: transition_transition,
          call: selection_prototype.call,
          nodes: selection_prototype.nodes,
          node: selection_prototype.node,
          size: selection_prototype.size,
          empty: selection_prototype.empty,
          each: selection_prototype.each,
          on: transition_on,
          attr: transition_attr,
          attrTween: transition_attrTween,
          style: transition_style,
          styleTween: transition_styleTween,
          text: transition_text,
          textTween: transition_textTween,
          remove: transition_remove,
          tween: transition_tween,
          delay: transition_delay,
          duration: transition_duration,
          ease: transition_ease,
          end: transition_end
        };
        var defaultTiming = {
          time: null,
          delay: 0,
          duration: 250,
          ease: d3Ease.easeCubicInOut
        };
        function inherit(node, id2) {
          var timing;
          while (!(timing = node.__transition) || !(timing = timing[id2])) {
            if (!(node = node.parentNode)) {
              return defaultTiming.time = d3Timer.now(), defaultTiming;
            }
          }
          return timing;
        }
        function selection_transition(name) {
          var id2, timing;
          if (name instanceof Transition) {
            id2 = name._id, name = name._name;
          } else {
            id2 = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
          }
          for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
              if (node = group[i]) {
                schedule(node, name, id2, i, group, timing || inherit(node, id2));
              }
            }
          }
          return new Transition(groups, this._parents, name, id2);
        }
        d3Selection.selection.prototype.interrupt = selection_interrupt;
        d3Selection.selection.prototype.transition = selection_transition;
        var root2 = [null];
        function active(node, name) {
          var schedules = node.__transition, schedule2, i;
          if (schedules) {
            name = name == null ? null : name + "";
            for (i in schedules) {
              if ((schedule2 = schedules[i]).state > SCHEDULED && schedule2.name === name) {
                return new Transition([[node]], root2, name, +i);
              }
            }
          }
          return null;
        }
        exports2.active = active;
        exports2.interrupt = interrupt;
        exports2.transition = transition;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-brush/dist/d3-brush.js
  var require_d3_brush = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-brush/dist/d3-brush.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_dispatch(), require_d3_drag(), require_d3_interpolate(), require_d3_selection(), require_d3_transition()) : typeof define === "function" && define.amd ? define(["exports", "d3-dispatch", "d3-drag", "d3-interpolate", "d3-selection", "d3-transition"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3));
      })(exports, function(exports2, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) {
        "use strict";
        function constant(x) {
          return function() {
            return x;
          };
        }
        function BrushEvent(target, type2, selection2) {
          this.target = target;
          this.type = type2;
          this.selection = selection2;
        }
        function nopropagation() {
          d3Selection.event.stopImmediatePropagation();
        }
        function noevent() {
          d3Selection.event.preventDefault();
          d3Selection.event.stopImmediatePropagation();
        }
        var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
        function number1(e) {
          return [+e[0], +e[1]];
        }
        function number2(e) {
          return [number1(e[0]), number1(e[1])];
        }
        function toucher(identifier) {
          return function(target) {
            return d3Selection.touch(target, d3Selection.event.touches, identifier);
          };
        }
        var X = {
          name: "x",
          handles: ["w", "e"].map(type),
          input: function(x, e) {
            return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
          },
          output: function(xy) {
            return xy && [xy[0][0], xy[1][0]];
          }
        };
        var Y = {
          name: "y",
          handles: ["n", "s"].map(type),
          input: function(y, e) {
            return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
          },
          output: function(xy) {
            return xy && [xy[0][1], xy[1][1]];
          }
        };
        var XY = {
          name: "xy",
          handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
          input: function(xy) {
            return xy == null ? null : number2(xy);
          },
          output: function(xy) {
            return xy;
          }
        };
        var cursors = {
          overlay: "crosshair",
          selection: "move",
          n: "ns-resize",
          e: "ew-resize",
          s: "ns-resize",
          w: "ew-resize",
          nw: "nwse-resize",
          ne: "nesw-resize",
          se: "nwse-resize",
          sw: "nesw-resize"
        };
        var flipX = {
          e: "w",
          w: "e",
          nw: "ne",
          ne: "nw",
          se: "sw",
          sw: "se"
        };
        var flipY = {
          n: "s",
          s: "n",
          nw: "sw",
          ne: "se",
          se: "ne",
          sw: "nw"
        };
        var signsX = {
          overlay: 1,
          selection: 1,
          n: null,
          e: 1,
          s: null,
          w: -1,
          nw: -1,
          ne: 1,
          se: 1,
          sw: -1
        };
        var signsY = {
          overlay: 1,
          selection: 1,
          n: -1,
          e: null,
          s: 1,
          w: null,
          nw: -1,
          ne: -1,
          se: 1,
          sw: 1
        };
        function type(t) {
          return { type: t };
        }
        function defaultFilter() {
          return !d3Selection.event.ctrlKey && !d3Selection.event.button;
        }
        function defaultExtent() {
          var svg = this.ownerSVGElement || this;
          if (svg.hasAttribute("viewBox")) {
            svg = svg.viewBox.baseVal;
            return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
          }
          return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
        }
        function defaultTouchable() {
          return navigator.maxTouchPoints || "ontouchstart" in this;
        }
        function local(node) {
          while (!node.__brush)
            if (!(node = node.parentNode))
              return;
          return node.__brush;
        }
        function empty2(extent) {
          return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
        }
        function brushSelection(node) {
          var state = node.__brush;
          return state ? state.dim.output(state.selection) : null;
        }
        function brushX() {
          return brush$1(X);
        }
        function brushY() {
          return brush$1(Y);
        }
        function brush() {
          return brush$1(XY);
        }
        function brush$1(dim) {
          var extent = defaultExtent, filter2 = defaultFilter, touchable = defaultTouchable, keys = true, listeners = d3Dispatch.dispatch("start", "brush", "end"), handleSize = 6, touchending;
          function brush2(group) {
            var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
            overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
              var extent2 = local(this).extent;
              d3Selection.select(this).attr("x", extent2[0][0]).attr("y", extent2[0][1]).attr("width", extent2[1][0] - extent2[0][0]).attr("height", extent2[1][1] - extent2[0][1]);
            });
            group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
            var handle = group.selectAll(".handle").data(dim.handles, function(d) {
              return d.type;
            });
            handle.exit().remove();
            handle.enter().append("rect").attr("class", function(d) {
              return "handle handle--" + d.type;
            }).attr("cursor", function(d) {
              return cursors[d.type];
            });
            group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
          }
          brush2.move = function(group, selection2) {
            if (group.selection) {
              group.on("start.brush", function() {
                emitter(this, arguments).beforestart().start();
              }).on("interrupt.brush end.brush", function() {
                emitter(this, arguments).end();
              }).tween("brush", function() {
                var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = d3Interpolate.interpolate(selection0, selection1);
                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }
                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
            } else {
              group.each(function() {
                var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
                d3Transition.interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start().brush().end();
              });
            }
          };
          brush2.clear = function(group) {
            brush2.move(group, null);
          };
          function redraw() {
            var group = d3Selection.select(this), selection2 = local(this).selection;
            if (selection2) {
              group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
              group.selectAll(".handle").style("display", null).attr("x", function(d) {
                return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
              }).attr("y", function(d) {
                return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
              }).attr("width", function(d) {
                return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
              }).attr("height", function(d) {
                return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
              });
            } else {
              group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
            }
          }
          function emitter(that, args, clean) {
            var emit = that.__brush.emitter;
            return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
          }
          function Emitter(that, args, clean) {
            this.that = that;
            this.args = args;
            this.state = that.__brush;
            this.active = 0;
            this.clean = clean;
          }
          Emitter.prototype = {
            beforestart: function() {
              if (++this.active === 1)
                this.state.emitter = this, this.starting = true;
              return this;
            },
            start: function() {
              if (this.starting)
                this.starting = false, this.emit("start");
              else
                this.emit("brush");
              return this;
            },
            brush: function() {
              this.emit("brush");
              return this;
            },
            end: function() {
              if (--this.active === 0)
                delete this.state.emitter, this.emit("end");
              return this;
            },
            emit: function(type2) {
              d3Selection.customEvent(new BrushEvent(brush2, type2, dim.output(this.state.selection)), listeners.apply, listeners, [type2, this.that, this.args]);
            }
          };
          function started() {
            if (touchending && !d3Selection.event.touches)
              return;
            if (!filter2.apply(this, arguments))
              return;
            var that = this, type2 = d3Selection.event.target.__data__.type, mode = (keys && d3Selection.event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent2 = state.extent, selection2 = state.selection, W = extent2[0][0], w0, w1, N = extent2[0][1], n0, n1, E = extent2[1][0], e0, e1, S = extent2[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && d3Selection.event.shiftKey, lockX, lockY, pointer = d3Selection.event.touches ? toucher(d3Selection.event.changedTouches[0].identifier) : d3Selection.mouse, point0 = pointer(that), point = point0, emit = emitter(that, arguments, true).beforestart();
            if (type2 === "overlay") {
              if (selection2)
                moving = true;
              state.selection = selection2 = [
                [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
                [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
              ];
            } else {
              w0 = selection2[0][0];
              n0 = selection2[0][1];
              e0 = selection2[1][0];
              s0 = selection2[1][1];
            }
            w1 = w0;
            n1 = n0;
            e1 = e0;
            s1 = s0;
            var group = d3Selection.select(that).attr("pointer-events", "none");
            var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
            if (d3Selection.event.touches) {
              emit.moved = moved;
              emit.ended = ended;
            } else {
              var view = d3Selection.select(d3Selection.event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
              if (keys)
                view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
              d3Drag.dragDisable(d3Selection.event.view);
            }
            nopropagation();
            d3Transition.interrupt(that);
            redraw.call(that);
            emit.start();
            function moved() {
              var point1 = pointer(that);
              if (shifting && !lockX && !lockY) {
                if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1]))
                  lockY = true;
                else
                  lockX = true;
              }
              point = point1;
              moving = true;
              noevent();
              move();
            }
            function move() {
              var t;
              dx = point[0] - point0[0];
              dy = point[1] - point0[1];
              switch (mode) {
                case MODE_SPACE:
                case MODE_DRAG: {
                  if (signX)
                    dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                  if (signY)
                    dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                  break;
                }
                case MODE_HANDLE: {
                  if (signX < 0)
                    dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                  else if (signX > 0)
                    dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                  if (signY < 0)
                    dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                  else if (signY > 0)
                    dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                  break;
                }
                case MODE_CENTER: {
                  if (signX)
                    w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                  if (signY)
                    n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                  break;
                }
              }
              if (e1 < w1) {
                signX *= -1;
                t = w0, w0 = e0, e0 = t;
                t = w1, w1 = e1, e1 = t;
                if (type2 in flipX)
                  overlay.attr("cursor", cursors[type2 = flipX[type2]]);
              }
              if (s1 < n1) {
                signY *= -1;
                t = n0, n0 = s0, s0 = t;
                t = n1, n1 = s1, s1 = t;
                if (type2 in flipY)
                  overlay.attr("cursor", cursors[type2 = flipY[type2]]);
              }
              if (state.selection)
                selection2 = state.selection;
              if (lockX)
                w1 = selection2[0][0], e1 = selection2[1][0];
              if (lockY)
                n1 = selection2[0][1], s1 = selection2[1][1];
              if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
                state.selection = [[w1, n1], [e1, s1]];
                redraw.call(that);
                emit.brush();
              }
            }
            function ended() {
              nopropagation();
              if (d3Selection.event.touches) {
                if (d3Selection.event.touches.length)
                  return;
                if (touchending)
                  clearTimeout(touchending);
                touchending = setTimeout(function() {
                  touchending = null;
                }, 500);
              } else {
                d3Drag.dragEnable(d3Selection.event.view, moving);
                view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
              }
              group.attr("pointer-events", "all");
              overlay.attr("cursor", cursors.overlay);
              if (state.selection)
                selection2 = state.selection;
              if (empty2(selection2))
                state.selection = null, redraw.call(that);
              emit.end();
            }
            function keydowned() {
              switch (d3Selection.event.keyCode) {
                case 16: {
                  shifting = signX && signY;
                  break;
                }
                case 18: {
                  if (mode === MODE_HANDLE) {
                    if (signX)
                      e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                    if (signY)
                      s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                    mode = MODE_CENTER;
                    move();
                  }
                  break;
                }
                case 32: {
                  if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                    if (signX < 0)
                      e0 = e1 - dx;
                    else if (signX > 0)
                      w0 = w1 - dx;
                    if (signY < 0)
                      s0 = s1 - dy;
                    else if (signY > 0)
                      n0 = n1 - dy;
                    mode = MODE_SPACE;
                    overlay.attr("cursor", cursors.selection);
                    move();
                  }
                  break;
                }
                default:
                  return;
              }
              noevent();
            }
            function keyupped() {
              switch (d3Selection.event.keyCode) {
                case 16: {
                  if (shifting) {
                    lockX = lockY = shifting = false;
                    move();
                  }
                  break;
                }
                case 18: {
                  if (mode === MODE_CENTER) {
                    if (signX < 0)
                      e0 = e1;
                    else if (signX > 0)
                      w0 = w1;
                    if (signY < 0)
                      s0 = s1;
                    else if (signY > 0)
                      n0 = n1;
                    mode = MODE_HANDLE;
                    move();
                  }
                  break;
                }
                case 32: {
                  if (mode === MODE_SPACE) {
                    if (d3Selection.event.altKey) {
                      if (signX)
                        e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                      if (signY)
                        s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                      mode = MODE_CENTER;
                    } else {
                      if (signX < 0)
                        e0 = e1;
                      else if (signX > 0)
                        w0 = w1;
                      if (signY < 0)
                        s0 = s1;
                      else if (signY > 0)
                        n0 = n1;
                      mode = MODE_HANDLE;
                    }
                    overlay.attr("cursor", cursors[type2]);
                    move();
                  }
                  break;
                }
                default:
                  return;
              }
              noevent();
            }
          }
          function touchmoved() {
            emitter(this, arguments).moved();
          }
          function touchended() {
            emitter(this, arguments).ended();
          }
          function initialize() {
            var state = this.__brush || { selection: null };
            state.extent = number2(extent.apply(this, arguments));
            state.dim = dim;
            return state;
          }
          brush2.extent = function(_) {
            return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush2) : extent;
          };
          brush2.filter = function(_) {
            return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), brush2) : filter2;
          };
          brush2.touchable = function(_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush2) : touchable;
          };
          brush2.handleSize = function(_) {
            return arguments.length ? (handleSize = +_, brush2) : handleSize;
          };
          brush2.keyModifiers = function(_) {
            return arguments.length ? (keys = !!_, brush2) : keys;
          };
          brush2.on = function() {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? brush2 : value;
          };
          return brush2;
        }
        exports2.brush = brush;
        exports2.brushSelection = brushSelection;
        exports2.brushX = brushX;
        exports2.brushY = brushY;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-path/dist/d3-path.js
  var require_d3_path = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-path/dist/d3-path.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
        function Path() {
          this._x0 = this._y0 = this._x1 = this._y1 = null;
          this._ = "";
        }
        function path() {
          return new Path();
        }
        Path.prototype = path.prototype = {
          constructor: Path,
          moveTo: function(x, y) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
          },
          closePath: function() {
            if (this._x1 !== null) {
              this._x1 = this._x0, this._y1 = this._y0;
              this._ += "Z";
            }
          },
          lineTo: function(x, y) {
            this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          quadraticCurveTo: function(x1, y1, x, y) {
            this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          bezierCurveTo: function(x1, y1, x2, y2, x, y) {
            this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          arcTo: function(x1, y1, x2, y2, r) {
            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
            if (r < 0)
              throw new Error("negative radius: " + r);
            if (this._x1 === null) {
              this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
            } else if (!(l01_2 > epsilon))
              ;
            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
              this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            } else {
              var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
              if (Math.abs(t01 - 1) > epsilon) {
                this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
              }
              this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
          },
          arc: function(x, y, r, a0, a1, ccw) {
            x = +x, y = +y, r = +r, ccw = !!ccw;
            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
            if (r < 0)
              throw new Error("negative radius: " + r);
            if (this._x1 === null) {
              this._ += "M" + x0 + "," + y0;
            } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
              this._ += "L" + x0 + "," + y0;
            }
            if (!r)
              return;
            if (da < 0)
              da = da % tau + tau;
            if (da > tauEpsilon) {
              this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
            } else if (da > epsilon) {
              this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
            }
          },
          rect: function(x, y, w, h) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
          },
          toString: function() {
            return this._;
          }
        };
        exports2.path = path;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-chord/dist/d3-chord.js
  var require_d3_chord = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-chord/dist/d3-chord.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_array(), require_d3_path()) : typeof define === "function" && define.amd ? define(["exports", "d3-array", "d3-path"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3);
      })(exports, function(exports2, d3Array, d3Path) {
        "use strict";
        var cos = Math.cos;
        var sin = Math.sin;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var tau = pi * 2;
        var max = Math.max;
        function compareValue(compare) {
          return function(a, b) {
            return compare(
              a.source.value + a.target.value,
              b.source.value + b.target.value
            );
          };
        }
        function chord() {
          var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
          function chord2(matrix) {
            var n = matrix.length, groupSums = [], groupIndex = d3Array.range(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k, x, x0, dx, i, j;
            k = 0, i = -1;
            while (++i < n) {
              x = 0, j = -1;
              while (++j < n) {
                x += matrix[i][j];
              }
              groupSums.push(x);
              subgroupIndex.push(d3Array.range(n));
              k += x;
            }
            if (sortGroups)
              groupIndex.sort(function(a, b) {
                return sortGroups(groupSums[a], groupSums[b]);
              });
            if (sortSubgroups)
              subgroupIndex.forEach(function(d, i2) {
                d.sort(function(a, b) {
                  return sortSubgroups(matrix[i2][a], matrix[i2][b]);
                });
              });
            k = max(0, tau - padAngle * n) / k;
            dx = k ? padAngle : tau / n;
            x = 0, i = -1;
            while (++i < n) {
              x0 = x, j = -1;
              while (++j < n) {
                var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                subgroups[dj * n + di] = {
                  index: di,
                  subindex: dj,
                  startAngle: a0,
                  endAngle: a1,
                  value: v
                };
              }
              groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x,
                value: groupSums[di]
              };
              x += dx;
            }
            i = -1;
            while (++i < n) {
              j = i - 1;
              while (++j < n) {
                var source = subgroups[j * n + i], target = subgroups[i * n + j];
                if (source.value || target.value) {
                  chords.push(source.value < target.value ? { source: target, target: source } : { source, target });
                }
              }
            }
            return sortChords ? chords.sort(sortChords) : chords;
          }
          chord2.padAngle = function(_) {
            return arguments.length ? (padAngle = max(0, _), chord2) : padAngle;
          };
          chord2.sortGroups = function(_) {
            return arguments.length ? (sortGroups = _, chord2) : sortGroups;
          };
          chord2.sortSubgroups = function(_) {
            return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;
          };
          chord2.sortChords = function(_) {
            return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;
          };
          return chord2;
        }
        var slice = Array.prototype.slice;
        function constant(x) {
          return function() {
            return x;
          };
        }
        function defaultSource(d) {
          return d.source;
        }
        function defaultTarget(d) {
          return d.target;
        }
        function defaultRadius(d) {
          return d.radius;
        }
        function defaultStartAngle(d) {
          return d.startAngle;
        }
        function defaultEndAngle(d) {
          return d.endAngle;
        }
        function ribbon() {
          var source = defaultSource, target = defaultTarget, radius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null;
          function ribbon2() {
            var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s, argv)), sa0 = startAngle.apply(this, argv) - halfPi, sa1 = endAngle.apply(this, argv) - halfPi, sx0 = sr * cos(sa0), sy0 = sr * sin(sa0), tr = +radius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi, ta1 = endAngle.apply(this, argv) - halfPi;
            if (!context)
              context = buffer = d3Path.path();
            context.moveTo(sx0, sy0);
            context.arc(0, 0, sr, sa0, sa1);
            if (sa0 !== ta0 || sa1 !== ta1) {
              context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
              context.arc(0, 0, tr, ta0, ta1);
            }
            context.quadraticCurveTo(0, 0, sx0, sy0);
            context.closePath();
            if (buffer)
              return context = null, buffer + "" || null;
          }
          ribbon2.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon2) : radius;
          };
          ribbon2.startAngle = function(_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon2) : startAngle;
          };
          ribbon2.endAngle = function(_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon2) : endAngle;
          };
          ribbon2.source = function(_) {
            return arguments.length ? (source = _, ribbon2) : source;
          };
          ribbon2.target = function(_) {
            return arguments.length ? (target = _, ribbon2) : target;
          };
          ribbon2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;
          };
          return ribbon2;
        }
        exports2.chord = chord;
        exports2.ribbon = ribbon;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-collection/dist/d3-collection.js
  var require_d3_collection = __commonJS({
    "node_modules/d3-collection/dist/d3-collection.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        var prefix = "$";
        function Map2() {
        }
        Map2.prototype = map.prototype = {
          constructor: Map2,
          has: function(key) {
            return prefix + key in this;
          },
          get: function(key) {
            return this[prefix + key];
          },
          set: function(key, value) {
            this[prefix + key] = value;
            return this;
          },
          remove: function(key) {
            var property = prefix + key;
            return property in this && delete this[property];
          },
          clear: function() {
            for (var property in this)
              if (property[0] === prefix)
                delete this[property];
          },
          keys: function() {
            var keys2 = [];
            for (var property in this)
              if (property[0] === prefix)
                keys2.push(property.slice(1));
            return keys2;
          },
          values: function() {
            var values2 = [];
            for (var property in this)
              if (property[0] === prefix)
                values2.push(this[property]);
            return values2;
          },
          entries: function() {
            var entries2 = [];
            for (var property in this)
              if (property[0] === prefix)
                entries2.push({ key: property.slice(1), value: this[property] });
            return entries2;
          },
          size: function() {
            var size = 0;
            for (var property in this)
              if (property[0] === prefix)
                ++size;
            return size;
          },
          empty: function() {
            for (var property in this)
              if (property[0] === prefix)
                return false;
            return true;
          },
          each: function(f) {
            for (var property in this)
              if (property[0] === prefix)
                f(this[property], property.slice(1), this);
          }
        };
        function map(object, f) {
          var map2 = new Map2();
          if (object instanceof Map2)
            object.each(function(value, key2) {
              map2.set(key2, value);
            });
          else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (f == null)
              while (++i < n)
                map2.set(i, object[i]);
            else
              while (++i < n)
                map2.set(f(o = object[i], i, object), o);
          } else if (object)
            for (var key in object)
              map2.set(key, object[key]);
          return map2;
        }
        function nest() {
          var keys2 = [], sortKeys = [], sortValues, rollup, nest2;
          function apply(array2, depth, createResult, setResult) {
            if (depth >= keys2.length) {
              if (sortValues != null)
                array2.sort(sortValues);
              return rollup != null ? rollup(array2) : array2;
            }
            var i = -1, n = array2.length, key = keys2[depth++], keyValue, value, valuesByKey = map(), values2, result = createResult();
            while (++i < n) {
              if (values2 = valuesByKey.get(keyValue = key(value = array2[i]) + "")) {
                values2.push(value);
              } else {
                valuesByKey.set(keyValue, [value]);
              }
            }
            valuesByKey.each(function(values3, key2) {
              setResult(result, key2, apply(values3, depth, createResult, setResult));
            });
            return result;
          }
          function entries2(map$$1, depth) {
            if (++depth > keys2.length)
              return map$$1;
            var array2, sortKey = sortKeys[depth - 1];
            if (rollup != null && depth >= keys2.length)
              array2 = map$$1.entries();
            else
              array2 = [], map$$1.each(function(v, k) {
                array2.push({ key: k, values: entries2(v, depth) });
              });
            return sortKey != null ? array2.sort(function(a, b) {
              return sortKey(a.key, b.key);
            }) : array2;
          }
          return nest2 = {
            object: function(array2) {
              return apply(array2, 0, createObject, setObject);
            },
            map: function(array2) {
              return apply(array2, 0, createMap, setMap);
            },
            entries: function(array2) {
              return entries2(apply(array2, 0, createMap, setMap), 0);
            },
            key: function(d) {
              keys2.push(d);
              return nest2;
            },
            sortKeys: function(order) {
              sortKeys[keys2.length - 1] = order;
              return nest2;
            },
            sortValues: function(order) {
              sortValues = order;
              return nest2;
            },
            rollup: function(f) {
              rollup = f;
              return nest2;
            }
          };
        }
        function createObject() {
          return {};
        }
        function setObject(object, key, value) {
          object[key] = value;
        }
        function createMap() {
          return map();
        }
        function setMap(map$$1, key, value) {
          map$$1.set(key, value);
        }
        function Set2() {
        }
        var proto = map.prototype;
        Set2.prototype = set.prototype = {
          constructor: Set2,
          has: proto.has,
          add: function(value) {
            value += "";
            this[prefix + value] = value;
            return this;
          },
          remove: proto.remove,
          clear: proto.clear,
          values: proto.keys,
          size: proto.size,
          empty: proto.empty,
          each: proto.each
        };
        function set(object, f) {
          var set2 = new Set2();
          if (object instanceof Set2)
            object.each(function(value) {
              set2.add(value);
            });
          else if (object) {
            var i = -1, n = object.length;
            if (f == null)
              while (++i < n)
                set2.add(object[i]);
            else
              while (++i < n)
                set2.add(f(object[i], i, object));
          }
          return set2;
        }
        function keys(map2) {
          var keys2 = [];
          for (var key in map2)
            keys2.push(key);
          return keys2;
        }
        function values(map2) {
          var values2 = [];
          for (var key in map2)
            values2.push(map2[key]);
          return values2;
        }
        function entries(map2) {
          var entries2 = [];
          for (var key in map2)
            entries2.push({ key, value: map2[key] });
          return entries2;
        }
        exports2.nest = nest;
        exports2.set = set;
        exports2.map = map;
        exports2.keys = keys;
        exports2.values = values;
        exports2.entries = entries;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-contour/dist/d3-contour.js
  var require_d3_contour = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-contour/dist/d3-contour.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_array()) : typeof define === "function" && define.amd ? define(["exports", "d3-array"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3);
      })(exports, function(exports2, d3Array) {
        "use strict";
        var array2 = Array.prototype;
        var slice = array2.slice;
        function ascending2(a, b) {
          return a - b;
        }
        function area(ring) {
          var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
          while (++i < n)
            area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
          return area2;
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function contains(ring, hole) {
          var i = -1, n = hole.length, c;
          while (++i < n)
            if (c = ringContains(ring, hole[i]))
              return c;
          return 0;
        }
        function ringContains(ring, point) {
          var x = point[0], y = point[1], contains2 = -1;
          for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
            var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
            if (segmentContains(pi, pj, point))
              return 0;
            if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi)
              contains2 = -contains2;
          }
          return contains2;
        }
        function segmentContains(a, b, c) {
          var i;
          return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
        }
        function collinear(a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
        }
        function within(p, q, r) {
          return p <= q && q <= r || r <= q && q <= p;
        }
        function noop() {
        }
        var cases = [
          [],
          [[[1, 1.5], [0.5, 1]]],
          [[[1.5, 1], [1, 1.5]]],
          [[[1.5, 1], [0.5, 1]]],
          [[[1, 0.5], [1.5, 1]]],
          [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
          [[[1, 0.5], [1, 1.5]]],
          [[[1, 0.5], [0.5, 1]]],
          [[[0.5, 1], [1, 0.5]]],
          [[[1, 1.5], [1, 0.5]]],
          [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
          [[[1.5, 1], [1, 0.5]]],
          [[[0.5, 1], [1.5, 1]]],
          [[[1, 1.5], [1.5, 1]]],
          [[[0.5, 1], [1, 1.5]]],
          []
        ];
        function contours() {
          var dx = 1, dy = 1, threshold = d3Array.thresholdSturges, smooth = smoothLinear;
          function contours2(values) {
            var tz = threshold(values);
            if (!Array.isArray(tz)) {
              var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
              tz = d3Array.tickStep(start, stop, tz);
              tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
            } else {
              tz = tz.slice().sort(ascending2);
            }
            return tz.map(function(value) {
              return contour(values, value);
            });
          }
          function contour(values, value) {
            var polygons = [], holes = [];
            isorings(values, value, function(ring) {
              smooth(ring, values, value);
              if (area(ring) > 0)
                polygons.push([ring]);
              else
                holes.push(ring);
            });
            holes.forEach(function(hole) {
              for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
                if (contains((polygon = polygons[i])[0], hole) !== -1) {
                  polygon.push(hole);
                  return;
                }
              }
            });
            return {
              type: "MultiPolygon",
              value,
              coordinates: polygons
            };
          }
          function isorings(values, value, callback) {
            var fragmentByStart = new Array(), fragmentByEnd = new Array(), x, y, t0, t1, t2, t3;
            x = y = -1;
            t1 = values[0] >= value;
            cases[t1 << 1].forEach(stitch);
            while (++x < dx - 1) {
              t0 = t1, t1 = values[x + 1] >= value;
              cases[t0 | t1 << 1].forEach(stitch);
            }
            cases[t1 << 0].forEach(stitch);
            while (++y < dy - 1) {
              x = -1;
              t1 = values[y * dx + dx] >= value;
              t2 = values[y * dx] >= value;
              cases[t1 << 1 | t2 << 2].forEach(stitch);
              while (++x < dx - 1) {
                t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
                t3 = t2, t2 = values[y * dx + x + 1] >= value;
                cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
              }
              cases[t1 | t2 << 3].forEach(stitch);
            }
            x = -1;
            t2 = values[y * dx] >= value;
            cases[t2 << 2].forEach(stitch);
            while (++x < dx - 1) {
              t3 = t2, t2 = values[y * dx + x + 1] >= value;
              cases[t2 << 2 | t3 << 3].forEach(stitch);
            }
            cases[t2 << 3].forEach(stitch);
            function stitch(line) {
              var start = [line[0][0] + x, line[0][1] + y], end = [line[1][0] + x, line[1][1] + y], startIndex = index(start), endIndex = index(end), f, g;
              if (f = fragmentByEnd[startIndex]) {
                if (g = fragmentByStart[endIndex]) {
                  delete fragmentByEnd[f.end];
                  delete fragmentByStart[g.start];
                  if (f === g) {
                    f.ring.push(end);
                    callback(f.ring);
                  } else {
                    fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
                  }
                } else {
                  delete fragmentByEnd[f.end];
                  f.ring.push(end);
                  fragmentByEnd[f.end = endIndex] = f;
                }
              } else if (f = fragmentByStart[endIndex]) {
                if (g = fragmentByEnd[startIndex]) {
                  delete fragmentByStart[f.start];
                  delete fragmentByEnd[g.end];
                  if (f === g) {
                    f.ring.push(end);
                    callback(f.ring);
                  } else {
                    fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
                  }
                } else {
                  delete fragmentByStart[f.start];
                  f.ring.unshift(start);
                  fragmentByStart[f.start = startIndex] = f;
                }
              } else {
                fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start, end] };
              }
            }
          }
          function index(point) {
            return point[0] * 2 + point[1] * (dx + 1) * 4;
          }
          function smoothLinear(ring, values, value) {
            ring.forEach(function(point) {
              var x = point[0], y = point[1], xt = x | 0, yt = y | 0, v0, v1 = values[yt * dx + xt];
              if (x > 0 && x < dx && xt === x) {
                v0 = values[yt * dx + xt - 1];
                point[0] = x + (value - v0) / (v1 - v0) - 0.5;
              }
              if (y > 0 && y < dy && yt === y) {
                v0 = values[(yt - 1) * dx + xt];
                point[1] = y + (value - v0) / (v1 - v0) - 0.5;
              }
            });
          }
          contours2.contour = contour;
          contours2.size = function(_) {
            if (!arguments.length)
              return [dx, dy];
            var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
            if (!(_0 > 0) || !(_1 > 0))
              throw new Error("invalid size");
            return dx = _0, dy = _1, contours2;
          };
          contours2.thresholds = function(_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours2) : threshold;
          };
          contours2.smooth = function(_) {
            return arguments.length ? (smooth = _ ? smoothLinear : noop, contours2) : smooth === smoothLinear;
          };
          return contours2;
        }
        function blurX(source, target, r) {
          var n = source.width, m = source.height, w = (r << 1) + 1;
          for (var j = 0; j < m; ++j) {
            for (var i = 0, sr = 0; i < n + r; ++i) {
              if (i < n) {
                sr += source.data[i + j * n];
              }
              if (i >= r) {
                if (i >= w) {
                  sr -= source.data[i - w + j * n];
                }
                target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
              }
            }
          }
        }
        function blurY(source, target, r) {
          var n = source.width, m = source.height, w = (r << 1) + 1;
          for (var i = 0; i < n; ++i) {
            for (var j = 0, sr = 0; j < m + r; ++j) {
              if (j < m) {
                sr += source.data[i + j * n];
              }
              if (j >= r) {
                if (j >= w) {
                  sr -= source.data[i + (j - w) * n];
                }
                target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
              }
            }
          }
        }
        function defaultX(d) {
          return d[0];
        }
        function defaultY(d) {
          return d[1];
        }
        function defaultWeight() {
          return 1;
        }
        function density() {
          var x = defaultX, y = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k = 2, o = r * 3, n = dx + o * 2 >> k, m = dy + o * 2 >> k, threshold = constant(20);
          function density2(data) {
            var values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
            data.forEach(function(d, i, data2) {
              var xi = +x(d, i, data2) + o >> k, yi = +y(d, i, data2) + o >> k, wi = +weight(d, i, data2);
              if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
                values0[xi + yi * n] += wi;
              }
            });
            blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
            blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);
            blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
            blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);
            blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
            blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);
            var tz = threshold(values0);
            if (!Array.isArray(tz)) {
              var stop = d3Array.max(values0);
              tz = d3Array.tickStep(0, stop, tz);
              tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
              tz.shift();
            }
            return contours().thresholds(tz).size([n, m])(values0).map(transform);
          }
          function transform(geometry) {
            geometry.value *= Math.pow(2, -2 * k);
            geometry.coordinates.forEach(transformPolygon);
            return geometry;
          }
          function transformPolygon(coordinates) {
            coordinates.forEach(transformRing);
          }
          function transformRing(coordinates) {
            coordinates.forEach(transformPoint);
          }
          function transformPoint(coordinates) {
            coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
            coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
          }
          function resize() {
            o = r * 3;
            n = dx + o * 2 >> k;
            m = dy + o * 2 >> k;
            return density2;
          }
          density2.x = function(_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density2) : x;
          };
          density2.y = function(_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density2) : y;
          };
          density2.weight = function(_) {
            return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density2) : weight;
          };
          density2.size = function(_) {
            if (!arguments.length)
              return [dx, dy];
            var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
            if (!(_0 >= 0) && !(_0 >= 0))
              throw new Error("invalid size");
            return dx = _0, dy = _1, resize();
          };
          density2.cellSize = function(_) {
            if (!arguments.length)
              return 1 << k;
            if (!((_ = +_) >= 1))
              throw new Error("invalid cell size");
            return k = Math.floor(Math.log(_) / Math.LN2), resize();
          };
          density2.thresholds = function(_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density2) : threshold;
          };
          density2.bandwidth = function(_) {
            if (!arguments.length)
              return Math.sqrt(r * (r + 1));
            if (!((_ = +_) >= 0))
              throw new Error("invalid bandwidth");
            return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
          };
          return density2;
        }
        exports2.contours = contours;
        exports2.contourDensity = density;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-dsv/dist/d3-dsv.js
  var require_d3_dsv = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-dsv/dist/d3-dsv.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
        function objectConverter(columns) {
          return new Function("d", "return {" + columns.map(function(name, i) {
            return JSON.stringify(name) + ": d[" + i + '] || ""';
          }).join(",") + "}");
        }
        function customConverter(columns, f) {
          var object = objectConverter(columns);
          return function(row, i) {
            return f(object(row), i, columns);
          };
        }
        function inferColumns(rows) {
          var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
          rows.forEach(function(row) {
            for (var column in row) {
              if (!(column in columnSet)) {
                columns.push(columnSet[column] = column);
              }
            }
          });
          return columns;
        }
        function pad(value, width) {
          var s = value + "", length = s.length;
          return length < width ? new Array(width - length + 1).join(0) + s : s;
        }
        function formatYear(year) {
          return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
        }
        function formatDate(date) {
          var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
          return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
        }
        function dsv(delimiter) {
          var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
          function parse2(text, f) {
            var convert, columns, rows = parseRows(text, function(row, i) {
              if (convert)
                return convert(row, i - 1);
              columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
            });
            rows.columns = columns || [];
            return rows;
          }
          function parseRows(text, f) {
            var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
            if (text.charCodeAt(N - 1) === NEWLINE)
              --N;
            if (text.charCodeAt(N - 1) === RETURN)
              --N;
            function token() {
              if (eof)
                return EOF;
              if (eol)
                return eol = false, EOL;
              var i, j = I, c;
              if (text.charCodeAt(j) === QUOTE) {
                while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
                  ;
                if ((i = I) >= N)
                  eof = true;
                else if ((c = text.charCodeAt(I++)) === NEWLINE)
                  eol = true;
                else if (c === RETURN) {
                  eol = true;
                  if (text.charCodeAt(I) === NEWLINE)
                    ++I;
                }
                return text.slice(j + 1, i - 1).replace(/""/g, '"');
              }
              while (I < N) {
                if ((c = text.charCodeAt(i = I++)) === NEWLINE)
                  eol = true;
                else if (c === RETURN) {
                  eol = true;
                  if (text.charCodeAt(I) === NEWLINE)
                    ++I;
                } else if (c !== DELIMITER)
                  continue;
                return text.slice(j, i);
              }
              return eof = true, text.slice(j, N);
            }
            while ((t = token()) !== EOF) {
              var row = [];
              while (t !== EOL && t !== EOF)
                row.push(t), t = token();
              if (f && (row = f(row, n++)) == null)
                continue;
              rows.push(row);
            }
            return rows;
          }
          function preformatBody(rows, columns) {
            return rows.map(function(row) {
              return columns.map(function(column) {
                return formatValue(row[column]);
              }).join(delimiter);
            });
          }
          function format(rows, columns) {
            if (columns == null)
              columns = inferColumns(rows);
            return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
          }
          function formatBody(rows, columns) {
            if (columns == null)
              columns = inferColumns(rows);
            return preformatBody(rows, columns).join("\n");
          }
          function formatRows(rows) {
            return rows.map(formatRow).join("\n");
          }
          function formatRow(row) {
            return row.map(formatValue).join(delimiter);
          }
          function formatValue(value) {
            return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
          }
          return {
            parse: parse2,
            parseRows,
            format,
            formatBody,
            formatRows,
            formatRow,
            formatValue
          };
        }
        var csv = dsv(",");
        var csvParse = csv.parse;
        var csvParseRows = csv.parseRows;
        var csvFormat = csv.format;
        var csvFormatBody = csv.formatBody;
        var csvFormatRows = csv.formatRows;
        var csvFormatRow = csv.formatRow;
        var csvFormatValue = csv.formatValue;
        var tsv = dsv("	");
        var tsvParse = tsv.parse;
        var tsvParseRows = tsv.parseRows;
        var tsvFormat = tsv.format;
        var tsvFormatBody = tsv.formatBody;
        var tsvFormatRows = tsv.formatRows;
        var tsvFormatRow = tsv.formatRow;
        var tsvFormatValue = tsv.formatValue;
        function autoType(object) {
          for (var key in object) {
            var value = object[key].trim(), number, m;
            if (!value)
              value = null;
            else if (value === "true")
              value = true;
            else if (value === "false")
              value = false;
            else if (value === "NaN")
              value = NaN;
            else if (!isNaN(number = +value))
              value = number;
            else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
              if (fixtz && !!m[4] && !m[7])
                value = value.replace(/-/g, "/").replace(/T/, " ");
              value = new Date(value);
            } else
              continue;
            object[key] = value;
          }
          return object;
        }
        var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
        exports2.autoType = autoType;
        exports2.csvFormat = csvFormat;
        exports2.csvFormatBody = csvFormatBody;
        exports2.csvFormatRow = csvFormatRow;
        exports2.csvFormatRows = csvFormatRows;
        exports2.csvFormatValue = csvFormatValue;
        exports2.csvParse = csvParse;
        exports2.csvParseRows = csvParseRows;
        exports2.dsvFormat = dsv;
        exports2.tsvFormat = tsvFormat;
        exports2.tsvFormatBody = tsvFormatBody;
        exports2.tsvFormatRow = tsvFormatRow;
        exports2.tsvFormatRows = tsvFormatRows;
        exports2.tsvFormatValue = tsvFormatValue;
        exports2.tsvParse = tsvParse;
        exports2.tsvParseRows = tsvParseRows;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-fetch/dist/d3-fetch.js
  var require_d3_fetch = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-fetch/dist/d3-fetch.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_dsv()) : typeof define === "function" && define.amd ? define(["exports", "d3-dsv"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Dsv) {
        "use strict";
        function responseBlob(response) {
          if (!response.ok)
            throw new Error(response.status + " " + response.statusText);
          return response.blob();
        }
        function blob(input, init) {
          return fetch(input, init).then(responseBlob);
        }
        function responseArrayBuffer(response) {
          if (!response.ok)
            throw new Error(response.status + " " + response.statusText);
          return response.arrayBuffer();
        }
        function buffer(input, init) {
          return fetch(input, init).then(responseArrayBuffer);
        }
        function responseText(response) {
          if (!response.ok)
            throw new Error(response.status + " " + response.statusText);
          return response.text();
        }
        function text(input, init) {
          return fetch(input, init).then(responseText);
        }
        function dsvParse(parse2) {
          return function(input, init, row) {
            if (arguments.length === 2 && typeof init === "function")
              row = init, init = void 0;
            return text(input, init).then(function(response) {
              return parse2(response, row);
            });
          };
        }
        function dsv(delimiter, input, init, row) {
          if (arguments.length === 3 && typeof init === "function")
            row = init, init = void 0;
          var format = d3Dsv.dsvFormat(delimiter);
          return text(input, init).then(function(response) {
            return format.parse(response, row);
          });
        }
        var csv = dsvParse(d3Dsv.csvParse);
        var tsv = dsvParse(d3Dsv.tsvParse);
        function image(input, init) {
          return new Promise(function(resolve, reject) {
            var image2 = new Image();
            for (var key in init)
              image2[key] = init[key];
            image2.onerror = reject;
            image2.onload = function() {
              resolve(image2);
            };
            image2.src = input;
          });
        }
        function responseJson(response) {
          if (!response.ok)
            throw new Error(response.status + " " + response.statusText);
          if (response.status === 204 || response.status === 205)
            return;
          return response.json();
        }
        function json(input, init) {
          return fetch(input, init).then(responseJson);
        }
        function parser(type) {
          return function(input, init) {
            return text(input, init).then(function(text2) {
              return new DOMParser().parseFromString(text2, type);
            });
          };
        }
        var xml = parser("application/xml");
        var html = parser("text/html");
        var svg = parser("image/svg+xml");
        exports2.blob = blob;
        exports2.buffer = buffer;
        exports2.csv = csv;
        exports2.dsv = dsv;
        exports2.html = html;
        exports2.image = image;
        exports2.json = json;
        exports2.svg = svg;
        exports2.text = text;
        exports2.tsv = tsv;
        exports2.xml = xml;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-quadtree/dist/d3-quadtree.js
  var require_d3_quadtree = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-quadtree/dist/d3-quadtree.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function tree_add(d) {
          var x = +this._x.call(null, d), y = +this._y.call(null, d);
          return add(this.cover(x, y), x, y, d);
        }
        function add(tree, x, y, d) {
          if (isNaN(x) || isNaN(y))
            return tree;
          var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
          if (!node)
            return tree._root = leaf, tree;
          while (node.length) {
            if (right = x >= (xm = (x0 + x1) / 2))
              x0 = xm;
            else
              x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
              y0 = ym;
            else
              y1 = ym;
            if (parent = node, !(node = node[i = bottom << 1 | right]))
              return parent[i] = leaf, tree;
          }
          xp = +tree._x.call(null, node.data);
          yp = +tree._y.call(null, node.data);
          if (x === xp && y === yp)
            return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
          do {
            parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
            if (right = x >= (xm = (x0 + x1) / 2))
              x0 = xm;
            else
              x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
              y0 = ym;
            else
              y1 = ym;
          } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
          return parent[j] = node, parent[i] = leaf, tree;
        }
        function addAll(data) {
          var d, i, n = data.length, x, y, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
          for (i = 0; i < n; ++i) {
            if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)))
              continue;
            xz[i] = x;
            yz[i] = y;
            if (x < x0)
              x0 = x;
            if (x > x1)
              x1 = x;
            if (y < y0)
              y0 = y;
            if (y > y1)
              y1 = y;
          }
          if (x0 > x1 || y0 > y1)
            return this;
          this.cover(x0, y0).cover(x1, y1);
          for (i = 0; i < n; ++i) {
            add(this, xz[i], yz[i], data[i]);
          }
          return this;
        }
        function tree_cover(x, y) {
          if (isNaN(x = +x) || isNaN(y = +y))
            return this;
          var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
          if (isNaN(x0)) {
            x1 = (x0 = Math.floor(x)) + 1;
            y1 = (y0 = Math.floor(y)) + 1;
          } else {
            var z = x1 - x0, node = this._root, parent, i;
            while (x0 > x || x >= x1 || y0 > y || y >= y1) {
              i = (y < y0) << 1 | x < x0;
              parent = new Array(4), parent[i] = node, node = parent, z *= 2;
              switch (i) {
                case 0:
                  x1 = x0 + z, y1 = y0 + z;
                  break;
                case 1:
                  x0 = x1 - z, y1 = y0 + z;
                  break;
                case 2:
                  x1 = x0 + z, y0 = y1 - z;
                  break;
                case 3:
                  x0 = x1 - z, y0 = y1 - z;
                  break;
              }
            }
            if (this._root && this._root.length)
              this._root = node;
          }
          this._x0 = x0;
          this._y0 = y0;
          this._x1 = x1;
          this._y1 = y1;
          return this;
        }
        function tree_data() {
          var data = [];
          this.visit(function(node) {
            if (!node.length)
              do
                data.push(node.data);
              while (node = node.next);
          });
          return data;
        }
        function tree_extent(_) {
          return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
        }
        function Quad(node, x0, y0, x1, y1) {
          this.node = node;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        function tree_find(x, y, radius) {
          var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
          if (node)
            quads.push(new Quad(node, x0, y0, x3, y3));
          if (radius == null)
            radius = Infinity;
          else {
            x0 = x - radius, y0 = y - radius;
            x3 = x + radius, y3 = y + radius;
            radius *= radius;
          }
          while (q = quads.pop()) {
            if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0)
              continue;
            if (node.length) {
              var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2;
              quads.push(
                new Quad(node[3], xm, ym, x2, y2),
                new Quad(node[2], x1, ym, xm, y2),
                new Quad(node[1], xm, y1, x2, ym),
                new Quad(node[0], x1, y1, xm, ym)
              );
              if (i = (y >= ym) << 1 | x >= xm) {
                q = quads[quads.length - 1];
                quads[quads.length - 1] = quads[quads.length - 1 - i];
                quads[quads.length - 1 - i] = q;
              }
            } else {
              var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
              if (d2 < radius) {
                var d = Math.sqrt(radius = d2);
                x0 = x - d, y0 = y - d;
                x3 = x + d, y3 = y + d;
                data = node.data;
              }
            }
          }
          return data;
        }
        function tree_remove(d) {
          if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)))
            return this;
          var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x, y, xm, ym, right, bottom, i, j;
          if (!node)
            return this;
          if (node.length)
            while (true) {
              if (right = x >= (xm = (x0 + x1) / 2))
                x0 = xm;
              else
                x1 = xm;
              if (bottom = y >= (ym = (y0 + y1) / 2))
                y0 = ym;
              else
                y1 = ym;
              if (!(parent = node, node = node[i = bottom << 1 | right]))
                return this;
              if (!node.length)
                break;
              if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
                retainer = parent, j = i;
            }
          while (node.data !== d)
            if (!(previous = node, node = node.next))
              return this;
          if (next = node.next)
            delete node.next;
          if (previous)
            return next ? previous.next = next : delete previous.next, this;
          if (!parent)
            return this._root = next, this;
          next ? parent[i] = next : delete parent[i];
          if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
            if (retainer)
              retainer[j] = node;
            else
              this._root = node;
          }
          return this;
        }
        function removeAll(data) {
          for (var i = 0, n = data.length; i < n; ++i)
            this.remove(data[i]);
          return this;
        }
        function tree_root() {
          return this._root;
        }
        function tree_size() {
          var size = 0;
          this.visit(function(node) {
            if (!node.length)
              do
                ++size;
              while (node = node.next);
          });
          return size;
        }
        function tree_visit(callback) {
          var quads = [], q, node = this._root, child, x0, y0, x1, y1;
          if (node)
            quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
          while (q = quads.pop()) {
            if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
              var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
              if (child = node[3])
                quads.push(new Quad(child, xm, ym, x1, y1));
              if (child = node[2])
                quads.push(new Quad(child, x0, ym, xm, y1));
              if (child = node[1])
                quads.push(new Quad(child, xm, y0, x1, ym));
              if (child = node[0])
                quads.push(new Quad(child, x0, y0, xm, ym));
            }
          }
          return this;
        }
        function tree_visitAfter(callback) {
          var quads = [], next = [], q;
          if (this._root)
            quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
          while (q = quads.pop()) {
            var node = q.node;
            if (node.length) {
              var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
              if (child = node[0])
                quads.push(new Quad(child, x0, y0, xm, ym));
              if (child = node[1])
                quads.push(new Quad(child, xm, y0, x1, ym));
              if (child = node[2])
                quads.push(new Quad(child, x0, ym, xm, y1));
              if (child = node[3])
                quads.push(new Quad(child, xm, ym, x1, y1));
            }
            next.push(q);
          }
          while (q = next.pop()) {
            callback(q.node, q.x0, q.y0, q.x1, q.y1);
          }
          return this;
        }
        function defaultX(d) {
          return d[0];
        }
        function tree_x(_) {
          return arguments.length ? (this._x = _, this) : this._x;
        }
        function defaultY(d) {
          return d[1];
        }
        function tree_y(_) {
          return arguments.length ? (this._y = _, this) : this._y;
        }
        function quadtree(nodes, x, y) {
          var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
          return nodes == null ? tree : tree.addAll(nodes);
        }
        function Quadtree(x, y, x0, y0, x1, y1) {
          this._x = x;
          this._y = y;
          this._x0 = x0;
          this._y0 = y0;
          this._x1 = x1;
          this._y1 = y1;
          this._root = void 0;
        }
        function leaf_copy(leaf) {
          var copy = { data: leaf.data }, next = copy;
          while (leaf = leaf.next)
            next = next.next = { data: leaf.data };
          return copy;
        }
        var treeProto = quadtree.prototype = Quadtree.prototype;
        treeProto.copy = function() {
          var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
          if (!node)
            return copy;
          if (!node.length)
            return copy._root = leaf_copy(node), copy;
          nodes = [{ source: node, target: copy._root = new Array(4) }];
          while (node = nodes.pop()) {
            for (var i = 0; i < 4; ++i) {
              if (child = node.source[i]) {
                if (child.length)
                  nodes.push({ source: child, target: node.target[i] = new Array(4) });
                else
                  node.target[i] = leaf_copy(child);
              }
            }
          }
          return copy;
        };
        treeProto.add = tree_add;
        treeProto.addAll = addAll;
        treeProto.cover = tree_cover;
        treeProto.data = tree_data;
        treeProto.extent = tree_extent;
        treeProto.find = tree_find;
        treeProto.remove = tree_remove;
        treeProto.removeAll = removeAll;
        treeProto.root = tree_root;
        treeProto.size = tree_size;
        treeProto.visit = tree_visit;
        treeProto.visitAfter = tree_visitAfter;
        treeProto.x = tree_x;
        treeProto.y = tree_y;
        exports2.quadtree = quadtree;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-force/dist/d3-force.js
  var require_d3_force = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-force/dist/d3-force.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_quadtree(), require_d3_collection(), require_d3_dispatch(), require_d3_timer()) : typeof define === "function" && define.amd ? define(["exports", "d3-quadtree", "d3-collection", "d3-dispatch", "d3-timer"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3);
      })(exports, function(exports2, d3Quadtree, d3Collection, d3Dispatch, d3Timer) {
        "use strict";
        function center(x2, y2) {
          var nodes;
          if (x2 == null)
            x2 = 0;
          if (y2 == null)
            y2 = 0;
          function force() {
            var i, n = nodes.length, node, sx = 0, sy = 0;
            for (i = 0; i < n; ++i) {
              node = nodes[i], sx += node.x, sy += node.y;
            }
            for (sx = sx / n - x2, sy = sy / n - y2, i = 0; i < n; ++i) {
              node = nodes[i], node.x -= sx, node.y -= sy;
            }
          }
          force.initialize = function(_) {
            nodes = _;
          };
          force.x = function(_) {
            return arguments.length ? (x2 = +_, force) : x2;
          };
          force.y = function(_) {
            return arguments.length ? (y2 = +_, force) : y2;
          };
          return force;
        }
        function constant(x2) {
          return function() {
            return x2;
          };
        }
        function jiggle() {
          return (Math.random() - 0.5) * 1e-6;
        }
        function x(d) {
          return d.x + d.vx;
        }
        function y(d) {
          return d.y + d.vy;
        }
        function collide(radius) {
          var nodes, radii, strength = 1, iterations = 1;
          if (typeof radius !== "function")
            radius = constant(radius == null ? 1 : +radius);
          function force() {
            var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
            for (var k = 0; k < iterations; ++k) {
              tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
              for (i = 0; i < n; ++i) {
                node = nodes[i];
                ri = radii[node.index], ri2 = ri * ri;
                xi = node.x + node.vx;
                yi = node.y + node.vy;
                tree.visit(apply);
              }
            }
            function apply(quad, x0, y0, x1, y1) {
              var data = quad.data, rj = quad.r, r = ri + rj;
              if (data) {
                if (data.index > node.index) {
                  var x2 = xi - data.x - data.vx, y2 = yi - data.y - data.vy, l = x2 * x2 + y2 * y2;
                  if (l < r * r) {
                    if (x2 === 0)
                      x2 = jiggle(), l += x2 * x2;
                    if (y2 === 0)
                      y2 = jiggle(), l += y2 * y2;
                    l = (r - (l = Math.sqrt(l))) / l * strength;
                    node.vx += (x2 *= l) * (r = (rj *= rj) / (ri2 + rj));
                    node.vy += (y2 *= l) * r;
                    data.vx -= x2 * (r = 1 - r);
                    data.vy -= y2 * r;
                  }
                }
                return;
              }
              return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
            }
          }
          function prepare(quad) {
            if (quad.data)
              return quad.r = radii[quad.data.index];
            for (var i = quad.r = 0; i < 4; ++i) {
              if (quad[i] && quad[i].r > quad.r) {
                quad.r = quad[i].r;
              }
            }
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length, node;
            radii = new Array(n);
            for (i = 0; i < n; ++i)
              node = nodes[i], radii[node.index] = +radius(node, i, nodes);
          }
          force.initialize = function(_) {
            nodes = _;
            initialize();
          };
          force.iterations = function(_) {
            return arguments.length ? (iterations = +_, force) : iterations;
          };
          force.strength = function(_) {
            return arguments.length ? (strength = +_, force) : strength;
          };
          force.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
          };
          return force;
        }
        function index(d) {
          return d.index;
        }
        function find2(nodeById, nodeId) {
          var node = nodeById.get(nodeId);
          if (!node)
            throw new Error("missing: " + nodeId);
          return node;
        }
        function link(links) {
          var id = index, strength = defaultStrength, strengths, distance = constant(30), distances, nodes, count, bias, iterations = 1;
          if (links == null)
            links = [];
          function defaultStrength(link2) {
            return 1 / Math.min(count[link2.source.index], count[link2.target.index]);
          }
          function force(alpha) {
            for (var k = 0, n = links.length; k < iterations; ++k) {
              for (var i = 0, link2, source, target, x2, y2, l, b; i < n; ++i) {
                link2 = links[i], source = link2.source, target = link2.target;
                x2 = target.x + target.vx - source.x - source.vx || jiggle();
                y2 = target.y + target.vy - source.y - source.vy || jiggle();
                l = Math.sqrt(x2 * x2 + y2 * y2);
                l = (l - distances[i]) / l * alpha * strengths[i];
                x2 *= l, y2 *= l;
                target.vx -= x2 * (b = bias[i]);
                target.vy -= y2 * b;
                source.vx += x2 * (b = 1 - b);
                source.vy += y2 * b;
              }
            }
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length, m = links.length, nodeById = d3Collection.map(nodes, id), link2;
            for (i = 0, count = new Array(n); i < m; ++i) {
              link2 = links[i], link2.index = i;
              if (typeof link2.source !== "object")
                link2.source = find2(nodeById, link2.source);
              if (typeof link2.target !== "object")
                link2.target = find2(nodeById, link2.target);
              count[link2.source.index] = (count[link2.source.index] || 0) + 1;
              count[link2.target.index] = (count[link2.target.index] || 0) + 1;
            }
            for (i = 0, bias = new Array(m); i < m; ++i) {
              link2 = links[i], bias[i] = count[link2.source.index] / (count[link2.source.index] + count[link2.target.index]);
            }
            strengths = new Array(m), initializeStrength();
            distances = new Array(m), initializeDistance();
          }
          function initializeStrength() {
            if (!nodes)
              return;
            for (var i = 0, n = links.length; i < n; ++i) {
              strengths[i] = +strength(links[i], i, links);
            }
          }
          function initializeDistance() {
            if (!nodes)
              return;
            for (var i = 0, n = links.length; i < n; ++i) {
              distances[i] = +distance(links[i], i, links);
            }
          }
          force.initialize = function(_) {
            nodes = _;
            initialize();
          };
          force.links = function(_) {
            return arguments.length ? (links = _, initialize(), force) : links;
          };
          force.id = function(_) {
            return arguments.length ? (id = _, force) : id;
          };
          force.iterations = function(_) {
            return arguments.length ? (iterations = +_, force) : iterations;
          };
          force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
          };
          force.distance = function(_) {
            return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
          };
          return force;
        }
        function x$1(d) {
          return d.x;
        }
        function y$1(d) {
          return d.y;
        }
        var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
        function simulation(nodes) {
          var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = d3Collection.map(), stepper = d3Timer.timer(step), event = d3Dispatch.dispatch("tick", "end");
          if (nodes == null)
            nodes = [];
          function step() {
            tick();
            event.call("tick", simulation2);
            if (alpha < alphaMin) {
              stepper.stop();
              event.call("end", simulation2);
            }
          }
          function tick(iterations) {
            var i, n = nodes.length, node;
            if (iterations === void 0)
              iterations = 1;
            for (var k = 0; k < iterations; ++k) {
              alpha += (alphaTarget - alpha) * alphaDecay;
              forces.each(function(force) {
                force(alpha);
              });
              for (i = 0; i < n; ++i) {
                node = nodes[i];
                if (node.fx == null)
                  node.x += node.vx *= velocityDecay;
                else
                  node.x = node.fx, node.vx = 0;
                if (node.fy == null)
                  node.y += node.vy *= velocityDecay;
                else
                  node.y = node.fy, node.vy = 0;
              }
            }
            return simulation2;
          }
          function initializeNodes() {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
              node = nodes[i], node.index = i;
              if (node.fx != null)
                node.x = node.fx;
              if (node.fy != null)
                node.y = node.fy;
              if (isNaN(node.x) || isNaN(node.y)) {
                var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
                node.x = radius * Math.cos(angle);
                node.y = radius * Math.sin(angle);
              }
              if (isNaN(node.vx) || isNaN(node.vy)) {
                node.vx = node.vy = 0;
              }
            }
          }
          function initializeForce(force) {
            if (force.initialize)
              force.initialize(nodes);
            return force;
          }
          initializeNodes();
          return simulation2 = {
            tick,
            restart: function() {
              return stepper.restart(step), simulation2;
            },
            stop: function() {
              return stepper.stop(), simulation2;
            },
            nodes: function(_) {
              return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation2) : nodes;
            },
            alpha: function(_) {
              return arguments.length ? (alpha = +_, simulation2) : alpha;
            },
            alphaMin: function(_) {
              return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
            },
            alphaDecay: function(_) {
              return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
            },
            alphaTarget: function(_) {
              return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
            },
            velocityDecay: function(_) {
              return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
            },
            force: function(name, _) {
              return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation2) : forces.get(name);
            },
            find: function(x2, y2, radius) {
              var i = 0, n = nodes.length, dx, dy, d2, node, closest;
              if (radius == null)
                radius = Infinity;
              else
                radius *= radius;
              for (i = 0; i < n; ++i) {
                node = nodes[i];
                dx = x2 - node.x;
                dy = y2 - node.y;
                d2 = dx * dx + dy * dy;
                if (d2 < radius)
                  closest = node, radius = d2;
              }
              return closest;
            },
            on: function(name, _) {
              return arguments.length > 1 ? (event.on(name, _), simulation2) : event.on(name);
            }
          };
        }
        function manyBody() {
          var nodes, node, alpha, strength = constant(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
          function force(_) {
            var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
            for (alpha = _, i = 0; i < n; ++i)
              node = nodes[i], tree.visit(apply);
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length, node2;
            strengths = new Array(n);
            for (i = 0; i < n; ++i)
              node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
          }
          function accumulate(quad) {
            var strength2 = 0, q, c, weight = 0, x2, y2, i;
            if (quad.length) {
              for (x2 = y2 = i = 0; i < 4; ++i) {
                if ((q = quad[i]) && (c = Math.abs(q.value))) {
                  strength2 += q.value, weight += c, x2 += c * q.x, y2 += c * q.y;
                }
              }
              quad.x = x2 / weight;
              quad.y = y2 / weight;
            } else {
              q = quad;
              q.x = q.data.x;
              q.y = q.data.y;
              do
                strength2 += strengths[q.data.index];
              while (q = q.next);
            }
            quad.value = strength2;
          }
          function apply(quad, x1, _, x2) {
            if (!quad.value)
              return true;
            var x3 = quad.x - node.x, y2 = quad.y - node.y, w = x2 - x1, l = x3 * x3 + y2 * y2;
            if (w * w / theta2 < l) {
              if (l < distanceMax2) {
                if (x3 === 0)
                  x3 = jiggle(), l += x3 * x3;
                if (y2 === 0)
                  y2 = jiggle(), l += y2 * y2;
                if (l < distanceMin2)
                  l = Math.sqrt(distanceMin2 * l);
                node.vx += x3 * quad.value * alpha / l;
                node.vy += y2 * quad.value * alpha / l;
              }
              return true;
            } else if (quad.length || l >= distanceMax2)
              return;
            if (quad.data !== node || quad.next) {
              if (x3 === 0)
                x3 = jiggle(), l += x3 * x3;
              if (y2 === 0)
                y2 = jiggle(), l += y2 * y2;
              if (l < distanceMin2)
                l = Math.sqrt(distanceMin2 * l);
            }
            do
              if (quad.data !== node) {
                w = strengths[quad.data.index] * alpha / l;
                node.vx += x3 * w;
                node.vy += y2 * w;
              }
            while (quad = quad.next);
          }
          force.initialize = function(_) {
            nodes = _;
            initialize();
          };
          force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
          };
          force.distanceMin = function(_) {
            return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
          };
          force.distanceMax = function(_) {
            return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
          };
          force.theta = function(_) {
            return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
          };
          return force;
        }
        function radial(radius, x2, y2) {
          var nodes, strength = constant(0.1), strengths, radiuses;
          if (typeof radius !== "function")
            radius = constant(+radius);
          if (x2 == null)
            x2 = 0;
          if (y2 == null)
            y2 = 0;
          function force(alpha) {
            for (var i = 0, n = nodes.length; i < n; ++i) {
              var node = nodes[i], dx = node.x - x2 || 1e-6, dy = node.y - y2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
              node.vx += dx * k;
              node.vy += dy * k;
            }
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length;
            strengths = new Array(n);
            radiuses = new Array(n);
            for (i = 0; i < n; ++i) {
              radiuses[i] = +radius(nodes[i], i, nodes);
              strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
            }
          }
          force.initialize = function(_) {
            nodes = _, initialize();
          };
          force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
          };
          force.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
          };
          force.x = function(_) {
            return arguments.length ? (x2 = +_, force) : x2;
          };
          force.y = function(_) {
            return arguments.length ? (y2 = +_, force) : y2;
          };
          return force;
        }
        function x$2(x2) {
          var strength = constant(0.1), nodes, strengths, xz;
          if (typeof x2 !== "function")
            x2 = constant(x2 == null ? 0 : +x2);
          function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
              node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
            }
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length;
            strengths = new Array(n);
            xz = new Array(n);
            for (i = 0; i < n; ++i) {
              strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
          }
          force.initialize = function(_) {
            nodes = _;
            initialize();
          };
          force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
          };
          force.x = function(_) {
            return arguments.length ? (x2 = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x2;
          };
          return force;
        }
        function y$2(y2) {
          var strength = constant(0.1), nodes, strengths, yz;
          if (typeof y2 !== "function")
            y2 = constant(y2 == null ? 0 : +y2);
          function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
              node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
            }
          }
          function initialize() {
            if (!nodes)
              return;
            var i, n = nodes.length;
            strengths = new Array(n);
            yz = new Array(n);
            for (i = 0; i < n; ++i) {
              strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
          }
          force.initialize = function(_) {
            nodes = _;
            initialize();
          };
          force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
          };
          force.y = function(_) {
            return arguments.length ? (y2 = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y2;
          };
          return force;
        }
        exports2.forceCenter = center;
        exports2.forceCollide = collide;
        exports2.forceLink = link;
        exports2.forceManyBody = manyBody;
        exports2.forceRadial = radial;
        exports2.forceSimulation = simulation;
        exports2.forceX = x$2;
        exports2.forceY = y$2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-format/dist/d3-format.js
  var require_d3_format = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-format/dist/d3-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function formatDecimal(x) {
          return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
        }
        function formatDecimalParts(x, p) {
          if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
            return null;
          var i, coefficient = x.slice(0, i);
          return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
          ];
        }
        function exponent(x) {
          return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
        }
        function formatGroup(grouping, thousands) {
          return function(value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
              if (length + g + 1 > width)
                g = Math.max(1, width - length);
              t.push(value.substring(i -= g, i + g));
              if ((length += g + 1) > width)
                break;
              g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
          };
        }
        function formatNumerals(numerals) {
          return function(value) {
            return value.replace(/[0-9]/g, function(i) {
              return numerals[+i];
            });
          };
        }
        var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function formatSpecifier(specifier) {
          if (!(match = re.exec(specifier)))
            throw new Error("invalid format: " + specifier);
          var match;
          return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
          });
        }
        formatSpecifier.prototype = FormatSpecifier.prototype;
        function FormatSpecifier(specifier) {
          this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
          this.align = specifier.align === void 0 ? ">" : specifier.align + "";
          this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
          this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
          this.zero = !!specifier.zero;
          this.width = specifier.width === void 0 ? void 0 : +specifier.width;
          this.comma = !!specifier.comma;
          this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
          this.trim = !!specifier.trim;
          this.type = specifier.type === void 0 ? "" : specifier.type + "";
        }
        FormatSpecifier.prototype.toString = function() {
          return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
        };
        function formatTrim(s) {
          out:
            for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
              switch (s[i]) {
                case ".":
                  i0 = i1 = i;
                  break;
                case "0":
                  if (i0 === 0)
                    i0 = i;
                  i1 = i;
                  break;
                default:
                  if (!+s[i])
                    break out;
                  if (i0 > 0)
                    i0 = 0;
                  break;
              }
            }
          return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
        }
        var prefixExponent;
        function formatPrefixAuto(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d)
            return x + "";
          var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
          return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
        }
        function formatRounded(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d)
            return x + "";
          var coefficient = d[0], exponent2 = d[1];
          return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
        }
        var formatTypes = {
          "%": function(x, p) {
            return (x * 100).toFixed(p);
          },
          "b": function(x) {
            return Math.round(x).toString(2);
          },
          "c": function(x) {
            return x + "";
          },
          "d": formatDecimal,
          "e": function(x, p) {
            return x.toExponential(p);
          },
          "f": function(x, p) {
            return x.toFixed(p);
          },
          "g": function(x, p) {
            return x.toPrecision(p);
          },
          "o": function(x) {
            return Math.round(x).toString(8);
          },
          "p": function(x, p) {
            return formatRounded(x * 100, p);
          },
          "r": formatRounded,
          "s": formatPrefixAuto,
          "X": function(x) {
            return Math.round(x).toString(16).toUpperCase();
          },
          "x": function(x) {
            return Math.round(x).toString(16);
          }
        };
        function identity(x) {
          return x;
        }
        var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
        function formatLocale(locale2) {
          var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
          function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            if (type === "n")
              comma = true, type = "g";
            else if (!formatTypes[type])
              precision === void 0 && (precision = 12), trim = true, type = "g";
            if (zero || fill === "0" && align === "=")
              zero = true, fill = "0", align = "=";
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
            precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
            function format(value) {
              var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
              if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
              } else {
                value = +value;
                var valueNegative = value < 0 || 1 / value < 0;
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                if (trim)
                  value = formatTrim(value);
                if (valueNegative && +value === 0 && sign !== "+")
                  valueNegative = false;
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                if (maybeSuffix) {
                  i = -1, n = value.length;
                  while (++i < n) {
                    if (c = value.charCodeAt(i), 48 > c || c > 57) {
                      valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                      value = value.slice(0, i);
                      break;
                    }
                  }
                }
              }
              if (comma && !zero)
                value = group(value, Infinity);
              var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
              if (comma && zero)
                value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
              switch (align) {
                case "<":
                  value = valuePrefix + value + valueSuffix + padding;
                  break;
                case "=":
                  value = valuePrefix + padding + value + valueSuffix;
                  break;
                case "^":
                  value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                  break;
                default:
                  value = padding + valuePrefix + value + valueSuffix;
                  break;
              }
              return numerals(value);
            }
            format.toString = function() {
              return specifier + "";
            };
            return format;
          }
          function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
            return function(value2) {
              return f(k * value2) + prefix;
            };
          }
          return {
            format: newFormat,
            formatPrefix
          };
        }
        var locale;
        defaultLocale({
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          minus: "-"
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.format = locale.format;
          exports2.formatPrefix = locale.formatPrefix;
          return locale;
        }
        function precisionFixed(step) {
          return Math.max(0, -exponent(Math.abs(step)));
        }
        function precisionPrefix(step, value) {
          return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
        }
        function precisionRound(step, max) {
          step = Math.abs(step), max = Math.abs(max) - step;
          return Math.max(0, exponent(max) - exponent(step)) + 1;
        }
        exports2.FormatSpecifier = FormatSpecifier;
        exports2.formatDefaultLocale = defaultLocale;
        exports2.formatLocale = formatLocale;
        exports2.formatSpecifier = formatSpecifier;
        exports2.precisionFixed = precisionFixed;
        exports2.precisionPrefix = precisionPrefix;
        exports2.precisionRound = precisionRound;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-geo/dist/d3-geo.js
  var require_d3_geo = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-geo/dist/d3-geo.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_array()) : typeof define === "function" && define.amd ? define(["exports", "d3-array"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Array) {
        "use strict";
        function adder() {
          return new Adder();
        }
        function Adder() {
          this.reset();
        }
        Adder.prototype = {
          constructor: Adder,
          reset: function() {
            this.s = this.t = 0;
          },
          add: function(y) {
            add(temp, y, this.t);
            add(this, temp.s, this.s);
            if (this.s)
              this.t += temp.t;
            else
              this.s = temp.t;
          },
          valueOf: function() {
            return this.s;
          }
        };
        var temp = new Adder();
        function add(adder2, a, b) {
          var x = adder2.s = a + b, bv = x - a, av = x - bv;
          adder2.t = a - av + (b - bv);
        }
        var epsilon = 1e-6;
        var epsilon2 = 1e-12;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var quarterPi = pi / 4;
        var tau = pi * 2;
        var degrees = 180 / pi;
        var radians = pi / 180;
        var abs = Math.abs;
        var atan = Math.atan;
        var atan2 = Math.atan2;
        var cos = Math.cos;
        var ceil = Math.ceil;
        var exp = Math.exp;
        var log = Math.log;
        var pow = Math.pow;
        var sin = Math.sin;
        var sign = Math.sign || function(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        };
        var sqrt = Math.sqrt;
        var tan = Math.tan;
        function acos(x) {
          return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
        }
        function asin(x) {
          return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
        }
        function haversin(x) {
          return (x = sin(x / 2)) * x;
        }
        function noop() {
        }
        function streamGeometry(geometry, stream) {
          if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
            streamGeometryType[geometry.type](geometry, stream);
          }
        }
        var streamObjectType = {
          Feature: function(object2, stream) {
            streamGeometry(object2.geometry, stream);
          },
          FeatureCollection: function(object2, stream) {
            var features = object2.features, i = -1, n = features.length;
            while (++i < n)
              streamGeometry(features[i].geometry, stream);
          }
        };
        var streamGeometryType = {
          Sphere: function(object2, stream) {
            stream.sphere();
          },
          Point: function(object2, stream) {
            object2 = object2.coordinates;
            stream.point(object2[0], object2[1], object2[2]);
          },
          MultiPoint: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
          },
          LineString: function(object2, stream) {
            streamLine(object2.coordinates, stream, 0);
          },
          MultiLineString: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              streamLine(coordinates2[i], stream, 0);
          },
          Polygon: function(object2, stream) {
            streamPolygon(object2.coordinates, stream);
          },
          MultiPolygon: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              streamPolygon(coordinates2[i], stream);
          },
          GeometryCollection: function(object2, stream) {
            var geometries = object2.geometries, i = -1, n = geometries.length;
            while (++i < n)
              streamGeometry(geometries[i], stream);
          }
        };
        function streamLine(coordinates2, stream, closed) {
          var i = -1, n = coordinates2.length - closed, coordinate;
          stream.lineStart();
          while (++i < n)
            coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
          stream.lineEnd();
        }
        function streamPolygon(coordinates2, stream) {
          var i = -1, n = coordinates2.length;
          stream.polygonStart();
          while (++i < n)
            streamLine(coordinates2[i], stream, 1);
          stream.polygonEnd();
        }
        function geoStream(object2, stream) {
          if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
            streamObjectType[object2.type](object2, stream);
          } else {
            streamGeometry(object2, stream);
          }
        }
        var areaRingSum = adder();
        var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
        var areaStream = {
          point: noop,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: function() {
            areaRingSum.reset();
            areaStream.lineStart = areaRingStart;
            areaStream.lineEnd = areaRingEnd;
          },
          polygonEnd: function() {
            var areaRing = +areaRingSum;
            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
            this.lineStart = this.lineEnd = this.point = noop;
          },
          sphere: function() {
            areaSum.add(tau);
          }
        };
        function areaRingStart() {
          areaStream.point = areaPointFirst;
        }
        function areaRingEnd() {
          areaPoint(lambda00, phi00);
        }
        function areaPointFirst(lambda, phi) {
          areaStream.point = areaPoint;
          lambda00 = lambda, phi00 = phi;
          lambda *= radians, phi *= radians;
          lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
        }
        function areaPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          phi = phi / 2 + quarterPi;
          var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
          areaRingSum.add(atan2(v, u));
          lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
        }
        function area(object2) {
          areaSum.reset();
          geoStream(object2, areaStream);
          return areaSum * 2;
        }
        function spherical(cartesian2) {
          return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
        }
        function cartesian(spherical2) {
          var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
          return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
        }
        function cartesianDot(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        function cartesianCross(a, b) {
          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        }
        function cartesianAddInPlace(a, b) {
          a[0] += b[0], a[1] += b[1], a[2] += b[2];
        }
        function cartesianScale(vector, k) {
          return [vector[0] * k, vector[1] * k, vector[2] * k];
        }
        function cartesianNormalizeInPlace(d) {
          var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
          d[0] /= l, d[1] /= l, d[2] /= l;
        }
        var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum = adder(), ranges, range;
        var boundsStream = {
          point: boundsPoint,
          lineStart: boundsLineStart,
          lineEnd: boundsLineEnd,
          polygonStart: function() {
            boundsStream.point = boundsRingPoint;
            boundsStream.lineStart = boundsRingStart;
            boundsStream.lineEnd = boundsRingEnd;
            deltaSum.reset();
            areaStream.polygonStart();
          },
          polygonEnd: function() {
            areaStream.polygonEnd();
            boundsStream.point = boundsPoint;
            boundsStream.lineStart = boundsLineStart;
            boundsStream.lineEnd = boundsLineEnd;
            if (areaRingSum < 0)
              lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
            else if (deltaSum > epsilon)
              phi1 = 90;
            else if (deltaSum < -epsilon)
              phi0 = -90;
            range[0] = lambda0$1, range[1] = lambda1;
          },
          sphere: function() {
            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          }
        };
        function boundsPoint(lambda, phi) {
          ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
          if (phi < phi0)
            phi0 = phi;
          if (phi > phi1)
            phi1 = phi;
        }
        function linePoint(lambda, phi) {
          var p = cartesian([lambda * radians, phi * radians]);
          if (p0) {
            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
            cartesianNormalizeInPlace(inflection);
            inflection = spherical(inflection);
            var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
            if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
              phii = inflection[1] * degrees;
              if (phii > phi1)
                phi1 = phii;
            } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
              phii = -inflection[1] * degrees;
              if (phii < phi0)
                phi0 = phii;
            } else {
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
            }
            if (antimeridian) {
              if (lambda < lambda2) {
                if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                  lambda1 = lambda;
              } else {
                if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                  lambda0$1 = lambda;
              }
            } else {
              if (lambda1 >= lambda0$1) {
                if (lambda < lambda0$1)
                  lambda0$1 = lambda;
                if (lambda > lambda1)
                  lambda1 = lambda;
              } else {
                if (lambda > lambda2) {
                  if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                    lambda1 = lambda;
                } else {
                  if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                    lambda0$1 = lambda;
                }
              }
            }
          } else {
            ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
          }
          if (phi < phi0)
            phi0 = phi;
          if (phi > phi1)
            phi1 = phi;
          p0 = p, lambda2 = lambda;
        }
        function boundsLineStart() {
          boundsStream.point = linePoint;
        }
        function boundsLineEnd() {
          range[0] = lambda0$1, range[1] = lambda1;
          boundsStream.point = boundsPoint;
          p0 = null;
        }
        function boundsRingPoint(lambda, phi) {
          if (p0) {
            var delta = lambda - lambda2;
            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
          } else {
            lambda00$1 = lambda, phi00$1 = phi;
          }
          areaStream.point(lambda, phi);
          linePoint(lambda, phi);
        }
        function boundsRingStart() {
          areaStream.lineStart();
        }
        function boundsRingEnd() {
          boundsRingPoint(lambda00$1, phi00$1);
          areaStream.lineEnd();
          if (abs(deltaSum) > epsilon)
            lambda0$1 = -(lambda1 = 180);
          range[0] = lambda0$1, range[1] = lambda1;
          p0 = null;
        }
        function angle(lambda02, lambda12) {
          return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
        }
        function rangeCompare(a, b) {
          return a[0] - b[0];
        }
        function rangeContains(range2, x) {
          return range2[0] <= range2[1] ? range2[0] <= x && x <= range2[1] : x < range2[0] || range2[1] < x;
        }
        function bounds(feature) {
          var i, n, a, b, merged, deltaMax, delta;
          phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
          ranges = [];
          geoStream(feature, boundsStream);
          if (n = ranges.length) {
            ranges.sort(rangeCompare);
            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                if (angle(a[0], b[1]) > angle(a[0], a[1]))
                  a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1]))
                  a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
              b = merged[i];
              if ((delta = angle(a[1], b[0])) > deltaMax)
                deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
            }
          }
          ranges = range = null;
          return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
        }
        var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0;
        var centroidStream = {
          sphere: noop,
          point: centroidPoint,
          lineStart: centroidLineStart,
          lineEnd: centroidLineEnd,
          polygonStart: function() {
            centroidStream.lineStart = centroidRingStart;
            centroidStream.lineEnd = centroidRingEnd;
          },
          polygonEnd: function() {
            centroidStream.lineStart = centroidLineStart;
            centroidStream.lineEnd = centroidLineEnd;
          }
        };
        function centroidPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi);
          centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
        }
        function centroidPointCartesian(x, y, z) {
          ++W0;
          X0 += (x - X0) / W0;
          Y0 += (y - Y0) / W0;
          Z0 += (z - Z0) / W0;
        }
        function centroidLineStart() {
          centroidStream.point = centroidLinePointFirst;
        }
        function centroidLinePointFirst(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi);
          x0 = cosPhi * cos(lambda);
          y0 = cosPhi * sin(lambda);
          z0 = sin(phi);
          centroidStream.point = centroidLinePoint;
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidLinePoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          W1 += w;
          X1 += w * (x0 + (x0 = x));
          Y1 += w * (y0 + (y0 = y));
          Z1 += w * (z0 + (z0 = z));
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidLineEnd() {
          centroidStream.point = centroidPoint;
        }
        function centroidRingStart() {
          centroidStream.point = centroidRingPointFirst;
        }
        function centroidRingEnd() {
          centroidRingPoint(lambda00$2, phi00$2);
          centroidStream.point = centroidPoint;
        }
        function centroidRingPointFirst(lambda, phi) {
          lambda00$2 = lambda, phi00$2 = phi;
          lambda *= radians, phi *= radians;
          centroidStream.point = centroidRingPoint;
          var cosPhi = cos(phi);
          x0 = cosPhi * cos(lambda);
          y0 = cosPhi * sin(lambda);
          z0 = sin(phi);
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidRingPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), v = m && -w / m;
          X2 += v * cx;
          Y2 += v * cy;
          Z2 += v * cz;
          W1 += w;
          X1 += w * (x0 + (x0 = x));
          Y1 += w * (y0 + (y0 = y));
          Z1 += w * (z0 + (z0 = z));
          centroidPointCartesian(x0, y0, z0);
        }
        function centroid(object2) {
          W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
          geoStream(object2, centroidStream);
          var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
          if (m < epsilon2) {
            x = X1, y = Y1, z = Z1;
            if (W1 < epsilon)
              x = X0, y = Y0, z = Z0;
            m = x * x + y * y + z * z;
            if (m < epsilon2)
              return [NaN, NaN];
          }
          return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function compose(a, b) {
          function compose2(x, y) {
            return x = a(x, y), b(x[0], x[1]);
          }
          if (a.invert && b.invert)
            compose2.invert = function(x, y) {
              return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
          return compose2;
        }
        function rotationIdentity(lambda, phi) {
          return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
        }
        rotationIdentity.invert = rotationIdentity;
        function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
          return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
        }
        function forwardRotationLambda(deltaLambda) {
          return function(lambda, phi) {
            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
          };
        }
        function rotationLambda(deltaLambda) {
          var rotation2 = forwardRotationLambda(deltaLambda);
          rotation2.invert = forwardRotationLambda(-deltaLambda);
          return rotation2;
        }
        function rotationPhiGamma(deltaPhi, deltaGamma) {
          var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
          function rotation2(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
            return [
              atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
              asin(k * cosDeltaGamma + y * sinDeltaGamma)
            ];
          }
          rotation2.invert = function(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
            return [
              atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
              asin(k * cosDeltaPhi - x * sinDeltaPhi)
            ];
          };
          return rotation2;
        }
        function rotation(rotate) {
          rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
          function forward(coordinates2) {
            coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
            return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
          }
          forward.invert = function(coordinates2) {
            coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
            return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
          };
          return forward;
        }
        function circleStream(stream, radius, delta, direction, t0, t1) {
          if (!delta)
            return;
          var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
          if (t0 == null) {
            t0 = radius + direction * tau;
            t1 = radius - step / 2;
          } else {
            t0 = circleRadius(cosRadius, t0);
            t1 = circleRadius(cosRadius, t1);
            if (direction > 0 ? t0 < t1 : t0 > t1)
              t0 += direction * tau;
          }
          for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
            stream.point(point[0], point[1]);
          }
        }
        function circleRadius(cosRadius, point) {
          point = cartesian(point), point[0] -= cosRadius;
          cartesianNormalizeInPlace(point);
          var radius = acos(-point[1]);
          return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
        }
        function circle() {
          var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
          function point(x, y) {
            ring.push(x = rotate(x, y));
            x[0] *= degrees, x[1] *= degrees;
          }
          function circle2() {
            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
            ring = [];
            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
            circleStream(stream, r, p, 1);
            c = { type: "Polygon", coordinates: [ring] };
            ring = rotate = null;
            return c;
          }
          circle2.center = function(_) {
            return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
          };
          circle2.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
          };
          circle2.precision = function(_) {
            return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
          };
          return circle2;
        }
        function clipBuffer() {
          var lines = [], line;
          return {
            point: function(x, y, m) {
              line.push([x, y, m]);
            },
            lineStart: function() {
              lines.push(line = []);
            },
            lineEnd: noop,
            rejoin: function() {
              if (lines.length > 1)
                lines.push(lines.pop().concat(lines.shift()));
            },
            result: function() {
              var result = lines;
              lines = [];
              line = null;
              return result;
            }
          };
        }
        function pointEqual(a, b) {
          return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
        }
        function Intersection(point, points, other, entry) {
          this.x = point;
          this.z = points;
          this.o = other;
          this.e = entry;
          this.v = false;
          this.n = this.p = null;
        }
        function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
          var subject = [], clip2 = [], i, n;
          segments.forEach(function(segment) {
            if ((n2 = segment.length - 1) <= 0)
              return;
            var n2, p02 = segment[0], p1 = segment[n2], x;
            if (pointEqual(p02, p1)) {
              if (!p02[2] && !p1[2]) {
                stream.lineStart();
                for (i = 0; i < n2; ++i)
                  stream.point((p02 = segment[i])[0], p02[1]);
                stream.lineEnd();
                return;
              }
              p1[0] += 2 * epsilon;
            }
            subject.push(x = new Intersection(p02, segment, null, true));
            clip2.push(x.o = new Intersection(p02, null, x, false));
            subject.push(x = new Intersection(p1, segment, null, false));
            clip2.push(x.o = new Intersection(p1, null, x, true));
          });
          if (!subject.length)
            return;
          clip2.sort(compareIntersection2);
          link(subject);
          link(clip2);
          for (i = 0, n = clip2.length; i < n; ++i) {
            clip2[i].e = startInside = !startInside;
          }
          var start = subject[0], points, point;
          while (1) {
            var current = start, isSubject = true;
            while (current.v)
              if ((current = current.n) === start)
                return;
            points = current.z;
            stream.lineStart();
            do {
              current.v = current.o.v = true;
              if (current.e) {
                if (isSubject) {
                  for (i = 0, n = points.length; i < n; ++i)
                    stream.point((point = points[i])[0], point[1]);
                } else {
                  interpolate2(current.x, current.n.x, 1, stream);
                }
                current = current.n;
              } else {
                if (isSubject) {
                  points = current.p.z;
                  for (i = points.length - 1; i >= 0; --i)
                    stream.point((point = points[i])[0], point[1]);
                } else {
                  interpolate2(current.x, current.p.x, -1, stream);
                }
                current = current.p;
              }
              current = current.o;
              points = current.z;
              isSubject = !isSubject;
            } while (!current.v);
            stream.lineEnd();
          }
        }
        function link(array2) {
          if (!(n = array2.length))
            return;
          var n, i = 0, a = array2[0], b;
          while (++i < n) {
            a.n = b = array2[i];
            b.p = a;
            a = b;
          }
          a.n = b = array2[0];
          b.p = a;
        }
        var sum = adder();
        function longitude(point) {
          if (abs(point[0]) <= pi)
            return point[0];
          else
            return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
        }
        function polygonContains(polygon, point) {
          var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
          sum.reset();
          if (sinPhi === 1)
            phi = halfPi + epsilon;
          else if (sinPhi === -1)
            phi = -halfPi - epsilon;
          for (var i = 0, n = polygon.length; i < n; ++i) {
            if (!(m = (ring = polygon[i]).length))
              continue;
            var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
            for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
              var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
              sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
              angle2 += antimeridian ? delta + sign2 * tau : delta;
              if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
                var arc = cartesianCross(cartesian(point0), cartesian(point1));
                cartesianNormalizeInPlace(arc);
                var intersection = cartesianCross(normal, arc);
                cartesianNormalizeInPlace(intersection);
                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                  winding += antimeridian ^ delta >= 0 ? 1 : -1;
                }
              }
            }
          }
          return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
        }
        function clip(pointVisible, clipLine2, interpolate2, start) {
          return function(sink) {
            var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
            var clip2 = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                clip2.point = pointRing;
                clip2.lineStart = ringStart;
                clip2.lineEnd = ringEnd;
                segments = [];
                polygon = [];
              },
              polygonEnd: function() {
                clip2.point = point;
                clip2.lineStart = lineStart;
                clip2.lineEnd = lineEnd;
                segments = d3Array.merge(segments);
                var startInside = polygonContains(polygon, start);
                if (segments.length) {
                  if (!polygonStarted)
                    sink.polygonStart(), polygonStarted = true;
                  clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
                } else if (startInside) {
                  if (!polygonStarted)
                    sink.polygonStart(), polygonStarted = true;
                  sink.lineStart();
                  interpolate2(null, null, 1, sink);
                  sink.lineEnd();
                }
                if (polygonStarted)
                  sink.polygonEnd(), polygonStarted = false;
                segments = polygon = null;
              },
              sphere: function() {
                sink.polygonStart();
                sink.lineStart();
                interpolate2(null, null, 1, sink);
                sink.lineEnd();
                sink.polygonEnd();
              }
            };
            function point(lambda, phi) {
              if (pointVisible(lambda, phi))
                sink.point(lambda, phi);
            }
            function pointLine(lambda, phi) {
              line.point(lambda, phi);
            }
            function lineStart() {
              clip2.point = pointLine;
              line.lineStart();
            }
            function lineEnd() {
              clip2.point = point;
              line.lineEnd();
            }
            function pointRing(lambda, phi) {
              ring.push([lambda, phi]);
              ringSink.point(lambda, phi);
            }
            function ringStart() {
              ringSink.lineStart();
              ring = [];
            }
            function ringEnd() {
              pointRing(ring[0][0], ring[0][1]);
              ringSink.lineEnd();
              var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
              ring.pop();
              polygon.push(ring);
              ring = null;
              if (!n)
                return;
              if (clean & 1) {
                segment = ringSegments[0];
                if ((m = segment.length - 1) > 0) {
                  if (!polygonStarted)
                    sink.polygonStart(), polygonStarted = true;
                  sink.lineStart();
                  for (i = 0; i < m; ++i)
                    sink.point((point2 = segment[i])[0], point2[1]);
                  sink.lineEnd();
                }
                return;
              }
              if (n > 1 && clean & 2)
                ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
              segments.push(ringSegments.filter(validSegment));
            }
            return clip2;
          };
        }
        function validSegment(segment) {
          return segment.length > 1;
        }
        function compareIntersection(a, b) {
          return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
        }
        var clipAntimeridian = clip(
          function() {
            return true;
          },
          clipAntimeridianLine,
          clipAntimeridianInterpolate,
          [-pi, -halfPi]
        );
        function clipAntimeridianLine(stream) {
          var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
          return {
            lineStart: function() {
              stream.lineStart();
              clean = 1;
            },
            point: function(lambda12, phi12) {
              var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
              if (abs(delta - pi) < epsilon) {
                stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
                stream.point(sign0, phi02);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi02);
                stream.point(lambda12, phi02);
                clean = 0;
              } else if (sign0 !== sign1 && delta >= pi) {
                if (abs(lambda02 - sign0) < epsilon)
                  lambda02 -= sign0 * epsilon;
                if (abs(lambda12 - sign1) < epsilon)
                  lambda12 -= sign1 * epsilon;
                phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
                stream.point(sign0, phi02);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi02);
                clean = 0;
              }
              stream.point(lambda02 = lambda12, phi02 = phi12);
              sign0 = sign1;
            },
            lineEnd: function() {
              stream.lineEnd();
              lambda02 = phi02 = NaN;
            },
            clean: function() {
              return 2 - clean;
            }
          };
        }
        function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
          var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
          return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
        }
        function clipAntimeridianInterpolate(from, to, direction, stream) {
          var phi;
          if (from == null) {
            phi = direction * halfPi;
            stream.point(-pi, phi);
            stream.point(0, phi);
            stream.point(pi, phi);
            stream.point(pi, 0);
            stream.point(pi, -phi);
            stream.point(0, -phi);
            stream.point(-pi, -phi);
            stream.point(-pi, 0);
            stream.point(-pi, phi);
          } else if (abs(from[0] - to[0]) > epsilon) {
            var lambda = from[0] < to[0] ? pi : -pi;
            phi = direction * lambda / 2;
            stream.point(-lambda, phi);
            stream.point(0, phi);
            stream.point(lambda, phi);
          } else {
            stream.point(to[0], to[1]);
          }
        }
        function clipCircle(radius) {
          var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
          function interpolate2(from, to, direction, stream) {
            circleStream(stream, radius, delta, direction, from, to);
          }
          function visible(lambda, phi) {
            return cos(lambda) * cos(phi) > cr;
          }
          function clipLine2(stream) {
            var point0, c0, v0, v00, clean;
            return {
              lineStart: function() {
                v00 = v0 = false;
                clean = 1;
              },
              point: function(lambda, phi) {
                var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                if (!point0 && (v00 = v0 = v))
                  stream.lineStart();
                if (v !== v0) {
                  point2 = intersect(point0, point1);
                  if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                    point1[2] = 1;
                }
                if (v !== v0) {
                  clean = 0;
                  if (v) {
                    stream.lineStart();
                    point2 = intersect(point1, point0);
                    stream.point(point2[0], point2[1]);
                  } else {
                    point2 = intersect(point0, point1);
                    stream.point(point2[0], point2[1], 2);
                    stream.lineEnd();
                  }
                  point0 = point2;
                } else if (notHemisphere && point0 && smallRadius ^ v) {
                  var t;
                  if (!(c & c0) && (t = intersect(point1, point0, true))) {
                    clean = 0;
                    if (smallRadius) {
                      stream.lineStart();
                      stream.point(t[0][0], t[0][1]);
                      stream.point(t[1][0], t[1][1]);
                      stream.lineEnd();
                    } else {
                      stream.point(t[1][0], t[1][1]);
                      stream.lineEnd();
                      stream.lineStart();
                      stream.point(t[0][0], t[0][1], 3);
                    }
                  }
                }
                if (v && (!point0 || !pointEqual(point0, point1))) {
                  stream.point(point1[0], point1[1]);
                }
                point0 = point1, v0 = v, c0 = c;
              },
              lineEnd: function() {
                if (v0)
                  stream.lineEnd();
                point0 = null;
              },
              clean: function() {
                return clean | (v00 && v0) << 1;
              }
            };
          }
          function intersect(a, b, two) {
            var pa = cartesian(a), pb = cartesian(b);
            var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
              return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
            cartesianAddInPlace(A, B);
            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
            if (t2 < 0)
              return;
            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
            cartesianAddInPlace(q, A);
            q = spherical(q);
            if (!two)
              return q;
            var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
            if (lambda12 < lambda02)
              z = lambda02, lambda02 = lambda12, lambda12 = z;
            var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
            if (!polar && phi12 < phi02)
              z = phi02, phi02 = phi12, phi12 = z;
            if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
              var q1 = cartesianScale(u, (-w + t) / uu);
              cartesianAddInPlace(q1, A);
              return [q, spherical(q1)];
            }
          }
          function code(lambda, phi) {
            var r = smallRadius ? radius : pi - radius, code2 = 0;
            if (lambda < -r)
              code2 |= 1;
            else if (lambda > r)
              code2 |= 2;
            if (phi < -r)
              code2 |= 4;
            else if (phi > r)
              code2 |= 8;
            return code2;
          }
          return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
        }
        function clipLine(a, b, x02, y02, x12, y12) {
          var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
          r = x02 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x12 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y02 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y12 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (t0 > 0)
            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
          if (t1 < 1)
            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
          return true;
        }
        var clipMax = 1e9, clipMin = -clipMax;
        function clipRectangle(x02, y02, x12, y12) {
          function visible(x, y) {
            return x02 <= x && x <= x12 && y02 <= y && y <= y12;
          }
          function interpolate2(from, to, direction, stream) {
            var a = 0, a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
              do
                stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
              while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              stream.point(to[0], to[1]);
            }
          }
          function corner(p, direction) {
            return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
          }
          function compareIntersection2(a, b) {
            return comparePoint(a.x, b.x);
          }
          function comparePoint(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
          }
          return function(stream) {
            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
            var clipStream = {
              point,
              lineStart,
              lineEnd,
              polygonStart,
              polygonEnd
            };
            function point(x, y) {
              if (visible(x, y))
                activeStream.point(x, y);
            }
            function polygonInside() {
              var winding = 0;
              for (var i = 0, n = polygon.length; i < n; ++i) {
                for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                  a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                  if (a1 <= y12) {
                    if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                      ++winding;
                  } else {
                    if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                      --winding;
                  }
                }
              }
              return winding;
            }
            function polygonStart() {
              activeStream = bufferStream, segments = [], polygon = [], clean = true;
            }
            function polygonEnd() {
              var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
              if (cleanInside || visible2) {
                stream.polygonStart();
                if (cleanInside) {
                  stream.lineStart();
                  interpolate2(null, null, 1, stream);
                  stream.lineEnd();
                }
                if (visible2) {
                  clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
                }
                stream.polygonEnd();
              }
              activeStream = stream, segments = polygon = ring = null;
            }
            function lineStart() {
              clipStream.point = linePoint2;
              if (polygon)
                polygon.push(ring = []);
              first = true;
              v_ = false;
              x_ = y_ = NaN;
            }
            function lineEnd() {
              if (segments) {
                linePoint2(x__, y__);
                if (v__ && v_)
                  bufferStream.rejoin();
                segments.push(bufferStream.result());
              }
              clipStream.point = point;
              if (v_)
                activeStream.lineEnd();
            }
            function linePoint2(x, y) {
              var v = visible(x, y);
              if (polygon)
                ring.push([x, y]);
              if (first) {
                x__ = x, y__ = y, v__ = v;
                first = false;
                if (v) {
                  activeStream.lineStart();
                  activeStream.point(x, y);
                }
              } else {
                if (v && v_)
                  activeStream.point(x, y);
                else {
                  var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                  if (clipLine(a, b, x02, y02, x12, y12)) {
                    if (!v_) {
                      activeStream.lineStart();
                      activeStream.point(a[0], a[1]);
                    }
                    activeStream.point(b[0], b[1]);
                    if (!v)
                      activeStream.lineEnd();
                    clean = false;
                  } else if (v) {
                    activeStream.lineStart();
                    activeStream.point(x, y);
                    clean = false;
                  }
                }
              }
              x_ = x, y_ = y, v_ = v;
            }
            return clipStream;
          };
        }
        function extent() {
          var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
          return clip2 = {
            stream: function(stream) {
              return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
            },
            extent: function(_) {
              return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
            }
          };
        }
        var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;
        var lengthStream = {
          sphere: noop,
          point: noop,
          lineStart: lengthLineStart,
          lineEnd: noop,
          polygonStart: noop,
          polygonEnd: noop
        };
        function lengthLineStart() {
          lengthStream.point = lengthPointFirst;
          lengthStream.lineEnd = lengthLineEnd;
        }
        function lengthLineEnd() {
          lengthStream.point = lengthStream.lineEnd = noop;
        }
        function lengthPointFirst(lambda, phi) {
          lambda *= radians, phi *= radians;
          lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
          lengthStream.point = lengthPoint;
        }
        function lengthPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
          lengthSum.add(atan2(sqrt(x * x + y * y), z));
          lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
        }
        function length(object2) {
          lengthSum.reset();
          geoStream(object2, lengthStream);
          return +lengthSum;
        }
        var coordinates = [null, null], object = { type: "LineString", coordinates };
        function distance(a, b) {
          coordinates[0] = a;
          coordinates[1] = b;
          return length(object);
        }
        var containsObjectType = {
          Feature: function(object2, point) {
            return containsGeometry(object2.geometry, point);
          },
          FeatureCollection: function(object2, point) {
            var features = object2.features, i = -1, n = features.length;
            while (++i < n)
              if (containsGeometry(features[i].geometry, point))
                return true;
            return false;
          }
        };
        var containsGeometryType = {
          Sphere: function() {
            return true;
          },
          Point: function(object2, point) {
            return containsPoint(object2.coordinates, point);
          },
          MultiPoint: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              if (containsPoint(coordinates2[i], point))
                return true;
            return false;
          },
          LineString: function(object2, point) {
            return containsLine(object2.coordinates, point);
          },
          MultiLineString: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              if (containsLine(coordinates2[i], point))
                return true;
            return false;
          },
          Polygon: function(object2, point) {
            return containsPolygon(object2.coordinates, point);
          },
          MultiPolygon: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n)
              if (containsPolygon(coordinates2[i], point))
                return true;
            return false;
          },
          GeometryCollection: function(object2, point) {
            var geometries = object2.geometries, i = -1, n = geometries.length;
            while (++i < n)
              if (containsGeometry(geometries[i], point))
                return true;
            return false;
          }
        };
        function containsGeometry(geometry, point) {
          return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
        }
        function containsPoint(coordinates2, point) {
          return distance(coordinates2, point) === 0;
        }
        function containsLine(coordinates2, point) {
          var ao, bo, ab;
          for (var i = 0, n = coordinates2.length; i < n; i++) {
            bo = distance(coordinates2[i], point);
            if (bo === 0)
              return true;
            if (i > 0) {
              ab = distance(coordinates2[i], coordinates2[i - 1]);
              if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
                return true;
            }
            ao = bo;
          }
          return false;
        }
        function containsPolygon(coordinates2, point) {
          return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
        }
        function ringRadians(ring) {
          return ring = ring.map(pointRadians), ring.pop(), ring;
        }
        function pointRadians(point) {
          return [point[0] * radians, point[1] * radians];
        }
        function contains(object2, point) {
          return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
        }
        function graticuleX(y02, y12, dy) {
          var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
          return function(x) {
            return y.map(function(y2) {
              return [x, y2];
            });
          };
        }
        function graticuleY(x02, x12, dx) {
          var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
          return function(y) {
            return x.map(function(x2) {
              return [x2, y];
            });
          };
        }
        function graticule() {
          var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
          function graticule2() {
            return { type: "MultiLineString", coordinates: lines() };
          }
          function lines() {
            return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
              return abs(x2 % DX) > epsilon;
            }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
              return abs(y2 % DY) > epsilon;
            }).map(y));
          }
          graticule2.lines = function() {
            return lines().map(function(coordinates2) {
              return { type: "LineString", coordinates: coordinates2 };
            });
          };
          graticule2.outline = function() {
            return {
              type: "Polygon",
              coordinates: [
                X(X02).concat(
                  Y(Y12).slice(1),
                  X(X12).reverse().slice(1),
                  Y(Y02).reverse().slice(1)
                )
              ]
            };
          };
          graticule2.extent = function(_) {
            if (!arguments.length)
              return graticule2.extentMinor();
            return graticule2.extentMajor(_).extentMinor(_);
          };
          graticule2.extentMajor = function(_) {
            if (!arguments.length)
              return [[X02, Y02], [X12, Y12]];
            X02 = +_[0][0], X12 = +_[1][0];
            Y02 = +_[0][1], Y12 = +_[1][1];
            if (X02 > X12)
              _ = X02, X02 = X12, X12 = _;
            if (Y02 > Y12)
              _ = Y02, Y02 = Y12, Y12 = _;
            return graticule2.precision(precision);
          };
          graticule2.extentMinor = function(_) {
            if (!arguments.length)
              return [[x02, y02], [x12, y12]];
            x02 = +_[0][0], x12 = +_[1][0];
            y02 = +_[0][1], y12 = +_[1][1];
            if (x02 > x12)
              _ = x02, x02 = x12, x12 = _;
            if (y02 > y12)
              _ = y02, y02 = y12, y12 = _;
            return graticule2.precision(precision);
          };
          graticule2.step = function(_) {
            if (!arguments.length)
              return graticule2.stepMinor();
            return graticule2.stepMajor(_).stepMinor(_);
          };
          graticule2.stepMajor = function(_) {
            if (!arguments.length)
              return [DX, DY];
            DX = +_[0], DY = +_[1];
            return graticule2;
          };
          graticule2.stepMinor = function(_) {
            if (!arguments.length)
              return [dx, dy];
            dx = +_[0], dy = +_[1];
            return graticule2;
          };
          graticule2.precision = function(_) {
            if (!arguments.length)
              return precision;
            precision = +_;
            x = graticuleX(y02, y12, 90);
            y = graticuleY(x02, x12, precision);
            X = graticuleX(Y02, Y12, 90);
            Y = graticuleY(X02, X12, precision);
            return graticule2;
          };
          return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
        }
        function graticule10() {
          return graticule()();
        }
        function interpolate(a, b) {
          var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
          var interpolate2 = d ? function(t) {
            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
              atan2(y, x) * degrees,
              atan2(z, sqrt(x * x + y * y)) * degrees
            ];
          } : function() {
            return [x02 * degrees, y02 * degrees];
          };
          interpolate2.distance = d;
          return interpolate2;
        }
        function identity(x) {
          return x;
        }
        var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;
        var areaStream$1 = {
          point: noop,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: function() {
            areaStream$1.lineStart = areaRingStart$1;
            areaStream$1.lineEnd = areaRingEnd$1;
          },
          polygonEnd: function() {
            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
            areaSum$1.add(abs(areaRingSum$1));
            areaRingSum$1.reset();
          },
          result: function() {
            var area2 = areaSum$1 / 2;
            areaSum$1.reset();
            return area2;
          }
        };
        function areaRingStart$1() {
          areaStream$1.point = areaPointFirst$1;
        }
        function areaPointFirst$1(x, y) {
          areaStream$1.point = areaPoint$1;
          x00 = x0$1 = x, y00 = y0$1 = y;
        }
        function areaPoint$1(x, y) {
          areaRingSum$1.add(y0$1 * x - x0$1 * y);
          x0$1 = x, y0$1 = y;
        }
        function areaRingEnd$1() {
          areaPoint$1(x00, y00);
        }
        var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
        var boundsStream$1 = {
          point: boundsPoint$1,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: noop,
          polygonEnd: noop,
          result: function() {
            var bounds2 = [[x0$2, y0$2], [x1, y1]];
            x1 = y1 = -(y0$2 = x0$2 = Infinity);
            return bounds2;
          }
        };
        function boundsPoint$1(x, y) {
          if (x < x0$2)
            x0$2 = x;
          if (x > x1)
            x1 = x;
          if (y < y0$2)
            y0$2 = y;
          if (y > y1)
            y1 = y;
        }
        var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
        var centroidStream$1 = {
          point: centroidPoint$1,
          lineStart: centroidLineStart$1,
          lineEnd: centroidLineEnd$1,
          polygonStart: function() {
            centroidStream$1.lineStart = centroidRingStart$1;
            centroidStream$1.lineEnd = centroidRingEnd$1;
          },
          polygonEnd: function() {
            centroidStream$1.point = centroidPoint$1;
            centroidStream$1.lineStart = centroidLineStart$1;
            centroidStream$1.lineEnd = centroidLineEnd$1;
          },
          result: function() {
            var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
            X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
            return centroid2;
          }
        };
        function centroidPoint$1(x, y) {
          X0$1 += x;
          Y0$1 += y;
          ++Z0$1;
        }
        function centroidLineStart$1() {
          centroidStream$1.point = centroidPointFirstLine;
        }
        function centroidPointFirstLine(x, y) {
          centroidStream$1.point = centroidPointLine;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function centroidPointLine(x, y) {
          var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
          X1$1 += z * (x0$3 + x) / 2;
          Y1$1 += z * (y0$3 + y) / 2;
          Z1$1 += z;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function centroidLineEnd$1() {
          centroidStream$1.point = centroidPoint$1;
        }
        function centroidRingStart$1() {
          centroidStream$1.point = centroidPointFirstRing;
        }
        function centroidRingEnd$1() {
          centroidPointRing(x00$1, y00$1);
        }
        function centroidPointFirstRing(x, y) {
          centroidStream$1.point = centroidPointRing;
          centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
        }
        function centroidPointRing(x, y) {
          var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
          X1$1 += z * (x0$3 + x) / 2;
          Y1$1 += z * (y0$3 + y) / 2;
          Z1$1 += z;
          z = y0$3 * x - x0$3 * y;
          X2$1 += z * (x0$3 + x);
          Y2$1 += z * (y0$3 + y);
          Z2$1 += z * 3;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function PathContext(context) {
          this._context = context;
        }
        PathContext.prototype = {
          _radius: 4.5,
          pointRadius: function(_) {
            return this._radius = _, this;
          },
          polygonStart: function() {
            this._line = 0;
          },
          polygonEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line === 0)
              this._context.closePath();
            this._point = NaN;
          },
          point: function(x, y) {
            switch (this._point) {
              case 0: {
                this._context.moveTo(x, y);
                this._point = 1;
                break;
              }
              case 1: {
                this._context.lineTo(x, y);
                break;
              }
              default: {
                this._context.moveTo(x + this._radius, y);
                this._context.arc(x, y, this._radius, 0, tau);
                break;
              }
            }
          },
          result: noop
        };
        var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
        var lengthStream$1 = {
          point: noop,
          lineStart: function() {
            lengthStream$1.point = lengthPointFirst$1;
          },
          lineEnd: function() {
            if (lengthRing)
              lengthPoint$1(x00$2, y00$2);
            lengthStream$1.point = noop;
          },
          polygonStart: function() {
            lengthRing = true;
          },
          polygonEnd: function() {
            lengthRing = null;
          },
          result: function() {
            var length2 = +lengthSum$1;
            lengthSum$1.reset();
            return length2;
          }
        };
        function lengthPointFirst$1(x, y) {
          lengthStream$1.point = lengthPoint$1;
          x00$2 = x0$4 = x, y00$2 = y0$4 = y;
        }
        function lengthPoint$1(x, y) {
          x0$4 -= x, y0$4 -= y;
          lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
          x0$4 = x, y0$4 = y;
        }
        function PathString() {
          this._string = [];
        }
        PathString.prototype = {
          _radius: 4.5,
          _circle: circle$1(4.5),
          pointRadius: function(_) {
            if ((_ = +_) !== this._radius)
              this._radius = _, this._circle = null;
            return this;
          },
          polygonStart: function() {
            this._line = 0;
          },
          polygonEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line === 0)
              this._string.push("Z");
            this._point = NaN;
          },
          point: function(x, y) {
            switch (this._point) {
              case 0: {
                this._string.push("M", x, ",", y);
                this._point = 1;
                break;
              }
              case 1: {
                this._string.push("L", x, ",", y);
                break;
              }
              default: {
                if (this._circle == null)
                  this._circle = circle$1(this._radius);
                this._string.push("M", x, ",", y, this._circle);
                break;
              }
            }
          },
          result: function() {
            if (this._string.length) {
              var result = this._string.join("");
              this._string = [];
              return result;
            } else {
              return null;
            }
          }
        };
        function circle$1(radius) {
          return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
        }
        function index(projection2, context) {
          var pointRadius = 4.5, projectionStream, contextStream;
          function path(object2) {
            if (object2) {
              if (typeof pointRadius === "function")
                contextStream.pointRadius(+pointRadius.apply(this, arguments));
              geoStream(object2, projectionStream(contextStream));
            }
            return contextStream.result();
          }
          path.area = function(object2) {
            geoStream(object2, projectionStream(areaStream$1));
            return areaStream$1.result();
          };
          path.measure = function(object2) {
            geoStream(object2, projectionStream(lengthStream$1));
            return lengthStream$1.result();
          };
          path.bounds = function(object2) {
            geoStream(object2, projectionStream(boundsStream$1));
            return boundsStream$1.result();
          };
          path.centroid = function(object2) {
            geoStream(object2, projectionStream(centroidStream$1));
            return centroidStream$1.result();
          };
          path.projection = function(_) {
            return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
          };
          path.context = function(_) {
            if (!arguments.length)
              return context;
            contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
            if (typeof pointRadius !== "function")
              contextStream.pointRadius(pointRadius);
            return path;
          };
          path.pointRadius = function(_) {
            if (!arguments.length)
              return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
          };
          return path.projection(projection2).context(context);
        }
        function transform(methods) {
          return {
            stream: transformer(methods)
          };
        }
        function transformer(methods) {
          return function(stream) {
            var s = new TransformStream();
            for (var key in methods)
              s[key] = methods[key];
            s.stream = stream;
            return s;
          };
        }
        function TransformStream() {
        }
        TransformStream.prototype = {
          constructor: TransformStream,
          point: function(x, y) {
            this.stream.point(x, y);
          },
          sphere: function() {
            this.stream.sphere();
          },
          lineStart: function() {
            this.stream.lineStart();
          },
          lineEnd: function() {
            this.stream.lineEnd();
          },
          polygonStart: function() {
            this.stream.polygonStart();
          },
          polygonEnd: function() {
            this.stream.polygonEnd();
          }
        };
        function fit(projection2, fitBounds, object2) {
          var clip2 = projection2.clipExtent && projection2.clipExtent();
          projection2.scale(150).translate([0, 0]);
          if (clip2 != null)
            projection2.clipExtent(null);
          geoStream(object2, projection2.stream(boundsStream$1));
          fitBounds(boundsStream$1.result());
          if (clip2 != null)
            projection2.clipExtent(clip2);
          return projection2;
        }
        function fitExtent(projection2, extent2, object2) {
          return fit(projection2, function(b) {
            var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        function fitSize(projection2, size, object2) {
          return fitExtent(projection2, [[0, 0], size], object2);
        }
        function fitWidth(projection2, width, object2) {
          return fit(projection2, function(b) {
            var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        function fitHeight(projection2, height, object2) {
          return fit(projection2, function(b) {
            var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        var maxDepth = 16, cosMinDistance = cos(30 * radians);
        function resample(project, delta2) {
          return +delta2 ? resample$1(project, delta2) : resampleNone(project);
        }
        function resampleNone(project) {
          return transformer({
            point: function(x, y) {
              x = project(x, y);
              this.stream.point(x[0], x[1]);
            }
          });
        }
        function resample$1(project, delta2) {
          function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
            var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
              var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
              if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
                stream.point(x2, y2);
                resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
              }
            }
          }
          return function(stream) {
            var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
            var resampleStream = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                stream.polygonStart();
                resampleStream.lineStart = ringStart;
              },
              polygonEnd: function() {
                stream.polygonEnd();
                resampleStream.lineStart = lineStart;
              }
            };
            function point(x, y) {
              x = project(x, y);
              stream.point(x[0], x[1]);
            }
            function lineStart() {
              x02 = NaN;
              resampleStream.point = linePoint2;
              stream.lineStart();
            }
            function linePoint2(lambda, phi) {
              var c = cartesian([lambda, phi]), p = project(lambda, phi);
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
              stream.point(x02, y02);
            }
            function lineEnd() {
              resampleStream.point = point;
              stream.lineEnd();
            }
            function ringStart() {
              lineStart();
              resampleStream.point = ringPoint;
              resampleStream.lineEnd = ringEnd;
            }
            function ringPoint(lambda, phi) {
              linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
              resampleStream.point = linePoint2;
            }
            function ringEnd() {
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
              resampleStream.lineEnd = lineEnd;
              lineEnd();
            }
            return resampleStream;
          };
        }
        var transformRadians = transformer({
          point: function(x, y) {
            this.stream.point(x * radians, y * radians);
          }
        });
        function transformRotate(rotate) {
          return transformer({
            point: function(x, y) {
              var r = rotate(x, y);
              return this.stream.point(r[0], r[1]);
            }
          });
        }
        function scaleTranslate(k, dx, dy, sx, sy) {
          function transform2(x, y) {
            x *= sx;
            y *= sy;
            return [dx + k * x, dy - k * y];
          }
          transform2.invert = function(x, y) {
            return [(x - dx) / k * sx, (dy - y) / k * sy];
          };
          return transform2;
        }
        function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
          var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
          function transform2(x, y) {
            x *= sx;
            y *= sy;
            return [a * x - b * y + dx, dy - b * x - a * y];
          }
          transform2.invert = function(x, y) {
            return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
          };
          return transform2;
        }
        function projection(project) {
          return projectionMutator(function() {
            return project;
          })();
        }
        function projectionMutator(projectAt) {
          var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
          function projection2(point) {
            return projectRotateTransform(point[0] * radians, point[1] * radians);
          }
          function invert(point) {
            point = projectRotateTransform.invert(point[0], point[1]);
            return point && [point[0] * degrees, point[1] * degrees];
          }
          projection2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
          };
          projection2.preclip = function(_) {
            return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
          };
          projection2.postclip = function(_) {
            return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
          };
          projection2.clipAngle = function(_) {
            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
          };
          projection2.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          projection2.scale = function(_) {
            return arguments.length ? (k = +_, recenter()) : k;
          };
          projection2.translate = function(_) {
            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
          };
          projection2.center = function(_) {
            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
          };
          projection2.rotate = function(_) {
            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
          };
          projection2.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
          };
          projection2.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
          };
          projection2.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
          };
          projection2.precision = function(_) {
            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
          };
          projection2.fitExtent = function(extent2, object2) {
            return fitExtent(projection2, extent2, object2);
          };
          projection2.fitSize = function(size, object2) {
            return fitSize(projection2, size, object2);
          };
          projection2.fitWidth = function(width, object2) {
            return fitWidth(projection2, width, object2);
          };
          projection2.fitHeight = function(height, object2) {
            return fitHeight(projection2, height, object2);
          };
          function recenter() {
            var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
            rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
            projectTransform = compose(project, transform2);
            projectRotateTransform = compose(rotate, projectTransform);
            projectResample = resample(projectTransform, delta2);
            return reset();
          }
          function reset() {
            cache = cacheStream = null;
            return projection2;
          }
          return function() {
            project = projectAt.apply(this, arguments);
            projection2.invert = project.invert && invert;
            return recenter();
          };
        }
        function conicProjection(projectAt) {
          var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
          p.parallels = function(_) {
            return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
          };
          return p;
        }
        function cylindricalEqualAreaRaw(phi02) {
          var cosPhi02 = cos(phi02);
          function forward(lambda, phi) {
            return [lambda * cosPhi02, sin(phi) / cosPhi02];
          }
          forward.invert = function(x, y) {
            return [x / cosPhi02, asin(y * cosPhi02)];
          };
          return forward;
        }
        function conicEqualAreaRaw(y02, y12) {
          var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
          if (abs(n) < epsilon)
            return cylindricalEqualAreaRaw(y02);
          var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
          function project(x, y) {
            var r = sqrt(c - 2 * n * sin(y)) / n;
            return [r * sin(x *= n), r0 - r * cos(x)];
          }
          project.invert = function(x, y) {
            var r0y = r0 - y, l = atan2(x, abs(r0y)) * sign(r0y);
            if (r0y * n < 0)
              l -= pi * sign(x) * sign(r0y);
            return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
          };
          return project;
        }
        function conicEqualArea() {
          return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
        }
        function albers() {
          return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
        }
        function multiplex(streams) {
          var n = streams.length;
          return {
            point: function(x, y) {
              var i = -1;
              while (++i < n)
                streams[i].point(x, y);
            },
            sphere: function() {
              var i = -1;
              while (++i < n)
                streams[i].sphere();
            },
            lineStart: function() {
              var i = -1;
              while (++i < n)
                streams[i].lineStart();
            },
            lineEnd: function() {
              var i = -1;
              while (++i < n)
                streams[i].lineEnd();
            },
            polygonStart: function() {
              var i = -1;
              while (++i < n)
                streams[i].polygonStart();
            },
            polygonEnd: function() {
              var i = -1;
              while (++i < n)
                streams[i].polygonEnd();
            }
          };
        }
        function albersUsa() {
          var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
            point = [x, y];
          } };
          function albersUsa2(coordinates2) {
            var x = coordinates2[0], y = coordinates2[1];
            return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
          }
          albersUsa2.invert = function(coordinates2) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
          };
          albersUsa2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
          };
          albersUsa2.precision = function(_) {
            if (!arguments.length)
              return lower48.precision();
            lower48.precision(_), alaska.precision(_), hawaii.precision(_);
            return reset();
          };
          albersUsa2.scale = function(_) {
            if (!arguments.length)
              return lower48.scale();
            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
            return albersUsa2.translate(lower48.translate());
          };
          albersUsa2.translate = function(_) {
            if (!arguments.length)
              return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
            alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
            hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
            return reset();
          };
          albersUsa2.fitExtent = function(extent2, object2) {
            return fitExtent(albersUsa2, extent2, object2);
          };
          albersUsa2.fitSize = function(size, object2) {
            return fitSize(albersUsa2, size, object2);
          };
          albersUsa2.fitWidth = function(width, object2) {
            return fitWidth(albersUsa2, width, object2);
          };
          albersUsa2.fitHeight = function(height, object2) {
            return fitHeight(albersUsa2, height, object2);
          };
          function reset() {
            cache = cacheStream = null;
            return albersUsa2;
          }
          return albersUsa2.scale(1070);
        }
        function azimuthalRaw(scale) {
          return function(x, y) {
            var cx = cos(x), cy = cos(y), k = scale(cx * cy);
            return [
              k * cy * sin(x),
              k * sin(y)
            ];
          };
        }
        function azimuthalInvert(angle2) {
          return function(x, y) {
            var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
            return [
              atan2(x * sc, z * cc),
              asin(z && y * sc / z)
            ];
          };
        }
        var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
          return sqrt(2 / (1 + cxcy));
        });
        azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
          return 2 * asin(z / 2);
        });
        function azimuthalEqualArea() {
          return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
        }
        var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
          return (c = acos(c)) && c / sin(c);
        });
        azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
          return z;
        });
        function azimuthalEquidistant() {
          return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
        }
        function mercatorRaw(lambda, phi) {
          return [lambda, log(tan((halfPi + phi) / 2))];
        }
        mercatorRaw.invert = function(x, y) {
          return [x, 2 * atan(exp(y)) - halfPi];
        };
        function mercator() {
          return mercatorProjection(mercatorRaw).scale(961 / tau);
        }
        function mercatorProjection(project) {
          var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
          m.scale = function(_) {
            return arguments.length ? (scale(_), reclip()) : scale();
          };
          m.translate = function(_) {
            return arguments.length ? (translate(_), reclip()) : translate();
          };
          m.center = function(_) {
            return arguments.length ? (center(_), reclip()) : center();
          };
          m.clipExtent = function(_) {
            return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          function reclip() {
            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
            return clipExtent(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
          }
          return reclip();
        }
        function tany(y) {
          return tan((halfPi + y) / 2);
        }
        function conicConformalRaw(y02, y12) {
          var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
          if (!n)
            return mercatorRaw;
          function project(x, y) {
            if (f > 0) {
              if (y < -halfPi + epsilon)
                y = -halfPi + epsilon;
            } else {
              if (y > halfPi - epsilon)
                y = halfPi - epsilon;
            }
            var r = f / pow(tany(y), n);
            return [r * sin(n * x), f - r * cos(n * x)];
          }
          project.invert = function(x, y) {
            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy), l = atan2(x, abs(fy)) * sign(fy);
            if (fy * n < 0)
              l -= pi * sign(x) * sign(fy);
            return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
          };
          return project;
        }
        function conicConformal() {
          return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
        }
        function equirectangularRaw(lambda, phi) {
          return [lambda, phi];
        }
        equirectangularRaw.invert = equirectangularRaw;
        function equirectangular() {
          return projection(equirectangularRaw).scale(152.63);
        }
        function conicEquidistantRaw(y02, y12) {
          var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
          if (abs(n) < epsilon)
            return equirectangularRaw;
          function project(x, y) {
            var gy = g - y, nx = n * x;
            return [gy * sin(nx), g - gy * cos(nx)];
          }
          project.invert = function(x, y) {
            var gy = g - y, l = atan2(x, abs(gy)) * sign(gy);
            if (gy * n < 0)
              l -= pi * sign(x) * sign(gy);
            return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
          };
          return project;
        }
        function conicEquidistant() {
          return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
        }
        var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt(3) / 2, iterations = 12;
        function equalEarthRaw(lambda, phi) {
          var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
          return [
            lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
            l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
          ];
        }
        equalEarthRaw.invert = function(x, y) {
          var l = y, l2 = l * l, l6 = l2 * l2 * l2;
          for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
            fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
            fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
            l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
            if (abs(delta) < epsilon2)
              break;
          }
          return [
            M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
            asin(sin(l) / M)
          ];
        };
        function equalEarth() {
          return projection(equalEarthRaw).scale(177.158);
        }
        function gnomonicRaw(x, y) {
          var cy = cos(y), k = cos(x) * cy;
          return [cy * sin(x) / k, sin(y) / k];
        }
        gnomonicRaw.invert = azimuthalInvert(atan);
        function gnomonic() {
          return projection(gnomonicRaw).scale(144.049).clipAngle(60);
        }
        function identity$1() {
          var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
            point: function(x, y) {
              var p = projection2([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }), postclip = identity, cache, cacheStream;
          function reset() {
            kx = k * sx;
            ky = k * sy;
            cache = cacheStream = null;
            return projection2;
          }
          function projection2(p) {
            var x = p[0] * kx, y = p[1] * ky;
            if (alpha) {
              var t = y * ca - x * sa;
              x = x * ca + y * sa;
              y = t;
            }
            return [x + tx, y + ty];
          }
          projection2.invert = function(p) {
            var x = p[0] - tx, y = p[1] - ty;
            if (alpha) {
              var t = y * ca + x * sa;
              x = x * ca - y * sa;
              y = t;
            }
            return [x / kx, y / ky];
          };
          projection2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
          };
          projection2.postclip = function(_) {
            return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
          };
          projection2.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          projection2.scale = function(_) {
            return arguments.length ? (k = +_, reset()) : k;
          };
          projection2.translate = function(_) {
            return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
          };
          projection2.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
          };
          projection2.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
          };
          projection2.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
          };
          projection2.fitExtent = function(extent2, object2) {
            return fitExtent(projection2, extent2, object2);
          };
          projection2.fitSize = function(size, object2) {
            return fitSize(projection2, size, object2);
          };
          projection2.fitWidth = function(width, object2) {
            return fitWidth(projection2, width, object2);
          };
          projection2.fitHeight = function(height, object2) {
            return fitHeight(projection2, height, object2);
          };
          return projection2;
        }
        function naturalEarth1Raw(lambda, phi) {
          var phi2 = phi * phi, phi4 = phi2 * phi2;
          return [
            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
          ];
        }
        naturalEarth1Raw.invert = function(x, y) {
          var phi = y, i = 25, delta;
          do {
            var phi2 = phi * phi, phi4 = phi2 * phi2;
            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
          } while (abs(delta) > epsilon && --i > 0);
          return [
            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
            phi
          ];
        };
        function naturalEarth1() {
          return projection(naturalEarth1Raw).scale(175.295);
        }
        function orthographicRaw(x, y) {
          return [cos(y) * sin(x), sin(y)];
        }
        orthographicRaw.invert = azimuthalInvert(asin);
        function orthographic() {
          return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
        }
        function stereographicRaw(x, y) {
          var cy = cos(y), k = 1 + cos(x) * cy;
          return [cy * sin(x) / k, sin(y) / k];
        }
        stereographicRaw.invert = azimuthalInvert(function(z) {
          return 2 * atan(z);
        });
        function stereographic() {
          return projection(stereographicRaw).scale(250).clipAngle(142);
        }
        function transverseMercatorRaw(lambda, phi) {
          return [log(tan((halfPi + phi) / 2)), -lambda];
        }
        transverseMercatorRaw.invert = function(x, y) {
          return [-y, 2 * atan(exp(x)) - halfPi];
        };
        function transverseMercator() {
          var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
          m.center = function(_) {
            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
          };
          m.rotate = function(_) {
            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
          };
          return rotate([0, 0, 90]).scale(159.155);
        }
        exports2.geoAlbers = albers;
        exports2.geoAlbersUsa = albersUsa;
        exports2.geoArea = area;
        exports2.geoAzimuthalEqualArea = azimuthalEqualArea;
        exports2.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
        exports2.geoAzimuthalEquidistant = azimuthalEquidistant;
        exports2.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
        exports2.geoBounds = bounds;
        exports2.geoCentroid = centroid;
        exports2.geoCircle = circle;
        exports2.geoClipAntimeridian = clipAntimeridian;
        exports2.geoClipCircle = clipCircle;
        exports2.geoClipExtent = extent;
        exports2.geoClipRectangle = clipRectangle;
        exports2.geoConicConformal = conicConformal;
        exports2.geoConicConformalRaw = conicConformalRaw;
        exports2.geoConicEqualArea = conicEqualArea;
        exports2.geoConicEqualAreaRaw = conicEqualAreaRaw;
        exports2.geoConicEquidistant = conicEquidistant;
        exports2.geoConicEquidistantRaw = conicEquidistantRaw;
        exports2.geoContains = contains;
        exports2.geoDistance = distance;
        exports2.geoEqualEarth = equalEarth;
        exports2.geoEqualEarthRaw = equalEarthRaw;
        exports2.geoEquirectangular = equirectangular;
        exports2.geoEquirectangularRaw = equirectangularRaw;
        exports2.geoGnomonic = gnomonic;
        exports2.geoGnomonicRaw = gnomonicRaw;
        exports2.geoGraticule = graticule;
        exports2.geoGraticule10 = graticule10;
        exports2.geoIdentity = identity$1;
        exports2.geoInterpolate = interpolate;
        exports2.geoLength = length;
        exports2.geoMercator = mercator;
        exports2.geoMercatorRaw = mercatorRaw;
        exports2.geoNaturalEarth1 = naturalEarth1;
        exports2.geoNaturalEarth1Raw = naturalEarth1Raw;
        exports2.geoOrthographic = orthographic;
        exports2.geoOrthographicRaw = orthographicRaw;
        exports2.geoPath = index;
        exports2.geoProjection = projection;
        exports2.geoProjectionMutator = projectionMutator;
        exports2.geoRotation = rotation;
        exports2.geoStereographic = stereographic;
        exports2.geoStereographicRaw = stereographicRaw;
        exports2.geoStream = geoStream;
        exports2.geoTransform = transform;
        exports2.geoTransverseMercator = transverseMercator;
        exports2.geoTransverseMercatorRaw = transverseMercatorRaw;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-hierarchy/dist/d3-hierarchy.js
  var require_d3_hierarchy = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-hierarchy/dist/d3-hierarchy.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function defaultSeparation(a, b) {
          return a.parent === b.parent ? 1 : 2;
        }
        function meanX(children2) {
          return children2.reduce(meanXReduce, 0) / children2.length;
        }
        function meanXReduce(x, c) {
          return x + c.x;
        }
        function maxY(children2) {
          return 1 + children2.reduce(maxYReduce, 0);
        }
        function maxYReduce(y, c) {
          return Math.max(y, c.y);
        }
        function leafLeft(node) {
          var children2;
          while (children2 = node.children)
            node = children2[0];
          return node;
        }
        function leafRight(node) {
          var children2;
          while (children2 = node.children)
            node = children2[children2.length - 1];
          return node;
        }
        function cluster() {
          var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
          function cluster2(root2) {
            var previousNode, x = 0;
            root2.eachAfter(function(node) {
              var children2 = node.children;
              if (children2) {
                node.x = meanX(children2);
                node.y = maxY(children2);
              } else {
                node.x = previousNode ? x += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
              }
            });
            var left = leafLeft(root2), right = leafRight(root2), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            return root2.eachAfter(nodeSize ? function(node) {
              node.x = (node.x - root2.x) * dx;
              node.y = (root2.y - node.y) * dy;
            } : function(node) {
              node.x = (node.x - x0) / (x1 - x0) * dx;
              node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
            });
          }
          cluster2.separation = function(x) {
            return arguments.length ? (separation = x, cluster2) : separation;
          };
          cluster2.size = function(x) {
            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? null : [dx, dy];
          };
          cluster2.nodeSize = function(x) {
            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? [dx, dy] : null;
          };
          return cluster2;
        }
        function count(node) {
          var sum = 0, children2 = node.children, i = children2 && children2.length;
          if (!i)
            sum = 1;
          else
            while (--i >= 0)
              sum += children2[i].value;
          node.value = sum;
        }
        function node_count() {
          return this.eachAfter(count);
        }
        function node_each(callback) {
          var node = this, current, next = [node], children2, i, n;
          do {
            current = next.reverse(), next = [];
            while (node = current.pop()) {
              callback(node), children2 = node.children;
              if (children2)
                for (i = 0, n = children2.length; i < n; ++i) {
                  next.push(children2[i]);
                }
            }
          } while (next.length);
          return this;
        }
        function node_eachBefore(callback) {
          var node = this, nodes = [node], children2, i;
          while (node = nodes.pop()) {
            callback(node), children2 = node.children;
            if (children2)
              for (i = children2.length - 1; i >= 0; --i) {
                nodes.push(children2[i]);
              }
          }
          return this;
        }
        function node_eachAfter(callback) {
          var node = this, nodes = [node], next = [], children2, i, n;
          while (node = nodes.pop()) {
            next.push(node), children2 = node.children;
            if (children2)
              for (i = 0, n = children2.length; i < n; ++i) {
                nodes.push(children2[i]);
              }
          }
          while (node = next.pop()) {
            callback(node);
          }
          return this;
        }
        function node_sum(value) {
          return this.eachAfter(function(node) {
            var sum = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
            while (--i >= 0)
              sum += children2[i].value;
            node.value = sum;
          });
        }
        function node_sort(compare) {
          return this.eachBefore(function(node) {
            if (node.children) {
              node.children.sort(compare);
            }
          });
        }
        function node_path(end) {
          var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
          while (start !== ancestor) {
            start = start.parent;
            nodes.push(start);
          }
          var k = nodes.length;
          while (end !== ancestor) {
            nodes.splice(k, 0, end);
            end = end.parent;
          }
          return nodes;
        }
        function leastCommonAncestor(a, b) {
          if (a === b)
            return a;
          var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
          a = aNodes.pop();
          b = bNodes.pop();
          while (a === b) {
            c = a;
            a = aNodes.pop();
            b = bNodes.pop();
          }
          return c;
        }
        function node_ancestors() {
          var node = this, nodes = [node];
          while (node = node.parent) {
            nodes.push(node);
          }
          return nodes;
        }
        function node_descendants() {
          var nodes = [];
          this.each(function(node) {
            nodes.push(node);
          });
          return nodes;
        }
        function node_leaves() {
          var leaves = [];
          this.eachBefore(function(node) {
            if (!node.children) {
              leaves.push(node);
            }
          });
          return leaves;
        }
        function node_links() {
          var root2 = this, links = [];
          root2.each(function(node) {
            if (node !== root2) {
              links.push({ source: node.parent, target: node });
            }
          });
          return links;
        }
        function hierarchy(data, children2) {
          var root2 = new Node3(data), valued = +data.value && (root2.value = data.value), node, nodes = [root2], child, childs, i, n;
          if (children2 == null)
            children2 = defaultChildren;
          while (node = nodes.pop()) {
            if (valued)
              node.value = +node.data.value;
            if ((childs = children2(node.data)) && (n = childs.length)) {
              node.children = new Array(n);
              for (i = n - 1; i >= 0; --i) {
                nodes.push(child = node.children[i] = new Node3(childs[i]));
                child.parent = node;
                child.depth = node.depth + 1;
              }
            }
          }
          return root2.eachBefore(computeHeight);
        }
        function node_copy() {
          return hierarchy(this).eachBefore(copyData);
        }
        function defaultChildren(d) {
          return d.children;
        }
        function copyData(node) {
          node.data = node.data.data;
        }
        function computeHeight(node) {
          var height = 0;
          do
            node.height = height;
          while ((node = node.parent) && node.height < ++height);
        }
        function Node3(data) {
          this.data = data;
          this.depth = this.height = 0;
          this.parent = null;
        }
        Node3.prototype = hierarchy.prototype = {
          constructor: Node3,
          count: node_count,
          each: node_each,
          eachAfter: node_eachAfter,
          eachBefore: node_eachBefore,
          sum: node_sum,
          sort: node_sort,
          path: node_path,
          ancestors: node_ancestors,
          descendants: node_descendants,
          leaves: node_leaves,
          links: node_links,
          copy: node_copy
        };
        var slice = Array.prototype.slice;
        function shuffle(array2) {
          var m = array2.length, t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array2[m];
            array2[m] = array2[i];
            array2[i] = t;
          }
          return array2;
        }
        function enclose(circles) {
          var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;
          while (i < n) {
            p = circles[i];
            if (e && enclosesWeak(e, p))
              ++i;
            else
              e = encloseBasis(B = extendBasis(B, p)), i = 0;
          }
          return e;
        }
        function extendBasis(B, p) {
          var i, j;
          if (enclosesWeakAll(p, B))
            return [p];
          for (i = 0; i < B.length; ++i) {
            if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
              return [B[i], p];
            }
          }
          for (i = 0; i < B.length - 1; ++i) {
            for (j = i + 1; j < B.length; ++j) {
              if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
                return [B[i], B[j], p];
              }
            }
          }
          throw new Error();
        }
        function enclosesNot(a, b) {
          var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
          return dr < 0 || dr * dr < dx * dx + dy * dy;
        }
        function enclosesWeak(a, b) {
          var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
          return dr > 0 && dr * dr > dx * dx + dy * dy;
        }
        function enclosesWeakAll(a, B) {
          for (var i = 0; i < B.length; ++i) {
            if (!enclosesWeak(a, B[i])) {
              return false;
            }
          }
          return true;
        }
        function encloseBasis(B) {
          switch (B.length) {
            case 1:
              return encloseBasis1(B[0]);
            case 2:
              return encloseBasis2(B[0], B[1]);
            case 3:
              return encloseBasis3(B[0], B[1], B[2]);
          }
        }
        function encloseBasis1(a) {
          return {
            x: a.x,
            y: a.y,
            r: a.r
          };
        }
        function encloseBasis2(a, b) {
          var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
          return {
            x: (x1 + x2 + x21 / l * r21) / 2,
            y: (y1 + y2 + y21 / l * r21) / 2,
            r: (l + r1 + r2) / 2
          };
        }
        function encloseBasis3(a, b, c) {
          var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
          return {
            x: x1 + xa + xb * r,
            y: y1 + ya + yb * r,
            r
          };
        }
        function place(b, a, c) {
          var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;
          if (d2) {
            a2 = a.r + c.r, a2 *= a2;
            b2 = b.r + c.r, b2 *= b2;
            if (a2 > b2) {
              x = (d2 + b2 - a2) / (2 * d2);
              y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
              c.x = b.x - x * dx - y * dy;
              c.y = b.y - x * dy + y * dx;
            } else {
              x = (d2 + a2 - b2) / (2 * d2);
              y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
              c.x = a.x + x * dx - y * dy;
              c.y = a.y + x * dy + y * dx;
            }
          } else {
            c.x = a.x + c.r;
            c.y = a.y;
          }
        }
        function intersects(a, b) {
          var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
          return dr > 0 && dr * dr > dx * dx + dy * dy;
        }
        function score(node) {
          var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
          return dx * dx + dy * dy;
        }
        function Node$1(circle) {
          this._ = circle;
          this.next = null;
          this.previous = null;
        }
        function packEnclose(circles) {
          if (!(n = circles.length))
            return 0;
          var a, b, c, n, aa, ca, i, j, k, sj, sk;
          a = circles[0], a.x = 0, a.y = 0;
          if (!(n > 1))
            return a.r;
          b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
          if (!(n > 2))
            return a.r + b.r;
          place(b, a, c = circles[2]);
          a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
          a.next = c.previous = b;
          b.next = a.previous = c;
          c.next = b.previous = a;
          pack:
            for (i = 3; i < n; ++i) {
              place(a._, b._, c = circles[i]), c = new Node$1(c);
              j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
              do {
                if (sj <= sk) {
                  if (intersects(j._, c._)) {
                    b = j, a.next = b, b.previous = a, --i;
                    continue pack;
                  }
                  sj += j._.r, j = j.next;
                } else {
                  if (intersects(k._, c._)) {
                    a = k, a.next = b, b.previous = a, --i;
                    continue pack;
                  }
                  sk += k._.r, k = k.previous;
                }
              } while (j !== k.next);
              c.previous = a, c.next = b, a.next = b.previous = b = c;
              aa = score(a);
              while ((c = c.next) !== b) {
                if ((ca = score(c)) < aa) {
                  a = c, aa = ca;
                }
              }
              b = a.next;
            }
          a = [b._], c = b;
          while ((c = c.next) !== b)
            a.push(c._);
          c = enclose(a);
          for (i = 0; i < n; ++i)
            a = circles[i], a.x -= c.x, a.y -= c.y;
          return c.r;
        }
        function siblings(circles) {
          packEnclose(circles);
          return circles;
        }
        function optional(f) {
          return f == null ? null : required(f);
        }
        function required(f) {
          if (typeof f !== "function")
            throw new Error();
          return f;
        }
        function constantZero() {
          return 0;
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function defaultRadius(d) {
          return Math.sqrt(d.value);
        }
        function index() {
          var radius = null, dx = 1, dy = 1, padding = constantZero;
          function pack(root2) {
            root2.x = dx / 2, root2.y = dy / 2;
            if (radius) {
              root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
            } else {
              root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
            }
            return root2;
          }
          pack.radius = function(x) {
            return arguments.length ? (radius = optional(x), pack) : radius;
          };
          pack.size = function(x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
          };
          pack.padding = function(x) {
            return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
          };
          return pack;
        }
        function radiusLeaf(radius) {
          return function(node) {
            if (!node.children) {
              node.r = Math.max(0, +radius(node) || 0);
            }
          };
        }
        function packChildren(padding, k) {
          return function(node) {
            if (children2 = node.children) {
              var children2, i, n = children2.length, r = padding(node) * k || 0, e;
              if (r)
                for (i = 0; i < n; ++i)
                  children2[i].r += r;
              e = packEnclose(children2);
              if (r)
                for (i = 0; i < n; ++i)
                  children2[i].r -= r;
              node.r = e + r;
            }
          };
        }
        function translateChild(k) {
          return function(node) {
            var parent = node.parent;
            node.r *= k;
            if (parent) {
              node.x = parent.x + k * node.x;
              node.y = parent.y + k * node.y;
            }
          };
        }
        function roundNode(node) {
          node.x0 = Math.round(node.x0);
          node.y0 = Math.round(node.y0);
          node.x1 = Math.round(node.x1);
          node.y1 = Math.round(node.y1);
        }
        function treemapDice(parent, x0, y0, x1, y1) {
          var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
          while (++i < n) {
            node = nodes[i], node.y0 = y0, node.y1 = y1;
            node.x0 = x0, node.x1 = x0 += node.value * k;
          }
        }
        function partition() {
          var dx = 1, dy = 1, padding = 0, round = false;
          function partition2(root2) {
            var n = root2.height + 1;
            root2.x0 = root2.y0 = padding;
            root2.x1 = dx;
            root2.y1 = dy / n;
            root2.eachBefore(positionNode(dy, n));
            if (round)
              root2.eachBefore(roundNode);
            return root2;
          }
          function positionNode(dy2, n) {
            return function(node) {
              if (node.children) {
                treemapDice(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
              }
              var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
              if (x1 < x0)
                x0 = x1 = (x0 + x1) / 2;
              if (y1 < y0)
                y0 = y1 = (y0 + y1) / 2;
              node.x0 = x0;
              node.y0 = y0;
              node.x1 = x1;
              node.y1 = y1;
            };
          }
          partition2.round = function(x) {
            return arguments.length ? (round = !!x, partition2) : round;
          };
          partition2.size = function(x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], partition2) : [dx, dy];
          };
          partition2.padding = function(x) {
            return arguments.length ? (padding = +x, partition2) : padding;
          };
          return partition2;
        }
        var keyPrefix = "$", preroot = { depth: -1 }, ambiguous = {};
        function defaultId(d) {
          return d.id;
        }
        function defaultParentId(d) {
          return d.parentId;
        }
        function stratify() {
          var id = defaultId, parentId = defaultParentId;
          function stratify2(data) {
            var d, i, n = data.length, root2, parent, node, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};
            for (i = 0; i < n; ++i) {
              d = data[i], node = nodes[i] = new Node3(d);
              if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
                nodeKey = keyPrefix + (node.id = nodeId);
                nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
              }
            }
            for (i = 0; i < n; ++i) {
              node = nodes[i], nodeId = parentId(data[i], i, data);
              if (nodeId == null || !(nodeId += "")) {
                if (root2)
                  throw new Error("multiple roots");
                root2 = node;
              } else {
                parent = nodeByKey[keyPrefix + nodeId];
                if (!parent)
                  throw new Error("missing: " + nodeId);
                if (parent === ambiguous)
                  throw new Error("ambiguous: " + nodeId);
                if (parent.children)
                  parent.children.push(node);
                else
                  parent.children = [node];
                node.parent = parent;
              }
            }
            if (!root2)
              throw new Error("no root");
            root2.parent = preroot;
            root2.eachBefore(function(node2) {
              node2.depth = node2.parent.depth + 1;
              --n;
            }).eachBefore(computeHeight);
            root2.parent = null;
            if (n > 0)
              throw new Error("cycle");
            return root2;
          }
          stratify2.id = function(x) {
            return arguments.length ? (id = required(x), stratify2) : id;
          };
          stratify2.parentId = function(x) {
            return arguments.length ? (parentId = required(x), stratify2) : parentId;
          };
          return stratify2;
        }
        function defaultSeparation$1(a, b) {
          return a.parent === b.parent ? 1 : 2;
        }
        function nextLeft(v) {
          var children2 = v.children;
          return children2 ? children2[0] : v.t;
        }
        function nextRight(v) {
          var children2 = v.children;
          return children2 ? children2[children2.length - 1] : v.t;
        }
        function moveSubtree(wm, wp, shift) {
          var change = shift / (wp.i - wm.i);
          wp.c -= change;
          wp.s += shift;
          wm.c += change;
          wp.z += shift;
          wp.m += shift;
        }
        function executeShifts(v) {
          var shift = 0, change = 0, children2 = v.children, i = children2.length, w;
          while (--i >= 0) {
            w = children2[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
          }
        }
        function nextAncestor(vim, v, ancestor) {
          return vim.a.parent === v.parent ? vim.a : ancestor;
        }
        function TreeNode(node, i) {
          this._ = node;
          this.parent = null;
          this.children = null;
          this.A = null;
          this.a = this;
          this.z = 0;
          this.m = 0;
          this.c = 0;
          this.s = 0;
          this.t = null;
          this.i = i;
        }
        TreeNode.prototype = Object.create(Node3.prototype);
        function treeRoot(root2) {
          var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n;
          while (node = nodes.pop()) {
            if (children2 = node._.children) {
              node.children = new Array(n = children2.length);
              for (i = n - 1; i >= 0; --i) {
                nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
                child.parent = node;
              }
            }
          }
          (tree2.parent = new TreeNode(null, 0)).children = [tree2];
          return tree2;
        }
        function tree() {
          var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;
          function tree2(root2) {
            var t = treeRoot(root2);
            t.eachAfter(firstWalk), t.parent.m = -t.z;
            t.eachBefore(secondWalk);
            if (nodeSize)
              root2.eachBefore(sizeNode);
            else {
              var left = root2, right = root2, bottom = root2;
              root2.eachBefore(function(node) {
                if (node.x < left.x)
                  left = node;
                if (node.x > right.x)
                  right = node;
                if (node.depth > bottom.depth)
                  bottom = node;
              });
              var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
              root2.eachBefore(function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
              });
            }
            return root2;
          }
          function firstWalk(v) {
            var children2 = v.children, siblings2 = v.parent.children, w = v.i ? siblings2[v.i - 1] : null;
            if (children2) {
              executeShifts(v);
              var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
              if (w) {
                v.z = w.z + separation(v._, w._);
                v.m = v.z - midpoint;
              } else {
                v.z = midpoint;
              }
            } else if (w) {
              v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings2[0]);
          }
          function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
          }
          function apportion(v, w, ancestor) {
            if (w) {
              var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
              while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
                vom = nextLeft(vom);
                vop = nextRight(vop);
                vop.a = v;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                  moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                  sip += shift;
                  sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
              }
              if (vim && !nextRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
              }
              if (vip && !nextLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v;
              }
            }
            return ancestor;
          }
          function sizeNode(node) {
            node.x *= dx;
            node.y = node.depth * dy;
          }
          tree2.separation = function(x) {
            return arguments.length ? (separation = x, tree2) : separation;
          };
          tree2.size = function(x) {
            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree2) : nodeSize ? null : [dx, dy];
          };
          tree2.nodeSize = function(x) {
            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree2) : nodeSize ? [dx, dy] : null;
          };
          return tree2;
        }
        function treemapSlice(parent, x0, y0, x1, y1) {
          var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
          while (++i < n) {
            node = nodes[i], node.x0 = x0, node.x1 = x1;
            node.y0 = y0, node.y1 = y0 += node.value * k;
          }
        }
        var phi = (1 + Math.sqrt(5)) / 2;
        function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
          var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
          while (i0 < n) {
            dx = x1 - x0, dy = y1 - y0;
            do
              sumValue = nodes[i1++].value;
            while (!sumValue && i1 < n);
            minValue = maxValue = sumValue;
            alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
            beta = sumValue * sumValue * alpha;
            minRatio = Math.max(maxValue / beta, beta / minValue);
            for (; i1 < n; ++i1) {
              sumValue += nodeValue = nodes[i1].value;
              if (nodeValue < minValue)
                minValue = nodeValue;
              if (nodeValue > maxValue)
                maxValue = nodeValue;
              beta = sumValue * sumValue * alpha;
              newRatio = Math.max(maxValue / beta, beta / minValue);
              if (newRatio > minRatio) {
                sumValue -= nodeValue;
                break;
              }
              minRatio = newRatio;
            }
            rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
            if (row.dice)
              treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
            else
              treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
            value -= sumValue, i0 = i1;
          }
          return rows;
        }
        var squarify = function custom(ratio) {
          function squarify2(parent, x0, y0, x1, y1) {
            squarifyRatio(ratio, parent, x0, y0, x1, y1);
          }
          squarify2.ratio = function(x) {
            return custom((x = +x) > 1 ? x : 1);
          };
          return squarify2;
        }(phi);
        function index$1() {
          var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
          function treemap(root2) {
            root2.x0 = root2.y0 = 0;
            root2.x1 = dx;
            root2.y1 = dy;
            root2.eachBefore(positionNode);
            paddingStack = [0];
            if (round)
              root2.eachBefore(roundNode);
            return root2;
          }
          function positionNode(node) {
            var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
            if (x1 < x0)
              x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0)
              y0 = y1 = (y0 + y1) / 2;
            node.x0 = x0;
            node.y0 = y0;
            node.x1 = x1;
            node.y1 = y1;
            if (node.children) {
              p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
              x0 += paddingLeft(node) - p;
              y0 += paddingTop(node) - p;
              x1 -= paddingRight(node) - p;
              y1 -= paddingBottom(node) - p;
              if (x1 < x0)
                x0 = x1 = (x0 + x1) / 2;
              if (y1 < y0)
                y0 = y1 = (y0 + y1) / 2;
              tile(node, x0, y0, x1, y1);
            }
          }
          treemap.round = function(x) {
            return arguments.length ? (round = !!x, treemap) : round;
          };
          treemap.size = function(x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
          };
          treemap.tile = function(x) {
            return arguments.length ? (tile = required(x), treemap) : tile;
          };
          treemap.padding = function(x) {
            return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
          };
          treemap.paddingInner = function(x) {
            return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
          };
          treemap.paddingOuter = function(x) {
            return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
          };
          treemap.paddingTop = function(x) {
            return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
          };
          treemap.paddingRight = function(x) {
            return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
          };
          treemap.paddingBottom = function(x) {
            return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
          };
          treemap.paddingLeft = function(x) {
            return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
          };
          return treemap;
        }
        function binary(parent, x0, y0, x1, y1) {
          var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
          for (sums[0] = sum = i = 0; i < n; ++i) {
            sums[i + 1] = sum += nodes[i].value;
          }
          partition2(0, n, parent.value, x0, y0, x1, y1);
          function partition2(i2, j, value, x02, y02, x12, y12) {
            if (i2 >= j - 1) {
              var node = nodes[i2];
              node.x0 = x02, node.y0 = y02;
              node.x1 = x12, node.y1 = y12;
              return;
            }
            var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k = i2 + 1, hi = j - 1;
            while (k < hi) {
              var mid = k + hi >>> 1;
              if (sums[mid] < valueTarget)
                k = mid + 1;
              else
                hi = mid;
            }
            if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
              --k;
            var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
            if (x12 - x02 > y12 - y02) {
              var xk = (x02 * valueRight + x12 * valueLeft) / value;
              partition2(i2, k, valueLeft, x02, y02, xk, y12);
              partition2(k, j, valueRight, xk, y02, x12, y12);
            } else {
              var yk = (y02 * valueRight + y12 * valueLeft) / value;
              partition2(i2, k, valueLeft, x02, y02, x12, yk);
              partition2(k, j, valueRight, x02, yk, x12, y12);
            }
          }
        }
        function sliceDice(parent, x0, y0, x1, y1) {
          (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
        }
        var resquarify = function custom(ratio) {
          function resquarify2(parent, x0, y0, x1, y1) {
            if ((rows = parent._squarify) && rows.ratio === ratio) {
              var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
              while (++j < m) {
                row = rows[j], nodes = row.children;
                for (i = row.value = 0, n = nodes.length; i < n; ++i)
                  row.value += nodes[i].value;
                if (row.dice)
                  treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
                else
                  treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
                value -= row.value;
              }
            } else {
              parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
              rows.ratio = ratio;
            }
          }
          resquarify2.ratio = function(x) {
            return custom((x = +x) > 1 ? x : 1);
          };
          return resquarify2;
        }(phi);
        exports2.cluster = cluster;
        exports2.hierarchy = hierarchy;
        exports2.pack = index;
        exports2.packEnclose = enclose;
        exports2.packSiblings = siblings;
        exports2.partition = partition;
        exports2.stratify = stratify;
        exports2.tree = tree;
        exports2.treemap = index$1;
        exports2.treemapBinary = binary;
        exports2.treemapDice = treemapDice;
        exports2.treemapResquarify = resquarify;
        exports2.treemapSlice = treemapSlice;
        exports2.treemapSliceDice = sliceDice;
        exports2.treemapSquarify = squarify;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-polygon/dist/d3-polygon.js
  var require_d3_polygon = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-polygon/dist/d3-polygon.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function area(polygon) {
          var i = -1, n = polygon.length, a, b = polygon[n - 1], area2 = 0;
          while (++i < n) {
            a = b;
            b = polygon[i];
            area2 += a[1] * b[0] - a[0] * b[1];
          }
          return area2 / 2;
        }
        function centroid(polygon) {
          var i = -1, n = polygon.length, x = 0, y = 0, a, b = polygon[n - 1], c, k = 0;
          while (++i < n) {
            a = b;
            b = polygon[i];
            k += c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
          }
          return k *= 3, [x / k, y / k];
        }
        function cross(a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
        }
        function lexicographicOrder(a, b) {
          return a[0] - b[0] || a[1] - b[1];
        }
        function computeUpperHullIndexes(points) {
          var n = points.length, indexes = [0, 1], size = 2;
          for (var i = 2; i < n; ++i) {
            while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0)
              --size;
            indexes[size++] = i;
          }
          return indexes.slice(0, size);
        }
        function hull(points) {
          if ((n = points.length) < 3)
            return null;
          var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
          for (i = 0; i < n; ++i)
            sortedPoints[i] = [+points[i][0], +points[i][1], i];
          sortedPoints.sort(lexicographicOrder);
          for (i = 0; i < n; ++i)
            flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
          var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
          var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];
          for (i = upperIndexes.length - 1; i >= 0; --i)
            hull2.push(points[sortedPoints[upperIndexes[i]][2]]);
          for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
            hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);
          return hull2;
        }
        function contains(polygon, point) {
          var n = polygon.length, p = polygon[n - 1], x = point[0], y = point[1], x0 = p[0], y0 = p[1], x1, y1, inside = false;
          for (var i = 0; i < n; ++i) {
            p = polygon[i], x1 = p[0], y1 = p[1];
            if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)
              inside = !inside;
            x0 = x1, y0 = y1;
          }
          return inside;
        }
        function length(polygon) {
          var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
          while (++i < n) {
            xa = xb;
            ya = yb;
            b = polygon[i];
            xb = b[0];
            yb = b[1];
            xa -= xb;
            ya -= yb;
            perimeter += Math.sqrt(xa * xa + ya * ya);
          }
          return perimeter;
        }
        exports2.polygonArea = area;
        exports2.polygonCentroid = centroid;
        exports2.polygonContains = contains;
        exports2.polygonHull = hull;
        exports2.polygonLength = length;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-random/dist/d3-random.js
  var require_d3_random = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-random/dist/d3-random.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        function defaultSource() {
          return Math.random();
        }
        var uniform = function sourceRandomUniform(source) {
          function randomUniform(min, max) {
            min = min == null ? 0 : +min;
            max = max == null ? 1 : +max;
            if (arguments.length === 1)
              max = min, min = 0;
            else
              max -= min;
            return function() {
              return source() * max + min;
            };
          }
          randomUniform.source = sourceRandomUniform;
          return randomUniform;
        }(defaultSource);
        var normal = function sourceRandomNormal(source) {
          function randomNormal(mu, sigma) {
            var x, r;
            mu = mu == null ? 0 : +mu;
            sigma = sigma == null ? 1 : +sigma;
            return function() {
              var y;
              if (x != null)
                y = x, x = null;
              else
                do {
                  x = source() * 2 - 1;
                  y = source() * 2 - 1;
                  r = x * x + y * y;
                } while (!r || r > 1);
              return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
            };
          }
          randomNormal.source = sourceRandomNormal;
          return randomNormal;
        }(defaultSource);
        var logNormal = function sourceRandomLogNormal(source) {
          function randomLogNormal() {
            var randomNormal = normal.source(source).apply(this, arguments);
            return function() {
              return Math.exp(randomNormal());
            };
          }
          randomLogNormal.source = sourceRandomLogNormal;
          return randomLogNormal;
        }(defaultSource);
        var irwinHall = function sourceRandomIrwinHall(source) {
          function randomIrwinHall(n) {
            return function() {
              for (var sum = 0, i = 0; i < n; ++i)
                sum += source();
              return sum;
            };
          }
          randomIrwinHall.source = sourceRandomIrwinHall;
          return randomIrwinHall;
        }(defaultSource);
        var bates = function sourceRandomBates(source) {
          function randomBates(n) {
            var randomIrwinHall = irwinHall.source(source)(n);
            return function() {
              return randomIrwinHall() / n;
            };
          }
          randomBates.source = sourceRandomBates;
          return randomBates;
        }(defaultSource);
        var exponential = function sourceRandomExponential(source) {
          function randomExponential(lambda) {
            return function() {
              return -Math.log(1 - source()) / lambda;
            };
          }
          randomExponential.source = sourceRandomExponential;
          return randomExponential;
        }(defaultSource);
        exports2.randomUniform = uniform;
        exports2.randomNormal = normal;
        exports2.randomLogNormal = logNormal;
        exports2.randomBates = bates;
        exports2.randomIrwinHall = irwinHall;
        exports2.randomExponential = exponential;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-time/dist/d3-time.js
  var require_d3_time = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-time/dist/d3-time.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var t0 = new Date(), t1 = new Date();
        function newInterval(floori, offseti, count, field) {
          function interval(date) {
            return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
          }
          interval.floor = function(date) {
            return floori(date = new Date(+date)), date;
          };
          interval.ceil = function(date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
          };
          interval.round = function(date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
          };
          interval.offset = function(date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
          };
          interval.range = function(start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
              return range;
            do
              range.push(previous = new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
          };
          interval.filter = function(test) {
            return newInterval(function(date) {
              if (date >= date)
                while (floori(date), !test(date))
                  date.setTime(date - 1);
            }, function(date, step) {
              if (date >= date) {
                if (step < 0)
                  while (++step <= 0) {
                    while (offseti(date, -1), !test(date)) {
                    }
                  }
                else
                  while (--step >= 0) {
                    while (offseti(date, 1), !test(date)) {
                    }
                  }
              }
            });
          };
          if (count) {
            interval.count = function(start, end) {
              t0.setTime(+start), t1.setTime(+end);
              floori(t0), floori(t1);
              return Math.floor(count(t0, t1));
            };
            interval.every = function(step) {
              step = Math.floor(step);
              return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                return field(d) % step === 0;
              } : function(d) {
                return interval.count(0, d) % step === 0;
              });
            };
          }
          return interval;
        }
        var millisecond = newInterval(function() {
        }, function(date, step) {
          date.setTime(+date + step);
        }, function(start, end) {
          return end - start;
        });
        millisecond.every = function(k) {
          k = Math.floor(k);
          if (!isFinite(k) || !(k > 0))
            return null;
          if (!(k > 1))
            return millisecond;
          return newInterval(function(date) {
            date.setTime(Math.floor(date / k) * k);
          }, function(date, step) {
            date.setTime(+date + step * k);
          }, function(start, end) {
            return (end - start) / k;
          });
        };
        var milliseconds = millisecond.range;
        var durationSecond = 1e3;
        var durationMinute = 6e4;
        var durationHour = 36e5;
        var durationDay = 864e5;
        var durationWeek = 6048e5;
        var second = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds());
        }, function(date, step) {
          date.setTime(+date + step * durationSecond);
        }, function(start, end) {
          return (end - start) / durationSecond;
        }, function(date) {
          return date.getUTCSeconds();
        });
        var seconds = second.range;
        var minute = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getMinutes();
        });
        var minutes = minute.range;
        var hour = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getHours();
        });
        var hours = hour.range;
        var day = newInterval(function(date) {
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setDate(date.getDate() + step);
        }, function(start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
        }, function(date) {
          return date.getDate() - 1;
        });
        var days = day.range;
        function weekday(i) {
          return newInterval(function(date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setDate(date.getDate() + step * 7);
          }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
          });
        }
        var sunday = weekday(0);
        var monday = weekday(1);
        var tuesday = weekday(2);
        var wednesday = weekday(3);
        var thursday = weekday(4);
        var friday = weekday(5);
        var saturday = weekday(6);
        var sundays = sunday.range;
        var mondays = monday.range;
        var tuesdays = tuesday.range;
        var wednesdays = wednesday.range;
        var thursdays = thursday.range;
        var fridays = friday.range;
        var saturdays = saturday.range;
        var month = newInterval(function(date) {
          date.setDate(1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setMonth(date.getMonth() + step);
        }, function(start, end) {
          return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
        }, function(date) {
          return date.getMonth();
        });
        var months = month.range;
        var year = newInterval(function(date) {
          date.setMonth(0, 1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setFullYear(date.getFullYear() + step);
        }, function(start, end) {
          return end.getFullYear() - start.getFullYear();
        }, function(date) {
          return date.getFullYear();
        });
        year.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setFullYear(date.getFullYear() + step * k);
          });
        };
        var years = year.range;
        var utcMinute = newInterval(function(date) {
          date.setUTCSeconds(0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getUTCMinutes();
        });
        var utcMinutes = utcMinute.range;
        var utcHour = newInterval(function(date) {
          date.setUTCMinutes(0, 0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getUTCHours();
        });
        var utcHours = utcHour.range;
        var utcDay = newInterval(function(date) {
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCDate(date.getUTCDate() + step);
        }, function(start, end) {
          return (end - start) / durationDay;
        }, function(date) {
          return date.getUTCDate() - 1;
        });
        var utcDays = utcDay.range;
        function utcWeekday(i) {
          return newInterval(function(date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
          }, function(start, end) {
            return (end - start) / durationWeek;
          });
        }
        var utcSunday = utcWeekday(0);
        var utcMonday = utcWeekday(1);
        var utcTuesday = utcWeekday(2);
        var utcWednesday = utcWeekday(3);
        var utcThursday = utcWeekday(4);
        var utcFriday = utcWeekday(5);
        var utcSaturday = utcWeekday(6);
        var utcSundays = utcSunday.range;
        var utcMondays = utcMonday.range;
        var utcTuesdays = utcTuesday.range;
        var utcWednesdays = utcWednesday.range;
        var utcThursdays = utcThursday.range;
        var utcFridays = utcFriday.range;
        var utcSaturdays = utcSaturday.range;
        var utcMonth = newInterval(function(date) {
          date.setUTCDate(1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCMonth(date.getUTCMonth() + step);
        }, function(start, end) {
          return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
        }, function(date) {
          return date.getUTCMonth();
        });
        var utcMonths = utcMonth.range;
        var utcYear = newInterval(function(date) {
          date.setUTCMonth(0, 1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCFullYear(date.getUTCFullYear() + step);
        }, function(start, end) {
          return end.getUTCFullYear() - start.getUTCFullYear();
        }, function(date) {
          return date.getUTCFullYear();
        });
        utcYear.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
          });
        };
        var utcYears = utcYear.range;
        exports2.timeDay = day;
        exports2.timeDays = days;
        exports2.timeFriday = friday;
        exports2.timeFridays = fridays;
        exports2.timeHour = hour;
        exports2.timeHours = hours;
        exports2.timeInterval = newInterval;
        exports2.timeMillisecond = millisecond;
        exports2.timeMilliseconds = milliseconds;
        exports2.timeMinute = minute;
        exports2.timeMinutes = minutes;
        exports2.timeMonday = monday;
        exports2.timeMondays = mondays;
        exports2.timeMonth = month;
        exports2.timeMonths = months;
        exports2.timeSaturday = saturday;
        exports2.timeSaturdays = saturdays;
        exports2.timeSecond = second;
        exports2.timeSeconds = seconds;
        exports2.timeSunday = sunday;
        exports2.timeSundays = sundays;
        exports2.timeThursday = thursday;
        exports2.timeThursdays = thursdays;
        exports2.timeTuesday = tuesday;
        exports2.timeTuesdays = tuesdays;
        exports2.timeWednesday = wednesday;
        exports2.timeWednesdays = wednesdays;
        exports2.timeWeek = sunday;
        exports2.timeWeeks = sundays;
        exports2.timeYear = year;
        exports2.timeYears = years;
        exports2.utcDay = utcDay;
        exports2.utcDays = utcDays;
        exports2.utcFriday = utcFriday;
        exports2.utcFridays = utcFridays;
        exports2.utcHour = utcHour;
        exports2.utcHours = utcHours;
        exports2.utcMillisecond = millisecond;
        exports2.utcMilliseconds = milliseconds;
        exports2.utcMinute = utcMinute;
        exports2.utcMinutes = utcMinutes;
        exports2.utcMonday = utcMonday;
        exports2.utcMondays = utcMondays;
        exports2.utcMonth = utcMonth;
        exports2.utcMonths = utcMonths;
        exports2.utcSaturday = utcSaturday;
        exports2.utcSaturdays = utcSaturdays;
        exports2.utcSecond = second;
        exports2.utcSeconds = seconds;
        exports2.utcSunday = utcSunday;
        exports2.utcSundays = utcSundays;
        exports2.utcThursday = utcThursday;
        exports2.utcThursdays = utcThursdays;
        exports2.utcTuesday = utcTuesday;
        exports2.utcTuesdays = utcTuesdays;
        exports2.utcWednesday = utcWednesday;
        exports2.utcWednesdays = utcWednesdays;
        exports2.utcWeek = utcSunday;
        exports2.utcWeeks = utcSundays;
        exports2.utcYear = utcYear;
        exports2.utcYears = utcYears;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-time-format/dist/d3-time-format.js
  var require_d3_time_format = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-time-format/dist/d3-time-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_time()) : typeof define === "function" && define.amd ? define(["exports", "d3-time"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Time) {
        "use strict";
        function localDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
          }
          return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
        }
        function utcDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
          }
          return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
        }
        function newDate(y, m, d) {
          return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
        }
        function formatLocale(locale2) {
          var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
          var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
          var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            "e": formatDayOfMonth,
            "f": formatMicroseconds,
            "g": formatYearISO,
            "G": formatFullYearISO,
            "H": formatHour24,
            "I": formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            "m": formatMonthNumber,
            "M": formatMinutes,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            "V": formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            "W": formatWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatYear,
            "Y": formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
          };
          var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            "f": formatUTCMicroseconds,
            "g": formatUTCYearISO,
            "G": formatUTCFullYearISO,
            "H": formatUTCHour24,
            "I": formatUTCHour12,
            "j": formatUTCDayOfYear,
            "L": formatUTCMilliseconds,
            "m": formatUTCMonthNumber,
            "M": formatUTCMinutes,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            "u": formatUTCWeekdayNumberMonday,
            "U": formatUTCWeekNumberSunday,
            "V": formatUTCWeekNumberISO,
            "w": formatUTCWeekdayNumberSunday,
            "W": formatUTCWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatUTCYear,
            "Y": formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
          };
          var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth,
            "e": parseDayOfMonth,
            "f": parseMicroseconds,
            "g": parseYear,
            "G": parseFullYear,
            "H": parseHour24,
            "I": parseHour24,
            "j": parseDayOfYear,
            "L": parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            "p": parsePeriod,
            "q": parseQuarter,
            "Q": parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            "u": parseWeekdayNumberMonday,
            "U": parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
          };
          formats.x = newFormat(locale_date, formats);
          formats.X = newFormat(locale_time, formats);
          formats.c = newFormat(locale_dateTime, formats);
          utcFormats.x = newFormat(locale_date, utcFormats);
          utcFormats.X = newFormat(locale_time, utcFormats);
          utcFormats.c = newFormat(locale_dateTime, utcFormats);
          function newFormat(specifier, formats2) {
            return function(date) {
              var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format;
              if (!(date instanceof Date))
                date = new Date(+date);
              while (++i < n) {
                if (specifier.charCodeAt(i) === 37) {
                  string.push(specifier.slice(j, i));
                  if ((pad2 = pads[c = specifier.charAt(++i)]) != null)
                    c = specifier.charAt(++i);
                  else
                    pad2 = c === "e" ? " " : "0";
                  if (format = formats2[c])
                    c = format(date, pad2);
                  string.push(c);
                  j = i + 1;
                }
              }
              string.push(specifier.slice(j, i));
              return string.join("");
            };
          }
          function newParse(specifier, Z) {
            return function(string) {
              var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
              if (i != string.length)
                return null;
              if ("Q" in d)
                return new Date(d.Q);
              if ("s" in d)
                return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
              if (Z && !("Z" in d))
                d.Z = 0;
              if ("p" in d)
                d.H = d.H % 12 + d.p * 12;
              if (d.m === void 0)
                d.m = "q" in d ? d.q : 0;
              if ("V" in d) {
                if (d.V < 1 || d.V > 53)
                  return null;
                if (!("w" in d))
                  d.w = 1;
                if ("Z" in d) {
                  week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                  week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
                  week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getUTCFullYear();
                  d.m = week.getUTCMonth();
                  d.d = week.getUTCDate() + (d.w + 6) % 7;
                } else {
                  week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                  week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
                  week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getFullYear();
                  d.m = week.getMonth();
                  d.d = week.getDate() + (d.w + 6) % 7;
                }
              } else if ("W" in d || "U" in d) {
                if (!("w" in d))
                  d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
              }
              if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
              }
              return localDate(d);
            };
          }
          function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse2;
            while (i < n) {
              if (j >= m)
                return -1;
              c = specifier.charCodeAt(i++);
              if (c === 37) {
                c = specifier.charAt(i++);
                parse2 = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse2 || (j = parse2(d, string, j)) < 0)
                  return -1;
              } else if (c != string.charCodeAt(j++)) {
                return -1;
              }
            }
            return j;
          }
          function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
          }
          function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
          }
          function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
          }
          function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
          }
          function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
          }
          function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
          }
          function formatMonth(d) {
            return locale_months[d.getMonth()];
          }
          function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
          }
          function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
          }
          function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
          }
          function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
          }
          function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
          }
          function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
          }
          function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
          }
          function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
          }
          return {
            format: function(specifier) {
              var f = newFormat(specifier += "", formats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            parse: function(specifier) {
              var p = newParse(specifier += "", false);
              p.toString = function() {
                return specifier;
              };
              return p;
            },
            utcFormat: function(specifier) {
              var f = newFormat(specifier += "", utcFormats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            utcParse: function(specifier) {
              var p = newParse(specifier += "", true);
              p.toString = function() {
                return specifier;
              };
              return p;
            }
          };
        }
        var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
        function pad(value, fill, width) {
          var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
          return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function requote(s) {
          return s.replace(requoteRe, "\\$&");
        }
        function formatRe(names) {
          return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
        }
        function formatLookup(names) {
          var map = {}, i = -1, n = names.length;
          while (++i < n)
            map[names[i].toLowerCase()] = i;
          return map;
        }
        function parseWeekdayNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.w = +n[0], i + n[0].length) : -1;
        }
        function parseWeekdayNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.u = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.U = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberISO(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.V = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.W = +n[0], i + n[0].length) : -1;
        }
        function parseFullYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 4));
          return n ? (d.y = +n[0], i + n[0].length) : -1;
        }
        function parseYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
        }
        function parseZone(d, string, i) {
          var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
          return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
        }
        function parseQuarter(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
        }
        function parseMonthNumber(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
        }
        function parseDayOfMonth(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.d = +n[0], i + n[0].length) : -1;
        }
        function parseDayOfYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
        }
        function parseHour24(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.H = +n[0], i + n[0].length) : -1;
        }
        function parseMinutes(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.M = +n[0], i + n[0].length) : -1;
        }
        function parseSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.S = +n[0], i + n[0].length) : -1;
        }
        function parseMilliseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.L = +n[0], i + n[0].length) : -1;
        }
        function parseMicroseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 6));
          return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
        }
        function parseLiteralPercent(d, string, i) {
          var n = percentRe.exec(string.slice(i, i + 1));
          return n ? i + n[0].length : -1;
        }
        function parseUnixTimestamp(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.Q = +n[0], i + n[0].length) : -1;
        }
        function parseUnixTimestampSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.s = +n[0], i + n[0].length) : -1;
        }
        function formatDayOfMonth(d, p) {
          return pad(d.getDate(), p, 2);
        }
        function formatHour24(d, p) {
          return pad(d.getHours(), p, 2);
        }
        function formatHour12(d, p) {
          return pad(d.getHours() % 12 || 12, p, 2);
        }
        function formatDayOfYear(d, p) {
          return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
        }
        function formatMilliseconds(d, p) {
          return pad(d.getMilliseconds(), p, 3);
        }
        function formatMicroseconds(d, p) {
          return formatMilliseconds(d, p) + "000";
        }
        function formatMonthNumber(d, p) {
          return pad(d.getMonth() + 1, p, 2);
        }
        function formatMinutes(d, p) {
          return pad(d.getMinutes(), p, 2);
        }
        function formatSeconds(d, p) {
          return pad(d.getSeconds(), p, 2);
        }
        function formatWeekdayNumberMonday(d) {
          var day = d.getDay();
          return day === 0 ? 7 : day;
        }
        function formatWeekNumberSunday(d, p) {
          return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function dISO(d) {
          var day = d.getDay();
          return day >= 4 || day === 0 ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
        }
        function formatWeekNumberISO(d, p) {
          d = dISO(d);
          return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
        }
        function formatWeekdayNumberSunday(d) {
          return d.getDay();
        }
        function formatWeekNumberMonday(d, p) {
          return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatYear(d, p) {
          return pad(d.getFullYear() % 100, p, 2);
        }
        function formatYearISO(d, p) {
          d = dISO(d);
          return pad(d.getFullYear() % 100, p, 2);
        }
        function formatFullYear(d, p) {
          return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatFullYearISO(d, p) {
          var day = d.getDay();
          d = day >= 4 || day === 0 ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
          return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatZone(d) {
          var z = d.getTimezoneOffset();
          return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
        }
        function formatUTCDayOfMonth(d, p) {
          return pad(d.getUTCDate(), p, 2);
        }
        function formatUTCHour24(d, p) {
          return pad(d.getUTCHours(), p, 2);
        }
        function formatUTCHour12(d, p) {
          return pad(d.getUTCHours() % 12 || 12, p, 2);
        }
        function formatUTCDayOfYear(d, p) {
          return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
        }
        function formatUTCMilliseconds(d, p) {
          return pad(d.getUTCMilliseconds(), p, 3);
        }
        function formatUTCMicroseconds(d, p) {
          return formatUTCMilliseconds(d, p) + "000";
        }
        function formatUTCMonthNumber(d, p) {
          return pad(d.getUTCMonth() + 1, p, 2);
        }
        function formatUTCMinutes(d, p) {
          return pad(d.getUTCMinutes(), p, 2);
        }
        function formatUTCSeconds(d, p) {
          return pad(d.getUTCSeconds(), p, 2);
        }
        function formatUTCWeekdayNumberMonday(d) {
          var dow = d.getUTCDay();
          return dow === 0 ? 7 : dow;
        }
        function formatUTCWeekNumberSunday(d, p) {
          return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function UTCdISO(d) {
          var day = d.getUTCDay();
          return day >= 4 || day === 0 ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
        }
        function formatUTCWeekNumberISO(d, p) {
          d = UTCdISO(d);
          return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
        }
        function formatUTCWeekdayNumberSunday(d) {
          return d.getUTCDay();
        }
        function formatUTCWeekNumberMonday(d, p) {
          return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCYear(d, p) {
          return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCYearISO(d, p) {
          d = UTCdISO(d);
          return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCFullYear(d, p) {
          return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCFullYearISO(d, p) {
          var day = d.getUTCDay();
          d = day >= 4 || day === 0 ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
          return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCZone() {
          return "+0000";
        }
        function formatLiteralPercent() {
          return "%";
        }
        function formatUnixTimestamp(d) {
          return +d;
        }
        function formatUnixTimestampSeconds(d) {
          return Math.floor(+d / 1e3);
        }
        var locale;
        defaultLocale({
          dateTime: "%x, %X",
          date: "%-m/%-d/%Y",
          time: "%-I:%M:%S %p",
          periods: ["AM", "PM"],
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.timeFormat = locale.format;
          exports2.timeParse = locale.parse;
          exports2.utcFormat = locale.utcFormat;
          exports2.utcParse = locale.utcParse;
          return locale;
        }
        var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
        function formatIsoNative(date) {
          return date.toISOString();
        }
        var formatIso = Date.prototype.toISOString ? formatIsoNative : exports2.utcFormat(isoSpecifier);
        function parseIsoNative(string) {
          var date = new Date(string);
          return isNaN(date) ? null : date;
        }
        var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports2.utcParse(isoSpecifier);
        exports2.isoFormat = formatIso;
        exports2.isoParse = parseIso;
        exports2.timeFormatDefaultLocale = defaultLocale;
        exports2.timeFormatLocale = formatLocale;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-scale/dist/d3-scale.js
  var require_d3_scale = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-scale/dist/d3-scale.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_collection(), require_d3_array(), require_d3_interpolate(), require_d3_format(), require_d3_time(), require_d3_time_format()) : typeof define === "function" && define.amd ? define(["exports", "d3-collection", "d3-array", "d3-interpolate", "d3-format", "d3-time", "d3-time-format"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3);
      })(exports, function(exports2, d3Collection, d3Array, d3Interpolate, d3Format, d3Time, d3TimeFormat) {
        "use strict";
        function initRange(domain, range) {
          switch (arguments.length) {
            case 0:
              break;
            case 1:
              this.range(domain);
              break;
            default:
              this.range(range).domain(domain);
              break;
          }
          return this;
        }
        function initInterpolator(domain, interpolator) {
          switch (arguments.length) {
            case 0:
              break;
            case 1:
              this.interpolator(domain);
              break;
            default:
              this.interpolator(interpolator).domain(domain);
              break;
          }
          return this;
        }
        var array2 = Array.prototype;
        var map = array2.map;
        var slice = array2.slice;
        var implicit = { name: "implicit" };
        function ordinal() {
          var index = d3Collection.map(), domain = [], range = [], unknown = implicit;
          function scale(d) {
            var key = d + "", i = index.get(key);
            if (!i) {
              if (unknown !== implicit)
                return unknown;
              index.set(key, i = domain.push(d));
            }
            return range[(i - 1) % range.length];
          }
          scale.domain = function(_) {
            if (!arguments.length)
              return domain.slice();
            domain = [], index = d3Collection.map();
            var i = -1, n = _.length, d, key;
            while (++i < n)
              if (!index.has(key = (d = _[i]) + ""))
                index.set(key, domain.push(d));
            return scale;
          };
          scale.range = function(_) {
            return arguments.length ? (range = slice.call(_), scale) : range.slice();
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          scale.copy = function() {
            return ordinal(domain, range).unknown(unknown);
          };
          initRange.apply(scale, arguments);
          return scale;
        }
        function band() {
          var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, range = [0, 1], step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
          delete scale.unknown;
          function rescale() {
            var n = domain().length, reverse = range[1] < range[0], start = range[reverse - 0], stop = range[1 - reverse];
            step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
            if (round)
              step = Math.floor(step);
            start += (stop - start - step * (n - paddingInner)) * align;
            bandwidth = step * (1 - paddingInner);
            if (round)
              start = Math.round(start), bandwidth = Math.round(bandwidth);
            var values = d3Array.range(n).map(function(i) {
              return start + step * i;
            });
            return ordinalRange(reverse ? values.reverse() : values);
          }
          scale.domain = function(_) {
            return arguments.length ? (domain(_), rescale()) : domain();
          };
          scale.range = function(_) {
            return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
          };
          scale.rangeRound = function(_) {
            return range = [+_[0], +_[1]], round = true, rescale();
          };
          scale.bandwidth = function() {
            return bandwidth;
          };
          scale.step = function() {
            return step;
          };
          scale.round = function(_) {
            return arguments.length ? (round = !!_, rescale()) : round;
          };
          scale.padding = function(_) {
            return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
          };
          scale.paddingInner = function(_) {
            return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
          };
          scale.paddingOuter = function(_) {
            return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
          };
          scale.align = function(_) {
            return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
          };
          scale.copy = function() {
            return band(domain(), range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
          };
          return initRange.apply(rescale(), arguments);
        }
        function pointish(scale) {
          var copy2 = scale.copy;
          scale.padding = scale.paddingOuter;
          delete scale.paddingInner;
          delete scale.paddingOuter;
          scale.copy = function() {
            return pointish(copy2());
          };
          return scale;
        }
        function point() {
          return pointish(band.apply(null, arguments).paddingInner(1));
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function number(x) {
          return +x;
        }
        var unit = [0, 1];
        function identity(x) {
          return x;
        }
        function normalize(a, b) {
          return (b -= a = +a) ? function(x) {
            return (x - a) / b;
          } : constant(isNaN(b) ? NaN : 0.5);
        }
        function clamper(domain) {
          var a = domain[0], b = domain[domain.length - 1], t;
          if (a > b)
            t = a, a = b, b = t;
          return function(x) {
            return Math.max(a, Math.min(b, x));
          };
        }
        function bimap(domain, range, interpolate) {
          var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
          if (d1 < d0)
            d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
          else
            d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
          return function(x) {
            return r0(d0(x));
          };
        }
        function polymap(domain, range, interpolate) {
          var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
          if (domain[j] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
          }
          while (++i < j) {
            d[i] = normalize(domain[i], domain[i + 1]);
            r[i] = interpolate(range[i], range[i + 1]);
          }
          return function(x) {
            var i2 = d3Array.bisect(domain, x, 1, j) - 1;
            return r[i2](d[i2](x));
          };
        }
        function copy(source, target) {
          return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
        }
        function transformer() {
          var domain = unit, range = unit, interpolate = d3Interpolate.interpolate, transform, untransform, unknown, clamp = identity, piecewise, output, input;
          function rescale() {
            piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
            output = input = null;
            return scale;
          }
          function scale(x) {
            return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
          }
          scale.invert = function(y) {
            return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
          };
          scale.domain = function(_) {
            return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
          };
          scale.range = function(_) {
            return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
          };
          scale.rangeRound = function(_) {
            return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
          };
          scale.clamp = function(_) {
            return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
          };
          scale.interpolate = function(_) {
            return arguments.length ? (interpolate = _, rescale()) : interpolate;
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          return function(t, u) {
            transform = t, untransform = u;
            return rescale();
          };
        }
        function continuous(transform, untransform) {
          return transformer()(transform, untransform);
        }
        function tickFormat(start, stop, count, specifier) {
          var step = d3Array.tickStep(start, stop, count), precision;
          specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
          switch (specifier.type) {
            case "s": {
              var value = Math.max(Math.abs(start), Math.abs(stop));
              if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value)))
                specifier.precision = precision;
              return d3Format.formatPrefix(specifier, value);
            }
            case "":
            case "e":
            case "g":
            case "p":
            case "r": {
              if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
                specifier.precision = precision - (specifier.type === "e");
              break;
            }
            case "f":
            case "%": {
              if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step)))
                specifier.precision = precision - (specifier.type === "%") * 2;
              break;
            }
          }
          return d3Format.format(specifier);
        }
        function linearish(scale) {
          var domain = scale.domain;
          scale.ticks = function(count) {
            var d = domain();
            return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
          };
          scale.tickFormat = function(count, specifier) {
            var d = domain();
            return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
          };
          scale.nice = function(count) {
            if (count == null)
              count = 10;
            var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step;
            if (stop < start) {
              step = start, start = stop, stop = step;
              step = i0, i0 = i1, i1 = step;
            }
            step = d3Array.tickIncrement(start, stop, count);
            if (step > 0) {
              start = Math.floor(start / step) * step;
              stop = Math.ceil(stop / step) * step;
              step = d3Array.tickIncrement(start, stop, count);
            } else if (step < 0) {
              start = Math.ceil(start * step) / step;
              stop = Math.floor(stop * step) / step;
              step = d3Array.tickIncrement(start, stop, count);
            }
            if (step > 0) {
              d[i0] = Math.floor(start / step) * step;
              d[i1] = Math.ceil(stop / step) * step;
              domain(d);
            } else if (step < 0) {
              d[i0] = Math.ceil(start * step) / step;
              d[i1] = Math.floor(stop * step) / step;
              domain(d);
            }
            return scale;
          };
          return scale;
        }
        function linear() {
          var scale = continuous(identity, identity);
          scale.copy = function() {
            return copy(scale, linear());
          };
          initRange.apply(scale, arguments);
          return linearish(scale);
        }
        function identity$1(domain) {
          var unknown;
          function scale(x) {
            return isNaN(x = +x) ? unknown : x;
          }
          scale.invert = scale;
          scale.domain = scale.range = function(_) {
            return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          scale.copy = function() {
            return identity$1(domain).unknown(unknown);
          };
          domain = arguments.length ? map.call(domain, number) : [0, 1];
          return linearish(scale);
        }
        function nice(domain, interval) {
          domain = domain.slice();
          var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
          if (x1 < x0) {
            t = i0, i0 = i1, i1 = t;
            t = x0, x0 = x1, x1 = t;
          }
          domain[i0] = interval.floor(x0);
          domain[i1] = interval.ceil(x1);
          return domain;
        }
        function transformLog(x) {
          return Math.log(x);
        }
        function transformExp(x) {
          return Math.exp(x);
        }
        function transformLogn(x) {
          return -Math.log(-x);
        }
        function transformExpn(x) {
          return -Math.exp(-x);
        }
        function pow10(x) {
          return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
        }
        function powp(base) {
          return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x) {
            return Math.pow(base, x);
          };
        }
        function logp(base) {
          return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x) {
            return Math.log(x) / base;
          });
        }
        function reflect(f) {
          return function(x) {
            return -f(-x);
          };
        }
        function loggish(transform) {
          var scale = transform(transformLog, transformExp), domain = scale.domain, base = 10, logs, pows;
          function rescale() {
            logs = logp(base), pows = powp(base);
            if (domain()[0] < 0) {
              logs = reflect(logs), pows = reflect(pows);
              transform(transformLogn, transformExpn);
            } else {
              transform(transformLog, transformExp);
            }
            return scale;
          }
          scale.base = function(_) {
            return arguments.length ? (base = +_, rescale()) : base;
          };
          scale.domain = function(_) {
            return arguments.length ? (domain(_), rescale()) : domain();
          };
          scale.ticks = function(count) {
            var d = domain(), u = d[0], v = d[d.length - 1], r;
            if (r = v < u)
              i = u, u = v, v = i;
            var i = logs(u), j = logs(v), p, k, t, n = count == null ? 10 : +count, z = [];
            if (!(base % 1) && j - i < n) {
              i = Math.round(i) - 1, j = Math.round(j) + 1;
              if (u > 0)
                for (; i < j; ++i) {
                  for (k = 1, p = pows(i); k < base; ++k) {
                    t = p * k;
                    if (t < u)
                      continue;
                    if (t > v)
                      break;
                    z.push(t);
                  }
                }
              else
                for (; i < j; ++i) {
                  for (k = base - 1, p = pows(i); k >= 1; --k) {
                    t = p * k;
                    if (t < u)
                      continue;
                    if (t > v)
                      break;
                    z.push(t);
                  }
                }
            } else {
              z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
            }
            return r ? z.reverse() : z;
          };
          scale.tickFormat = function(count, specifier) {
            if (specifier == null)
              specifier = base === 10 ? ".0e" : ",";
            if (typeof specifier !== "function")
              specifier = d3Format.format(specifier);
            if (count === Infinity)
              return specifier;
            if (count == null)
              count = 10;
            var k = Math.max(1, base * count / scale.ticks().length);
            return function(d) {
              var i = d / pows(Math.round(logs(d)));
              if (i * base < base - 0.5)
                i *= base;
              return i <= k ? specifier(d) : "";
            };
          };
          scale.nice = function() {
            return domain(nice(domain(), {
              floor: function(x) {
                return pows(Math.floor(logs(x)));
              },
              ceil: function(x) {
                return pows(Math.ceil(logs(x)));
              }
            }));
          };
          return scale;
        }
        function log() {
          var scale = loggish(transformer()).domain([1, 10]);
          scale.copy = function() {
            return copy(scale, log()).base(scale.base());
          };
          initRange.apply(scale, arguments);
          return scale;
        }
        function transformSymlog(c) {
          return function(x) {
            return Math.sign(x) * Math.log1p(Math.abs(x / c));
          };
        }
        function transformSymexp(c) {
          return function(x) {
            return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
          };
        }
        function symlogish(transform) {
          var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));
          scale.constant = function(_) {
            return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
          };
          return linearish(scale);
        }
        function symlog() {
          var scale = symlogish(transformer());
          scale.copy = function() {
            return copy(scale, symlog()).constant(scale.constant());
          };
          return initRange.apply(scale, arguments);
        }
        function transformPow(exponent) {
          return function(x) {
            return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
          };
        }
        function transformSqrt(x) {
          return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
        }
        function transformSquare(x) {
          return x < 0 ? -x * x : x * x;
        }
        function powish(transform) {
          var scale = transform(identity, identity), exponent = 1;
          function rescale() {
            return exponent === 1 ? transform(identity, identity) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
          }
          scale.exponent = function(_) {
            return arguments.length ? (exponent = +_, rescale()) : exponent;
          };
          return linearish(scale);
        }
        function pow() {
          var scale = powish(transformer());
          scale.copy = function() {
            return copy(scale, pow()).exponent(scale.exponent());
          };
          initRange.apply(scale, arguments);
          return scale;
        }
        function sqrt() {
          return pow.apply(null, arguments).exponent(0.5);
        }
        function quantile() {
          var domain = [], range = [], thresholds = [], unknown;
          function rescale() {
            var i = 0, n = Math.max(1, range.length);
            thresholds = new Array(n - 1);
            while (++i < n)
              thresholds[i - 1] = d3Array.quantile(domain, i / n);
            return scale;
          }
          function scale(x) {
            return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
          }
          scale.invertExtent = function(y) {
            var i = range.indexOf(y);
            return i < 0 ? [NaN, NaN] : [
              i > 0 ? thresholds[i - 1] : domain[0],
              i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
            ];
          };
          scale.domain = function(_) {
            if (!arguments.length)
              return domain.slice();
            domain = [];
            for (var i = 0, n = _.length, d; i < n; ++i)
              if (d = _[i], d != null && !isNaN(d = +d))
                domain.push(d);
            domain.sort(d3Array.ascending);
            return rescale();
          };
          scale.range = function(_) {
            return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          scale.quantiles = function() {
            return thresholds.slice();
          };
          scale.copy = function() {
            return quantile().domain(domain).range(range).unknown(unknown);
          };
          return initRange.apply(scale, arguments);
        }
        function quantize() {
          var x0 = 0, x1 = 1, n = 1, domain = [0.5], range = [0, 1], unknown;
          function scale(x) {
            return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
          }
          function rescale() {
            var i = -1;
            domain = new Array(n);
            while (++i < n)
              domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
            return scale;
          }
          scale.domain = function(_) {
            return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
          };
          scale.range = function(_) {
            return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
          };
          scale.invertExtent = function(y) {
            var i = range.indexOf(y);
            return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : scale;
          };
          scale.thresholds = function() {
            return domain.slice();
          };
          scale.copy = function() {
            return quantize().domain([x0, x1]).range(range).unknown(unknown);
          };
          return initRange.apply(linearish(scale), arguments);
        }
        function threshold() {
          var domain = [0.5], range = [0, 1], unknown, n = 1;
          function scale(x) {
            return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
          }
          scale.domain = function(_) {
            return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
          };
          scale.range = function(_) {
            return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
          };
          scale.invertExtent = function(y) {
            var i = range.indexOf(y);
            return [domain[i - 1], domain[i]];
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          scale.copy = function() {
            return threshold().domain(domain).range(range).unknown(unknown);
          };
          return initRange.apply(scale, arguments);
        }
        var durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
        function date(t) {
          return new Date(t);
        }
        function number$1(t) {
          return t instanceof Date ? +t : +new Date(+t);
        }
        function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
          var scale = continuous(identity, identity), invert = scale.invert, domain = scale.domain;
          var formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear = format("%Y");
          var tickIntervals = [
            [second, 1, durationSecond],
            [second, 5, 5 * durationSecond],
            [second, 15, 15 * durationSecond],
            [second, 30, 30 * durationSecond],
            [minute, 1, durationMinute],
            [minute, 5, 5 * durationMinute],
            [minute, 15, 15 * durationMinute],
            [minute, 30, 30 * durationMinute],
            [hour, 1, durationHour],
            [hour, 3, 3 * durationHour],
            [hour, 6, 6 * durationHour],
            [hour, 12, 12 * durationHour],
            [day, 1, durationDay],
            [day, 2, 2 * durationDay],
            [week, 1, durationWeek],
            [month, 1, durationMonth],
            [month, 3, 3 * durationMonth],
            [year, 1, durationYear]
          ];
          function tickFormat2(date2) {
            return (second(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear)(date2);
          }
          function tickInterval(interval, start, stop, step) {
            if (interval == null)
              interval = 10;
            if (typeof interval === "number") {
              var target = Math.abs(stop - start) / interval, i = d3Array.bisector(function(i2) {
                return i2[2];
              }).right(tickIntervals, target);
              if (i === tickIntervals.length) {
                step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
                interval = year;
              } else if (i) {
                i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
                step = i[1];
                interval = i[0];
              } else {
                step = Math.max(d3Array.tickStep(start, stop, interval), 1);
                interval = millisecond;
              }
            }
            return step == null ? interval : interval.every(step);
          }
          scale.invert = function(y) {
            return new Date(invert(y));
          };
          scale.domain = function(_) {
            return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
          };
          scale.ticks = function(interval, step) {
            var d = domain(), t0 = d[0], t1 = d[d.length - 1], r = t1 < t0, t;
            if (r)
              t = t0, t0 = t1, t1 = t;
            t = tickInterval(interval, t0, t1, step);
            t = t ? t.range(t0, t1 + 1) : [];
            return r ? t.reverse() : t;
          };
          scale.tickFormat = function(count, specifier) {
            return specifier == null ? tickFormat2 : format(specifier);
          };
          scale.nice = function(interval, step) {
            var d = domain();
            return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
          };
          scale.copy = function() {
            return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
          };
          return scale;
        }
        function time() {
          return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
        }
        function utcTime() {
          return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
        }
        function transformer$1() {
          var x0 = 0, x1 = 1, t0, t1, k10, transform, interpolator = identity, clamp = false, unknown;
          function scale(x) {
            return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
          }
          scale.domain = function(_) {
            return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
          };
          scale.clamp = function(_) {
            return arguments.length ? (clamp = !!_, scale) : clamp;
          };
          scale.interpolator = function(_) {
            return arguments.length ? (interpolator = _, scale) : interpolator;
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          return function(t) {
            transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
            return scale;
          };
        }
        function copy$1(source, target) {
          return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
        }
        function sequential() {
          var scale = linearish(transformer$1()(identity));
          scale.copy = function() {
            return copy$1(scale, sequential());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function sequentialLog() {
          var scale = loggish(transformer$1()).domain([1, 10]);
          scale.copy = function() {
            return copy$1(scale, sequentialLog()).base(scale.base());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function sequentialSymlog() {
          var scale = symlogish(transformer$1());
          scale.copy = function() {
            return copy$1(scale, sequentialSymlog()).constant(scale.constant());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function sequentialPow() {
          var scale = powish(transformer$1());
          scale.copy = function() {
            return copy$1(scale, sequentialPow()).exponent(scale.exponent());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function sequentialSqrt() {
          return sequentialPow.apply(null, arguments).exponent(0.5);
        }
        function sequentialQuantile() {
          var domain = [], interpolator = identity;
          function scale(x) {
            if (!isNaN(x = +x))
              return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
          }
          scale.domain = function(_) {
            if (!arguments.length)
              return domain.slice();
            domain = [];
            for (var i = 0, n = _.length, d; i < n; ++i)
              if (d = _[i], d != null && !isNaN(d = +d))
                domain.push(d);
            domain.sort(d3Array.ascending);
            return scale;
          };
          scale.interpolator = function(_) {
            return arguments.length ? (interpolator = _, scale) : interpolator;
          };
          scale.copy = function() {
            return sequentialQuantile(interpolator).domain(domain);
          };
          return initInterpolator.apply(scale, arguments);
        }
        function transformer$2() {
          var x0 = 0, x1 = 0.5, x2 = 1, t0, t1, t2, k10, k21, interpolator = identity, transform, clamp = false, unknown;
          function scale(x) {
            return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
          }
          scale.domain = function(_) {
            return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
          };
          scale.clamp = function(_) {
            return arguments.length ? (clamp = !!_, scale) : clamp;
          };
          scale.interpolator = function(_) {
            return arguments.length ? (interpolator = _, scale) : interpolator;
          };
          scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
          };
          return function(t) {
            transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
            return scale;
          };
        }
        function diverging() {
          var scale = linearish(transformer$2()(identity));
          scale.copy = function() {
            return copy$1(scale, diverging());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function divergingLog() {
          var scale = loggish(transformer$2()).domain([0.1, 1, 10]);
          scale.copy = function() {
            return copy$1(scale, divergingLog()).base(scale.base());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function divergingSymlog() {
          var scale = symlogish(transformer$2());
          scale.copy = function() {
            return copy$1(scale, divergingSymlog()).constant(scale.constant());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function divergingPow() {
          var scale = powish(transformer$2());
          scale.copy = function() {
            return copy$1(scale, divergingPow()).exponent(scale.exponent());
          };
          return initInterpolator.apply(scale, arguments);
        }
        function divergingSqrt() {
          return divergingPow.apply(null, arguments).exponent(0.5);
        }
        exports2.scaleBand = band;
        exports2.scalePoint = point;
        exports2.scaleIdentity = identity$1;
        exports2.scaleLinear = linear;
        exports2.scaleLog = log;
        exports2.scaleSymlog = symlog;
        exports2.scaleOrdinal = ordinal;
        exports2.scaleImplicit = implicit;
        exports2.scalePow = pow;
        exports2.scaleSqrt = sqrt;
        exports2.scaleQuantile = quantile;
        exports2.scaleQuantize = quantize;
        exports2.scaleThreshold = threshold;
        exports2.scaleTime = time;
        exports2.scaleUtc = utcTime;
        exports2.scaleSequential = sequential;
        exports2.scaleSequentialLog = sequentialLog;
        exports2.scaleSequentialPow = sequentialPow;
        exports2.scaleSequentialSqrt = sequentialSqrt;
        exports2.scaleSequentialSymlog = sequentialSymlog;
        exports2.scaleSequentialQuantile = sequentialQuantile;
        exports2.scaleDiverging = diverging;
        exports2.scaleDivergingLog = divergingLog;
        exports2.scaleDivergingPow = divergingPow;
        exports2.scaleDivergingSqrt = divergingSqrt;
        exports2.scaleDivergingSymlog = divergingSymlog;
        exports2.tickFormat = tickFormat;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-scale-chromatic/dist/d3-scale-chromatic.js
  var require_d3_scale_chromatic = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-scale-chromatic/dist/d3-scale-chromatic.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_interpolate(), require_d3_color()) : typeof define === "function" && define.amd ? define(["exports", "d3-interpolate", "d3-color"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3));
      })(exports, function(exports2, d3Interpolate, d3Color) {
        "use strict";
        function colors(specifier) {
          var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
          while (i < n)
            colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
          return colors2;
        }
        var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
        var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
        var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
        var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
        var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
        var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
        var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
        var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
        var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
        var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
        function ramp(scheme2) {
          return d3Interpolate.interpolateRgbBasis(scheme2[scheme2.length - 1]);
        }
        var scheme = new Array(3).concat(
          "d8b365f5f5f55ab4ac",
          "a6611adfc27d80cdc1018571",
          "a6611adfc27df5f5f580cdc1018571",
          "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
          "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
          "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
          "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
          "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
          "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
        ).map(colors);
        var BrBG = ramp(scheme);
        var scheme$1 = new Array(3).concat(
          "af8dc3f7f7f77fbf7b",
          "7b3294c2a5cfa6dba0008837",
          "7b3294c2a5cff7f7f7a6dba0008837",
          "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
          "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
          "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
          "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
          "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
          "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
        ).map(colors);
        var PRGn = ramp(scheme$1);
        var scheme$2 = new Array(3).concat(
          "e9a3c9f7f7f7a1d76a",
          "d01c8bf1b6dab8e1864dac26",
          "d01c8bf1b6daf7f7f7b8e1864dac26",
          "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
          "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
          "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
          "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
          "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
          "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
        ).map(colors);
        var PiYG = ramp(scheme$2);
        var scheme$3 = new Array(3).concat(
          "998ec3f7f7f7f1a340",
          "5e3c99b2abd2fdb863e66101",
          "5e3c99b2abd2f7f7f7fdb863e66101",
          "542788998ec3d8daebfee0b6f1a340b35806",
          "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
          "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
          "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
          "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
          "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
        ).map(colors);
        var PuOr = ramp(scheme$3);
        var scheme$4 = new Array(3).concat(
          "ef8a62f7f7f767a9cf",
          "ca0020f4a58292c5de0571b0",
          "ca0020f4a582f7f7f792c5de0571b0",
          "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
          "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
          "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
          "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
          "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
          "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
        ).map(colors);
        var RdBu = ramp(scheme$4);
        var scheme$5 = new Array(3).concat(
          "ef8a62ffffff999999",
          "ca0020f4a582bababa404040",
          "ca0020f4a582ffffffbababa404040",
          "b2182bef8a62fddbc7e0e0e09999994d4d4d",
          "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
          "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
          "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
          "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
          "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
        ).map(colors);
        var RdGy = ramp(scheme$5);
        var scheme$6 = new Array(3).concat(
          "fc8d59ffffbf91bfdb",
          "d7191cfdae61abd9e92c7bb6",
          "d7191cfdae61ffffbfabd9e92c7bb6",
          "d73027fc8d59fee090e0f3f891bfdb4575b4",
          "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
          "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
          "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
          "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
          "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
        ).map(colors);
        var RdYlBu = ramp(scheme$6);
        var scheme$7 = new Array(3).concat(
          "fc8d59ffffbf91cf60",
          "d7191cfdae61a6d96a1a9641",
          "d7191cfdae61ffffbfa6d96a1a9641",
          "d73027fc8d59fee08bd9ef8b91cf601a9850",
          "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
          "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
          "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
          "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
          "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
        ).map(colors);
        var RdYlGn = ramp(scheme$7);
        var scheme$8 = new Array(3).concat(
          "fc8d59ffffbf99d594",
          "d7191cfdae61abdda42b83ba",
          "d7191cfdae61ffffbfabdda42b83ba",
          "d53e4ffc8d59fee08be6f59899d5943288bd",
          "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
          "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
          "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
          "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
          "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
        ).map(colors);
        var Spectral = ramp(scheme$8);
        var scheme$9 = new Array(3).concat(
          "e5f5f999d8c92ca25f",
          "edf8fbb2e2e266c2a4238b45",
          "edf8fbb2e2e266c2a42ca25f006d2c",
          "edf8fbccece699d8c966c2a42ca25f006d2c",
          "edf8fbccece699d8c966c2a441ae76238b45005824",
          "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
          "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
        ).map(colors);
        var BuGn = ramp(scheme$9);
        var scheme$a = new Array(3).concat(
          "e0ecf49ebcda8856a7",
          "edf8fbb3cde38c96c688419d",
          "edf8fbb3cde38c96c68856a7810f7c",
          "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
          "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
          "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
          "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
        ).map(colors);
        var BuPu = ramp(scheme$a);
        var scheme$b = new Array(3).concat(
          "e0f3dba8ddb543a2ca",
          "f0f9e8bae4bc7bccc42b8cbe",
          "f0f9e8bae4bc7bccc443a2ca0868ac",
          "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
          "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
          "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
          "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
        ).map(colors);
        var GnBu = ramp(scheme$b);
        var scheme$c = new Array(3).concat(
          "fee8c8fdbb84e34a33",
          "fef0d9fdcc8afc8d59d7301f",
          "fef0d9fdcc8afc8d59e34a33b30000",
          "fef0d9fdd49efdbb84fc8d59e34a33b30000",
          "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
          "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
          "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
        ).map(colors);
        var OrRd = ramp(scheme$c);
        var scheme$d = new Array(3).concat(
          "ece2f0a6bddb1c9099",
          "f6eff7bdc9e167a9cf02818a",
          "f6eff7bdc9e167a9cf1c9099016c59",
          "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
          "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
          "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
          "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
        ).map(colors);
        var PuBuGn = ramp(scheme$d);
        var scheme$e = new Array(3).concat(
          "ece7f2a6bddb2b8cbe",
          "f1eef6bdc9e174a9cf0570b0",
          "f1eef6bdc9e174a9cf2b8cbe045a8d",
          "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
          "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
          "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
          "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
        ).map(colors);
        var PuBu = ramp(scheme$e);
        var scheme$f = new Array(3).concat(
          "e7e1efc994c7dd1c77",
          "f1eef6d7b5d8df65b0ce1256",
          "f1eef6d7b5d8df65b0dd1c77980043",
          "f1eef6d4b9dac994c7df65b0dd1c77980043",
          "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
          "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
          "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
        ).map(colors);
        var PuRd = ramp(scheme$f);
        var scheme$g = new Array(3).concat(
          "fde0ddfa9fb5c51b8a",
          "feebe2fbb4b9f768a1ae017e",
          "feebe2fbb4b9f768a1c51b8a7a0177",
          "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
          "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
          "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
          "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
        ).map(colors);
        var RdPu = ramp(scheme$g);
        var scheme$h = new Array(3).concat(
          "edf8b17fcdbb2c7fb8",
          "ffffcca1dab441b6c4225ea8",
          "ffffcca1dab441b6c42c7fb8253494",
          "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
          "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
          "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
          "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
        ).map(colors);
        var YlGnBu = ramp(scheme$h);
        var scheme$i = new Array(3).concat(
          "f7fcb9addd8e31a354",
          "ffffccc2e69978c679238443",
          "ffffccc2e69978c67931a354006837",
          "ffffccd9f0a3addd8e78c67931a354006837",
          "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
          "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
          "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
        ).map(colors);
        var YlGn = ramp(scheme$i);
        var scheme$j = new Array(3).concat(
          "fff7bcfec44fd95f0e",
          "ffffd4fed98efe9929cc4c02",
          "ffffd4fed98efe9929d95f0e993404",
          "ffffd4fee391fec44ffe9929d95f0e993404",
          "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
          "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
          "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
        ).map(colors);
        var YlOrBr = ramp(scheme$j);
        var scheme$k = new Array(3).concat(
          "ffeda0feb24cf03b20",
          "ffffb2fecc5cfd8d3ce31a1c",
          "ffffb2fecc5cfd8d3cf03b20bd0026",
          "ffffb2fed976feb24cfd8d3cf03b20bd0026",
          "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
          "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
          "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
        ).map(colors);
        var YlOrRd = ramp(scheme$k);
        var scheme$l = new Array(3).concat(
          "deebf79ecae13182bd",
          "eff3ffbdd7e76baed62171b5",
          "eff3ffbdd7e76baed63182bd08519c",
          "eff3ffc6dbef9ecae16baed63182bd08519c",
          "eff3ffc6dbef9ecae16baed64292c62171b5084594",
          "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
          "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
        ).map(colors);
        var Blues = ramp(scheme$l);
        var scheme$m = new Array(3).concat(
          "e5f5e0a1d99b31a354",
          "edf8e9bae4b374c476238b45",
          "edf8e9bae4b374c47631a354006d2c",
          "edf8e9c7e9c0a1d99b74c47631a354006d2c",
          "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
          "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
          "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
        ).map(colors);
        var Greens = ramp(scheme$m);
        var scheme$n = new Array(3).concat(
          "f0f0f0bdbdbd636363",
          "f7f7f7cccccc969696525252",
          "f7f7f7cccccc969696636363252525",
          "f7f7f7d9d9d9bdbdbd969696636363252525",
          "f7f7f7d9d9d9bdbdbd969696737373525252252525",
          "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
          "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
        ).map(colors);
        var Greys = ramp(scheme$n);
        var scheme$o = new Array(3).concat(
          "efedf5bcbddc756bb1",
          "f2f0f7cbc9e29e9ac86a51a3",
          "f2f0f7cbc9e29e9ac8756bb154278f",
          "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
          "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
          "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
          "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
        ).map(colors);
        var Purples = ramp(scheme$o);
        var scheme$p = new Array(3).concat(
          "fee0d2fc9272de2d26",
          "fee5d9fcae91fb6a4acb181d",
          "fee5d9fcae91fb6a4ade2d26a50f15",
          "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
          "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
          "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
          "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
        ).map(colors);
        var Reds = ramp(scheme$p);
        var scheme$q = new Array(3).concat(
          "fee6cefdae6be6550d",
          "feeddefdbe85fd8d3cd94701",
          "feeddefdbe85fd8d3ce6550da63603",
          "feeddefdd0a2fdae6bfd8d3ce6550da63603",
          "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
          "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
          "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
        ).map(colors);
        var Oranges = ramp(scheme$q);
        function cividis(t) {
          t = Math.max(0, Math.min(1, t));
          return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
        }
        var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0), d3Color.cubehelix(-240, 0.5, 1));
        var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.5, 0.8));
        var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.5, 0.8));
        var c = d3Color.cubehelix();
        function rainbow(t) {
          if (t < 0 || t > 1)
            t -= Math.floor(t);
          var ts = Math.abs(t - 0.5);
          c.h = 360 * t - 100;
          c.s = 1.5 - 1.5 * ts;
          c.l = 0.8 - 0.9 * ts;
          return c + "";
        }
        var c$1 = d3Color.rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
        function sinebow(t) {
          var x;
          t = (0.5 - t) * Math.PI;
          c$1.r = 255 * (x = Math.sin(t)) * x;
          c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
          c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
          return c$1 + "";
        }
        function turbo(t) {
          t = Math.max(0, Math.min(1, t));
          return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
        }
        function ramp$1(range) {
          var n = range.length;
          return function(t) {
            return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
          };
        }
        var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
        var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
        var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
        var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
        exports2.interpolateBlues = Blues;
        exports2.interpolateBrBG = BrBG;
        exports2.interpolateBuGn = BuGn;
        exports2.interpolateBuPu = BuPu;
        exports2.interpolateCividis = cividis;
        exports2.interpolateCool = cool;
        exports2.interpolateCubehelixDefault = cubehelix;
        exports2.interpolateGnBu = GnBu;
        exports2.interpolateGreens = Greens;
        exports2.interpolateGreys = Greys;
        exports2.interpolateInferno = inferno;
        exports2.interpolateMagma = magma;
        exports2.interpolateOrRd = OrRd;
        exports2.interpolateOranges = Oranges;
        exports2.interpolatePRGn = PRGn;
        exports2.interpolatePiYG = PiYG;
        exports2.interpolatePlasma = plasma;
        exports2.interpolatePuBu = PuBu;
        exports2.interpolatePuBuGn = PuBuGn;
        exports2.interpolatePuOr = PuOr;
        exports2.interpolatePuRd = PuRd;
        exports2.interpolatePurples = Purples;
        exports2.interpolateRainbow = rainbow;
        exports2.interpolateRdBu = RdBu;
        exports2.interpolateRdGy = RdGy;
        exports2.interpolateRdPu = RdPu;
        exports2.interpolateRdYlBu = RdYlBu;
        exports2.interpolateRdYlGn = RdYlGn;
        exports2.interpolateReds = Reds;
        exports2.interpolateSinebow = sinebow;
        exports2.interpolateSpectral = Spectral;
        exports2.interpolateTurbo = turbo;
        exports2.interpolateViridis = viridis;
        exports2.interpolateWarm = warm;
        exports2.interpolateYlGn = YlGn;
        exports2.interpolateYlGnBu = YlGnBu;
        exports2.interpolateYlOrBr = YlOrBr;
        exports2.interpolateYlOrRd = YlOrRd;
        exports2.schemeAccent = Accent;
        exports2.schemeBlues = scheme$l;
        exports2.schemeBrBG = scheme;
        exports2.schemeBuGn = scheme$9;
        exports2.schemeBuPu = scheme$a;
        exports2.schemeCategory10 = category10;
        exports2.schemeDark2 = Dark2;
        exports2.schemeGnBu = scheme$b;
        exports2.schemeGreens = scheme$m;
        exports2.schemeGreys = scheme$n;
        exports2.schemeOrRd = scheme$c;
        exports2.schemeOranges = scheme$q;
        exports2.schemePRGn = scheme$1;
        exports2.schemePaired = Paired;
        exports2.schemePastel1 = Pastel1;
        exports2.schemePastel2 = Pastel2;
        exports2.schemePiYG = scheme$2;
        exports2.schemePuBu = scheme$e;
        exports2.schemePuBuGn = scheme$d;
        exports2.schemePuOr = scheme$3;
        exports2.schemePuRd = scheme$f;
        exports2.schemePurples = scheme$o;
        exports2.schemeRdBu = scheme$4;
        exports2.schemeRdGy = scheme$5;
        exports2.schemeRdPu = scheme$g;
        exports2.schemeRdYlBu = scheme$6;
        exports2.schemeRdYlGn = scheme$7;
        exports2.schemeReds = scheme$p;
        exports2.schemeSet1 = Set1;
        exports2.schemeSet2 = Set2;
        exports2.schemeSet3 = Set3;
        exports2.schemeSpectral = scheme$8;
        exports2.schemeTableau10 = Tableau10;
        exports2.schemeYlGn = scheme$i;
        exports2.schemeYlGnBu = scheme$h;
        exports2.schemeYlOrBr = scheme$j;
        exports2.schemeYlOrRd = scheme$k;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-shape/dist/d3-shape.js
  var require_d3_shape = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-shape/dist/d3-shape.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_path()) : typeof define === "function" && define.amd ? define(["exports", "d3-path"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Path) {
        "use strict";
        function constant(x2) {
          return function constant2() {
            return x2;
          };
        }
        var abs = Math.abs;
        var atan2 = Math.atan2;
        var cos = Math.cos;
        var max = Math.max;
        var min = Math.min;
        var sin = Math.sin;
        var sqrt = Math.sqrt;
        var epsilon = 1e-12;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var tau = 2 * pi;
        function acos(x2) {
          return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
        }
        function asin(x2) {
          return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
        }
        function arcInnerRadius(d) {
          return d.innerRadius;
        }
        function arcOuterRadius(d) {
          return d.outerRadius;
        }
        function arcStartAngle(d) {
          return d.startAngle;
        }
        function arcEndAngle(d) {
          return d.endAngle;
        }
        function arcPadAngle(d) {
          return d && d.padAngle;
        }
        function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
          var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
          if (t * t < epsilon)
            return;
          t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
          return [x0 + t * x10, y0 + t * y10];
        }
        function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
          var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
          return {
            cx: cx0,
            cy: cy0,
            x01: -ox,
            y01: -oy,
            x11: cx0 * (r1 / r - 1),
            y11: cy0 * (r1 / r - 1)
          };
        }
        function arc() {
          var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
          function arc2() {
            var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
            if (!context)
              context = buffer = d3Path.path();
            if (r1 < r0)
              r = r1, r1 = r0, r0 = r;
            if (!(r1 > epsilon))
              context.moveTo(0, 0);
            else if (da > tau - epsilon) {
              context.moveTo(r1 * cos(a0), r1 * sin(a0));
              context.arc(0, 0, r1, a0, a1, !cw);
              if (r0 > epsilon) {
                context.moveTo(r0 * cos(a1), r0 * sin(a1));
                context.arc(0, 0, r0, a1, a0, cw);
              }
            } else {
              var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
              if (rp > epsilon) {
                var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
                if ((da0 -= p0 * 2) > epsilon)
                  p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
                else
                  da0 = 0, a00 = a10 = (a0 + a1) / 2;
                if ((da1 -= p1 * 2) > epsilon)
                  p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                else
                  da1 = 0, a01 = a11 = (a0 + a1) / 2;
              }
              var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
              if (rc > epsilon) {
                var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
                if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                  var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                  rc0 = min(rc, (r0 - lc) / (kc - 1));
                  rc1 = min(rc, (r1 - lc) / (kc + 1));
                }
              }
              if (!(da1 > epsilon))
                context.moveTo(x01, y01);
              else if (rc1 > epsilon) {
                t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                if (rc1 < rc)
                  context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
                else {
                  context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                }
              } else
                context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
              if (!(r0 > epsilon) || !(da0 > epsilon))
                context.lineTo(x10, y10);
              else if (rc0 > epsilon) {
                t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                if (rc0 < rc)
                  context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
                else {
                  context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                }
              } else
                context.arc(0, 0, r0, a10, a00, cw);
            }
            context.closePath();
            if (buffer)
              return context = null, buffer + "" || null;
          }
          arc2.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
            return [cos(a2) * r, sin(a2) * r];
          };
          arc2.innerRadius = function(_) {
            return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : innerRadius;
          };
          arc2.outerRadius = function(_) {
            return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : outerRadius;
          };
          arc2.cornerRadius = function(_) {
            return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : cornerRadius;
          };
          arc2.padRadius = function(_) {
            return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc2) : padRadius;
          };
          arc2.startAngle = function(_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc2) : startAngle;
          };
          arc2.endAngle = function(_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc2) : endAngle;
          };
          arc2.padAngle = function(_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc2) : padAngle;
          };
          arc2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, arc2) : context;
          };
          return arc2;
        }
        function Linear(context) {
          this._context = context;
        }
        Linear.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
              default:
                this._context.lineTo(x2, y2);
                break;
            }
          }
        };
        function curveLinear(context) {
          return new Linear(context);
        }
        function x(p) {
          return p[0];
        }
        function y(p) {
          return p[1];
        }
        function line() {
          var x$1 = x, y$1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
          function line2(data) {
            var i, n = data.length, d, defined0 = false, buffer;
            if (context == null)
              output = curve(buffer = d3Path.path());
            for (i = 0; i <= n; ++i) {
              if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0)
                  output.lineStart();
                else
                  output.lineEnd();
              }
              if (defined0)
                output.point(+x$1(d, i, data), +y$1(d, i, data));
            }
            if (buffer)
              return output = null, buffer + "" || null;
          }
          line2.x = function(_) {
            return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line2) : x$1;
          };
          line2.y = function(_) {
            return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line2) : y$1;
          };
          line2.defined = function(_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line2) : defined;
          };
          line2.curve = function(_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
          };
          line2.context = function(_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
          };
          return line2;
        }
        function area() {
          var x0 = x, x1 = null, y0 = constant(0), y1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
          function area2(data) {
            var i, j, k2, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
            if (context == null)
              output = curve(buffer = d3Path.path());
            for (i = 0; i <= n; ++i) {
              if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) {
                  j = i;
                  output.areaStart();
                  output.lineStart();
                } else {
                  output.lineEnd();
                  output.lineStart();
                  for (k2 = i - 1; k2 >= j; --k2) {
                    output.point(x0z[k2], y0z[k2]);
                  }
                  output.lineEnd();
                  output.areaEnd();
                }
              }
              if (defined0) {
                x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
              }
            }
            if (buffer)
              return output = null, buffer + "" || null;
          }
          function arealine() {
            return line().defined(defined).curve(curve).context(context);
          }
          area2.x = function(_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area2) : x0;
          };
          area2.x0 = function(_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area2) : x0;
          };
          area2.x1 = function(_) {
            return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : x1;
          };
          area2.y = function(_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area2) : y0;
          };
          area2.y0 = function(_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area2) : y0;
          };
          area2.y1 = function(_) {
            return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : y1;
          };
          area2.lineX0 = area2.lineY0 = function() {
            return arealine().x(x0).y(y0);
          };
          area2.lineY1 = function() {
            return arealine().x(x0).y(y1);
          };
          area2.lineX1 = function() {
            return arealine().x(x1).y(y0);
          };
          area2.defined = function(_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area2) : defined;
          };
          area2.curve = function(_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
          };
          area2.context = function(_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
          };
          return area2;
        }
        function descending(a2, b) {
          return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
        }
        function identity(d) {
          return d;
        }
        function pie() {
          var value = identity, sortValues = descending, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);
          function pie2(data) {
            var i, n = data.length, j, k2, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
            for (i = 0; i < n; ++i) {
              if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
                sum2 += v;
              }
            }
            if (sortValues != null)
              index.sort(function(i2, j2) {
                return sortValues(arcs[i2], arcs[j2]);
              });
            else if (sort != null)
              index.sort(function(i2, j2) {
                return sort(data[i2], data[j2]);
              });
            for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
              j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
                data: data[j],
                index: i,
                value: v,
                startAngle: a0,
                endAngle: a1,
                padAngle: p
              };
            }
            return arcs;
          }
          pie2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie2) : value;
          };
          pie2.sortValues = function(_) {
            return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
          };
          pie2.sort = function(_) {
            return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
          };
          pie2.startAngle = function(_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie2) : startAngle;
          };
          pie2.endAngle = function(_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie2) : endAngle;
          };
          pie2.padAngle = function(_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie2) : padAngle;
          };
          return pie2;
        }
        var curveRadialLinear = curveRadial(curveLinear);
        function Radial(curve) {
          this._curve = curve;
        }
        Radial.prototype = {
          areaStart: function() {
            this._curve.areaStart();
          },
          areaEnd: function() {
            this._curve.areaEnd();
          },
          lineStart: function() {
            this._curve.lineStart();
          },
          lineEnd: function() {
            this._curve.lineEnd();
          },
          point: function(a2, r) {
            this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
          }
        };
        function curveRadial(curve) {
          function radial(context) {
            return new Radial(curve(context));
          }
          radial._curve = curve;
          return radial;
        }
        function lineRadial(l) {
          var c2 = l.curve;
          l.angle = l.x, delete l.x;
          l.radius = l.y, delete l.y;
          l.curve = function(_) {
            return arguments.length ? c2(curveRadial(_)) : c2()._curve;
          };
          return l;
        }
        function lineRadial$1() {
          return lineRadial(line().curve(curveRadialLinear));
        }
        function areaRadial() {
          var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
          a2.angle = a2.x, delete a2.x;
          a2.startAngle = a2.x0, delete a2.x0;
          a2.endAngle = a2.x1, delete a2.x1;
          a2.radius = a2.y, delete a2.y;
          a2.innerRadius = a2.y0, delete a2.y0;
          a2.outerRadius = a2.y1, delete a2.y1;
          a2.lineStartAngle = function() {
            return lineRadial(x0());
          }, delete a2.lineX0;
          a2.lineEndAngle = function() {
            return lineRadial(x1());
          }, delete a2.lineX1;
          a2.lineInnerRadius = function() {
            return lineRadial(y0());
          }, delete a2.lineY0;
          a2.lineOuterRadius = function() {
            return lineRadial(y1());
          }, delete a2.lineY1;
          a2.curve = function(_) {
            return arguments.length ? c2(curveRadial(_)) : c2()._curve;
          };
          return a2;
        }
        function pointRadial(x2, y2) {
          return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
        }
        var slice = Array.prototype.slice;
        function linkSource(d) {
          return d.source;
        }
        function linkTarget(d) {
          return d.target;
        }
        function link(curve) {
          var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;
          function link2() {
            var buffer, argv = slice.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv);
            if (!context)
              context = buffer = d3Path.path();
            curve(context, +x$1.apply(this, (argv[0] = s2, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
            if (buffer)
              return context = null, buffer + "" || null;
          }
          link2.source = function(_) {
            return arguments.length ? (source = _, link2) : source;
          };
          link2.target = function(_) {
            return arguments.length ? (target = _, link2) : target;
          };
          link2.x = function(_) {
            return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link2) : x$1;
          };
          link2.y = function(_) {
            return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link2) : y$1;
          };
          link2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, link2) : context;
          };
          return link2;
        }
        function curveHorizontal(context, x0, y0, x1, y1) {
          context.moveTo(x0, y0);
          context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
        }
        function curveVertical(context, x0, y0, x1, y1) {
          context.moveTo(x0, y0);
          context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
        }
        function curveRadial$1(context, x0, y0, x1, y1) {
          var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);
          context.moveTo(p0[0], p0[1]);
          context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
        }
        function linkHorizontal() {
          return link(curveHorizontal);
        }
        function linkVertical() {
          return link(curveVertical);
        }
        function linkRadial() {
          var l = link(curveRadial$1);
          l.angle = l.x, delete l.x;
          l.radius = l.y, delete l.y;
          return l;
        }
        var circle = {
          draw: function(context, size) {
            var r = Math.sqrt(size / pi);
            context.moveTo(r, 0);
            context.arc(0, 0, r, 0, tau);
          }
        };
        var cross = {
          draw: function(context, size) {
            var r = Math.sqrt(size / 5) / 2;
            context.moveTo(-3 * r, -r);
            context.lineTo(-r, -r);
            context.lineTo(-r, -3 * r);
            context.lineTo(r, -3 * r);
            context.lineTo(r, -r);
            context.lineTo(3 * r, -r);
            context.lineTo(3 * r, r);
            context.lineTo(r, r);
            context.lineTo(r, 3 * r);
            context.lineTo(-r, 3 * r);
            context.lineTo(-r, r);
            context.lineTo(-3 * r, r);
            context.closePath();
          }
        };
        var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
        var diamond = {
          draw: function(context, size) {
            var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
            context.moveTo(0, -y2);
            context.lineTo(x2, 0);
            context.lineTo(0, y2);
            context.lineTo(-x2, 0);
            context.closePath();
          }
        };
        var ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;
        var star = {
          draw: function(context, size) {
            var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
            context.moveTo(0, -r);
            context.lineTo(x2, y2);
            for (var i = 1; i < 5; ++i) {
              var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
              context.lineTo(s2 * r, -c2 * r);
              context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
            }
            context.closePath();
          }
        };
        var square = {
          draw: function(context, size) {
            var w = Math.sqrt(size), x2 = -w / 2;
            context.rect(x2, x2, w, w);
          }
        };
        var sqrt3 = Math.sqrt(3);
        var triangle = {
          draw: function(context, size) {
            var y2 = -Math.sqrt(size / (sqrt3 * 3));
            context.moveTo(0, y2 * 2);
            context.lineTo(-sqrt3 * y2, -y2);
            context.lineTo(sqrt3 * y2, -y2);
            context.closePath();
          }
        };
        var c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
        var wye = {
          draw: function(context, size) {
            var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
            context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
            context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
            context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
            context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
            context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
            context.closePath();
          }
        };
        var symbols = [
          circle,
          cross,
          diamond,
          square,
          star,
          triangle,
          wye
        ];
        function symbol() {
          var type = constant(circle), size = constant(64), context = null;
          function symbol2() {
            var buffer;
            if (!context)
              context = buffer = d3Path.path();
            type.apply(this, arguments).draw(context, +size.apply(this, arguments));
            if (buffer)
              return context = null, buffer + "" || null;
          }
          symbol2.type = function(_) {
            return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol2) : type;
          };
          symbol2.size = function(_) {
            return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol2) : size;
          };
          symbol2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, symbol2) : context;
          };
          return symbol2;
        }
        function noop() {
        }
        function point(that, x2, y2) {
          that._context.bezierCurveTo(
            (2 * that._x0 + that._x1) / 3,
            (2 * that._y0 + that._y1) / 3,
            (that._x0 + 2 * that._x1) / 3,
            (that._y0 + 2 * that._y1) / 3,
            (that._x0 + 4 * that._x1 + x2) / 6,
            (that._y0 + 4 * that._y1 + y2) / 6
          );
        }
        function Basis(context) {
          this._context = context;
        }
        Basis.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 3:
                point(this, this._x1, this._y1);
              case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
              default:
                point(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basis(context) {
          return new Basis(context);
        }
        function BasisClosed(context) {
          this._context = context;
        }
        BasisClosed.prototype = {
          areaStart: noop,
          areaEnd: noop,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x2, this._y2);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x2, this._y2);
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x2 = x2, this._y2 = y2;
                break;
              case 1:
                this._point = 2;
                this._x3 = x2, this._y3 = y2;
                break;
              case 2:
                this._point = 3;
                this._x4 = x2, this._y4 = y2;
                this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
                break;
              default:
                point(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basisClosed(context) {
          return new BasisClosed(context);
        }
        function BasisOpen(context) {
          this._context = context;
        }
        BasisOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
                this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                break;
              case 3:
                this._point = 4;
              default:
                point(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basisOpen(context) {
          return new BasisOpen(context);
        }
        function Bundle(context, beta) {
          this._basis = new Basis(context);
          this._beta = beta;
        }
        Bundle.prototype = {
          lineStart: function() {
            this._x = [];
            this._y = [];
            this._basis.lineStart();
          },
          lineEnd: function() {
            var x2 = this._x, y2 = this._y, j = x2.length - 1;
            if (j > 0) {
              var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
              while (++i <= j) {
                t = i / j;
                this._basis.point(
                  this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
                  this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
                );
              }
            }
            this._x = this._y = null;
            this._basis.lineEnd();
          },
          point: function(x2, y2) {
            this._x.push(+x2);
            this._y.push(+y2);
          }
        };
        var bundle = function custom(beta) {
          function bundle2(context) {
            return beta === 1 ? new Basis(context) : new Bundle(context, beta);
          }
          bundle2.beta = function(beta2) {
            return custom(+beta2);
          };
          return bundle2;
        }(0.85);
        function point$1(that, x2, y2) {
          that._context.bezierCurveTo(
            that._x1 + that._k * (that._x2 - that._x0),
            that._y1 + that._k * (that._y2 - that._y0),
            that._x2 + that._k * (that._x1 - x2),
            that._y2 + that._k * (that._y1 - y2),
            that._x2,
            that._y2
          );
        }
        function Cardinal(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        Cardinal.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
              case 3:
                point$1(this, this._x1, this._y1);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                this._x1 = x2, this._y1 = y2;
                break;
              case 2:
                this._point = 3;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinal = function custom(tension) {
          function cardinal2(context) {
            return new Cardinal(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function CardinalClosed(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        CardinalClosed.prototype = {
          areaStart: noop,
          areaEnd: noop,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x3 = x2, this._y3 = y2;
                break;
              case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x2, this._y4 = y2);
                break;
              case 2:
                this._point = 3;
                this._x5 = x2, this._y5 = y2;
                break;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinalClosed = function custom(tension) {
          function cardinal2(context) {
            return new CardinalClosed(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function CardinalOpen(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        CardinalOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
              case 3:
                this._point = 4;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinalOpen = function custom(tension) {
          function cardinal2(context) {
            return new CardinalOpen(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function point$2(that, x2, y2) {
          var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
          if (that._l01_a > epsilon) {
            var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
            x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
            y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
          }
          if (that._l23_a > epsilon) {
            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
            x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
            y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
          }
          that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
        }
        function CatmullRom(context, alpha) {
          this._context = context;
          this._alpha = alpha;
        }
        CatmullRom.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
              case 3:
                this.point(this._x2, this._y2);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRom = function custom(alpha) {
          function catmullRom2(context) {
            return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
          }
          catmullRom2.alpha = function(alpha2) {
            return custom(+alpha2);
          };
          return catmullRom2;
        }(0.5);
        function CatmullRomClosed(context, alpha) {
          this._context = context;
          this._alpha = alpha;
        }
        CatmullRomClosed.prototype = {
          areaStart: noop,
          areaEnd: noop,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x3 = x2, this._y3 = y2;
                break;
              case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x2, this._y4 = y2);
                break;
              case 2:
                this._point = 3;
                this._x5 = x2, this._y5 = y2;
                break;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRomClosed = function custom(alpha) {
          function catmullRom2(context) {
            return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
          }
          catmullRom2.alpha = function(alpha2) {
            return custom(+alpha2);
          };
          return catmullRom2;
        }(0.5);
        function CatmullRomOpen(context, alpha) {
          this._context = context;
          this._alpha = alpha;
        }
        CatmullRomOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
              case 3:
                this._point = 4;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRomOpen = function custom(alpha) {
          function catmullRom2(context) {
            return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
          }
          catmullRom2.alpha = function(alpha2) {
            return custom(+alpha2);
          };
          return catmullRom2;
        }(0.5);
        function LinearClosed(context) {
          this._context = context;
        }
        LinearClosed.prototype = {
          areaStart: noop,
          areaEnd: noop,
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._point)
              this._context.closePath();
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point)
              this._context.lineTo(x2, y2);
            else
              this._point = 1, this._context.moveTo(x2, y2);
          }
        };
        function linearClosed(context) {
          return new LinearClosed(context);
        }
        function sign(x2) {
          return x2 < 0 ? -1 : 1;
        }
        function slope3(that, x2, y2) {
          var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
          return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
        }
        function slope2(that, t) {
          var h = that._x1 - that._x0;
          return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
        }
        function point$3(that, t0, t1) {
          var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
          that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
        }
        function MonotoneX(context) {
          this._context = context;
        }
        MonotoneX.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
              case 3:
                point$3(this, this._t0, slope2(this, this._t0));
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            var t1 = NaN;
            x2 = +x2, y2 = +y2;
            if (x2 === this._x1 && y2 === this._y1)
              return;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                point$3(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
                break;
              default:
                point$3(this, this._t0, t1 = slope3(this, x2, y2));
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
            this._t0 = t1;
          }
        };
        function MonotoneY(context) {
          this._context = new ReflectContext(context);
        }
        (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
          MonotoneX.prototype.point.call(this, y2, x2);
        };
        function ReflectContext(context) {
          this._context = context;
        }
        ReflectContext.prototype = {
          moveTo: function(x2, y2) {
            this._context.moveTo(y2, x2);
          },
          closePath: function() {
            this._context.closePath();
          },
          lineTo: function(x2, y2) {
            this._context.lineTo(y2, x2);
          },
          bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
            this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
          }
        };
        function monotoneX(context) {
          return new MonotoneX(context);
        }
        function monotoneY(context) {
          return new MonotoneY(context);
        }
        function Natural(context) {
          this._context = context;
        }
        Natural.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x = [];
            this._y = [];
          },
          lineEnd: function() {
            var x2 = this._x, y2 = this._y, n = x2.length;
            if (n) {
              this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
              if (n === 2) {
                this._context.lineTo(x2[1], y2[1]);
              } else {
                var px = controlPoints(x2), py = controlPoints(y2);
                for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
                  this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
                }
              }
            }
            if (this._line || this._line !== 0 && n === 1)
              this._context.closePath();
            this._line = 1 - this._line;
            this._x = this._y = null;
          },
          point: function(x2, y2) {
            this._x.push(+x2);
            this._y.push(+y2);
          }
        };
        function controlPoints(x2) {
          var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
          a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
          for (i = 1; i < n - 1; ++i)
            a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
          a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
          for (i = 1; i < n; ++i)
            m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
          a2[n - 1] = r[n - 1] / b[n - 1];
          for (i = n - 2; i >= 0; --i)
            a2[i] = (r[i] - a2[i + 1]) / b[i];
          b[n - 1] = (x2[n] + a2[n - 1]) / 2;
          for (i = 0; i < n - 1; ++i)
            b[i] = 2 * x2[i + 1] - a2[i + 1];
          return [a2, b];
        }
        function natural(context) {
          return new Natural(context);
        }
        function Step(context, t) {
          this._context = context;
          this._t = t;
        }
        Step.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x = this._y = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (0 < this._t && this._t < 1 && this._point === 2)
              this._context.lineTo(this._x, this._y);
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            if (this._line >= 0)
              this._t = 1 - this._t, this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
              default: {
                if (this._t <= 0) {
                  this._context.lineTo(this._x, y2);
                  this._context.lineTo(x2, y2);
                } else {
                  var x1 = this._x * (1 - this._t) + x2 * this._t;
                  this._context.lineTo(x1, this._y);
                  this._context.lineTo(x1, y2);
                }
                break;
              }
            }
            this._x = x2, this._y = y2;
          }
        };
        function step(context) {
          return new Step(context, 0.5);
        }
        function stepBefore(context) {
          return new Step(context, 0);
        }
        function stepAfter(context) {
          return new Step(context, 1);
        }
        function none2(series, order) {
          if (!((n = series.length) > 1))
            return;
          for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
            s0 = s1, s1 = series[order[i]];
            for (j = 0; j < m; ++j) {
              s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
            }
          }
        }
        function none$1(series) {
          var n = series.length, o = new Array(n);
          while (--n >= 0)
            o[n] = n;
          return o;
        }
        function stackValue(d, key) {
          return d[key];
        }
        function stack() {
          var keys = constant([]), order = none$1, offset = none2, value = stackValue;
          function stack2(data) {
            var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
            for (i = 0; i < n; ++i) {
              for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
                si[j] = sij = [0, +value(data[j], ki, j, data)];
                sij.data = data[j];
              }
              si.key = ki;
            }
            for (i = 0, oz = order(sz); i < n; ++i) {
              sz[oz[i]].index = i;
            }
            offset(sz, oz);
            return sz;
          }
          stack2.keys = function(_) {
            return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack2) : keys;
          };
          stack2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack2) : value;
          };
          stack2.order = function(_) {
            return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack2) : order;
          };
          stack2.offset = function(_) {
            return arguments.length ? (offset = _ == null ? none2 : _, stack2) : offset;
          };
          return stack2;
        }
        function expand(series, order) {
          if (!((n = series.length) > 0))
            return;
          for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
            for (y2 = i = 0; i < n; ++i)
              y2 += series[i][j][1] || 0;
            if (y2)
              for (i = 0; i < n; ++i)
                series[i][j][1] /= y2;
          }
          none2(series, order);
        }
        function diverging(series, order) {
          if (!((n = series.length) > 0))
            return;
          for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
            for (yp = yn = 0, i = 0; i < n; ++i) {
              if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
                d[0] = yp, d[1] = yp += dy;
              } else if (dy < 0) {
                d[1] = yn, d[0] = yn += dy;
              } else {
                d[0] = 0, d[1] = dy;
              }
            }
          }
        }
        function silhouette(series, order) {
          if (!((n = series.length) > 0))
            return;
          for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
            for (var i = 0, y2 = 0; i < n; ++i)
              y2 += series[i][j][1] || 0;
            s0[j][1] += s0[j][0] = -y2 / 2;
          }
          none2(series, order);
        }
        function wiggle(series, order) {
          if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))
            return;
          for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
            for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
              var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
              for (var k2 = 0; k2 < i; ++k2) {
                var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                s3 += skj0 - skj1;
              }
              s1 += sij0, s2 += s3 * sij0;
            }
            s0[j - 1][1] += s0[j - 1][0] = y2;
            if (s1)
              y2 -= s2 / s1;
          }
          s0[j - 1][1] += s0[j - 1][0] = y2;
          none2(series, order);
        }
        function appearance(series) {
          var peaks = series.map(peak);
          return none$1(series).sort(function(a2, b) {
            return peaks[a2] - peaks[b];
          });
        }
        function peak(series) {
          var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
          while (++i < n)
            if ((vi = +series[i][1]) > vj)
              vj = vi, j = i;
          return j;
        }
        function ascending2(series) {
          var sums = series.map(sum);
          return none$1(series).sort(function(a2, b) {
            return sums[a2] - sums[b];
          });
        }
        function sum(series) {
          var s2 = 0, i = -1, n = series.length, v;
          while (++i < n)
            if (v = +series[i][1])
              s2 += v;
          return s2;
        }
        function descending$1(series) {
          return ascending2(series).reverse();
        }
        function insideOut(series) {
          var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];
          for (i = 0; i < n; ++i) {
            j = order[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        }
        function reverse(series) {
          return none$1(series).reverse();
        }
        exports2.arc = arc;
        exports2.area = area;
        exports2.areaRadial = areaRadial;
        exports2.curveBasis = basis;
        exports2.curveBasisClosed = basisClosed;
        exports2.curveBasisOpen = basisOpen;
        exports2.curveBundle = bundle;
        exports2.curveCardinal = cardinal;
        exports2.curveCardinalClosed = cardinalClosed;
        exports2.curveCardinalOpen = cardinalOpen;
        exports2.curveCatmullRom = catmullRom;
        exports2.curveCatmullRomClosed = catmullRomClosed;
        exports2.curveCatmullRomOpen = catmullRomOpen;
        exports2.curveLinear = curveLinear;
        exports2.curveLinearClosed = linearClosed;
        exports2.curveMonotoneX = monotoneX;
        exports2.curveMonotoneY = monotoneY;
        exports2.curveNatural = natural;
        exports2.curveStep = step;
        exports2.curveStepAfter = stepAfter;
        exports2.curveStepBefore = stepBefore;
        exports2.line = line;
        exports2.lineRadial = lineRadial$1;
        exports2.linkHorizontal = linkHorizontal;
        exports2.linkRadial = linkRadial;
        exports2.linkVertical = linkVertical;
        exports2.pie = pie;
        exports2.pointRadial = pointRadial;
        exports2.radialArea = areaRadial;
        exports2.radialLine = lineRadial$1;
        exports2.stack = stack;
        exports2.stackOffsetDiverging = diverging;
        exports2.stackOffsetExpand = expand;
        exports2.stackOffsetNone = none2;
        exports2.stackOffsetSilhouette = silhouette;
        exports2.stackOffsetWiggle = wiggle;
        exports2.stackOrderAppearance = appearance;
        exports2.stackOrderAscending = ascending2;
        exports2.stackOrderDescending = descending$1;
        exports2.stackOrderInsideOut = insideOut;
        exports2.stackOrderNone = none$1;
        exports2.stackOrderReverse = reverse;
        exports2.symbol = symbol;
        exports2.symbolCircle = circle;
        exports2.symbolCross = cross;
        exports2.symbolDiamond = diamond;
        exports2.symbolSquare = square;
        exports2.symbolStar = star;
        exports2.symbolTriangle = triangle;
        exports2.symbolWye = wye;
        exports2.symbols = symbols;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-voronoi/dist/d3-voronoi.js
  var require_d3_voronoi = __commonJS({
    "node_modules/d3-voronoi/dist/d3-voronoi.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        function constant(x2) {
          return function() {
            return x2;
          };
        }
        function x(d) {
          return d[0];
        }
        function y(d) {
          return d[1];
        }
        function RedBlackTree() {
          this._ = null;
        }
        function RedBlackNode(node) {
          node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        RedBlackTree.prototype = {
          constructor: RedBlackTree,
          insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
              node.P = after;
              node.N = after.N;
              if (after.N)
                after.N.P = node;
              after.N = node;
              if (after.R) {
                after = after.R;
                while (after.L)
                  after = after.L;
                after.L = node;
              } else {
                after.R = node;
              }
              parent = after;
            } else if (this._) {
              after = RedBlackFirst(this._);
              node.P = null;
              node.N = after;
              after.P = after.L = node;
              parent = after;
            } else {
              node.P = node.N = null;
              this._ = node;
              parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
              grandpa = parent.U;
              if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.R) {
                    RedBlackRotateLeft(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  RedBlackRotateRight(this, grandpa);
                }
              } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.L) {
                    RedBlackRotateRight(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  RedBlackRotateLeft(this, grandpa);
                }
              }
              parent = after.U;
            }
            this._.C = false;
          },
          remove: function(node) {
            if (node.N)
              node.N.P = node.P;
            if (node.P)
              node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
              next = right;
            else if (!right)
              next = left;
            else
              next = RedBlackFirst(right);
            if (parent) {
              if (parent.L === node)
                parent.L = next;
              else
                parent.R = next;
            } else {
              this._ = next;
            }
            if (left && right) {
              red = next.C;
              next.C = node.C;
              next.L = left;
              left.U = next;
              if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
              } else {
                next.U = parent;
                parent = next;
                node = next.R;
              }
            } else {
              red = node.C;
              node = next;
            }
            if (node)
              node.U = parent;
            if (red)
              return;
            if (node && node.C) {
              node.C = false;
              return;
            }
            do {
              if (node === this._)
                break;
              if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  RedBlackRotateLeft(this, parent);
                  sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.R || !sibling.R.C) {
                    sibling.L.C = false;
                    sibling.C = true;
                    RedBlackRotateRight(this, sibling);
                    sibling = parent.R;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.R.C = false;
                  RedBlackRotateLeft(this, parent);
                  node = this._;
                  break;
                }
              } else {
                sibling = parent.L;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  RedBlackRotateRight(this, parent);
                  sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.L || !sibling.L.C) {
                    sibling.R.C = false;
                    sibling.C = true;
                    RedBlackRotateLeft(this, sibling);
                    sibling = parent.L;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.L.C = false;
                  RedBlackRotateRight(this, parent);
                  node = this._;
                  break;
                }
              }
              sibling.C = true;
              node = parent;
              parent = parent.U;
            } while (!node.C);
            if (node)
              node.C = false;
          }
        };
        function RedBlackRotateLeft(tree, node) {
          var p = node, q = node.R, parent = p.U;
          if (parent) {
            if (parent.L === p)
              parent.L = q;
            else
              parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.R = q.L;
          if (p.R)
            p.R.U = p;
          q.L = p;
        }
        function RedBlackRotateRight(tree, node) {
          var p = node, q = node.L, parent = p.U;
          if (parent) {
            if (parent.L === p)
              parent.L = q;
            else
              parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.L = q.R;
          if (p.L)
            p.L.U = p;
          q.R = p;
        }
        function RedBlackFirst(node) {
          while (node.L)
            node = node.L;
          return node;
        }
        function createEdge(left, right, v0, v1) {
          var edge = [null, null], index = edges.push(edge) - 1;
          edge.left = left;
          edge.right = right;
          if (v0)
            setEdgeEnd(edge, left, right, v0);
          if (v1)
            setEdgeEnd(edge, right, left, v1);
          cells[left.index].halfedges.push(index);
          cells[right.index].halfedges.push(index);
          return edge;
        }
        function createBorderEdge(left, v0, v1) {
          var edge = [v0, v1];
          edge.left = left;
          return edge;
        }
        function setEdgeEnd(edge, left, right, vertex) {
          if (!edge[0] && !edge[1]) {
            edge[0] = vertex;
            edge.left = left;
            edge.right = right;
          } else if (edge.left === right) {
            edge[1] = vertex;
          } else {
            edge[0] = vertex;
          }
        }
        function clipEdge(edge, x0, y0, x1, y1) {
          var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
          r = x0 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (!(t0 > 0) && !(t1 < 1))
            return true;
          if (t0 > 0)
            edge[0] = [ax + t0 * dx, ay + t0 * dy];
          if (t1 < 1)
            edge[1] = [ax + t1 * dx, ay + t1 * dy];
          return true;
        }
        function connectEdge(edge, x0, y0, x1, y1) {
          var v1 = edge[1];
          if (v1)
            return true;
          var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
          if (ry === ly) {
            if (fx < x0 || fx >= x1)
              return;
            if (lx > rx) {
              if (!v0)
                v0 = [fx, y0];
              else if (v0[1] >= y1)
                return;
              v1 = [fx, y1];
            } else {
              if (!v0)
                v0 = [fx, y1];
              else if (v0[1] < y0)
                return;
              v1 = [fx, y0];
            }
          } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
              if (lx > rx) {
                if (!v0)
                  v0 = [(y0 - fb) / fm, y0];
                else if (v0[1] >= y1)
                  return;
                v1 = [(y1 - fb) / fm, y1];
              } else {
                if (!v0)
                  v0 = [(y1 - fb) / fm, y1];
                else if (v0[1] < y0)
                  return;
                v1 = [(y0 - fb) / fm, y0];
              }
            } else {
              if (ly < ry) {
                if (!v0)
                  v0 = [x0, fm * x0 + fb];
                else if (v0[0] >= x1)
                  return;
                v1 = [x1, fm * x1 + fb];
              } else {
                if (!v0)
                  v0 = [x1, fm * x1 + fb];
                else if (v0[0] < x0)
                  return;
                v1 = [x0, fm * x0 + fb];
              }
            }
          }
          edge[0] = v0;
          edge[1] = v1;
          return true;
        }
        function clipEdges(x0, y0, x1, y1) {
          var i = edges.length, edge;
          while (i--) {
            if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
              delete edges[i];
            }
          }
        }
        function createCell(site) {
          return cells[site.index] = {
            site,
            halfedges: []
          };
        }
        function cellHalfedgeAngle(cell, edge) {
          var site = cell.site, va = edge.left, vb = edge.right;
          if (site === vb)
            vb = va, va = site;
          if (vb)
            return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
          if (site === va)
            va = edge[1], vb = edge[0];
          else
            va = edge[0], vb = edge[1];
          return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
        }
        function cellHalfedgeStart(cell, edge) {
          return edge[+(edge.left !== cell.site)];
        }
        function cellHalfedgeEnd(cell, edge) {
          return edge[+(edge.left === cell.site)];
        }
        function sortCellHalfedges() {
          for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
            if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
              var index = new Array(m), array2 = new Array(m);
              for (j = 0; j < m; ++j)
                index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
              index.sort(function(i2, j2) {
                return array2[j2] - array2[i2];
              });
              for (j = 0; j < m; ++j)
                array2[j] = halfedges[index[j]];
              for (j = 0; j < m; ++j)
                halfedges[j] = array2[j];
            }
          }
        }
        function clipCells(x0, y0, x1, y1) {
          var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
          for (iCell = 0; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
              site = cell.site;
              halfedges = cell.halfedges;
              iHalfedge = halfedges.length;
              while (iHalfedge--) {
                if (!edges[halfedges[iHalfedge]]) {
                  halfedges.splice(iHalfedge, 1);
                }
              }
              iHalfedge = 0, nHalfedges = halfedges.length;
              while (iHalfedge < nHalfedges) {
                end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
                start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
                if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
                  halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
                    site,
                    end,
                    Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1] : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0] : null
                  )) - 1);
                  ++nHalfedges;
                }
              }
              if (nHalfedges)
                cover = false;
            }
          }
          if (cover) {
            var dx, dy, d2, dc = Infinity;
            for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
              if (cell = cells[iCell]) {
                site = cell.site;
                dx = site[0] - x0;
                dy = site[1] - y0;
                d2 = dx * dx + dy * dy;
                if (d2 < dc)
                  dc = d2, cover = cell;
              }
            }
            if (cover) {
              var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
              cover.halfedges.push(
                edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
                edges.push(createBorderEdge(site, v01, v11)) - 1,
                edges.push(createBorderEdge(site, v11, v10)) - 1,
                edges.push(createBorderEdge(site, v10, v00)) - 1
              );
            }
          }
          for (iCell = 0; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
              if (!cell.halfedges.length) {
                delete cells[iCell];
              }
            }
          }
        }
        var circlePool = [];
        var firstCircle;
        function Circle() {
          RedBlackNode(this);
          this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function attachCircle(arc) {
          var lArc = arc.P, rArc = arc.N;
          if (!lArc || !rArc)
            return;
          var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
          if (lSite === rSite)
            return;
          var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
          var d = 2 * (ax * cy - ay * cx);
          if (d >= -epsilon2)
            return;
          var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
          var circle = circlePool.pop() || new Circle();
          circle.arc = arc;
          circle.site = cSite;
          circle.x = x2 + bx;
          circle.y = (circle.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
          arc.circle = circle;
          var before = null, node = circles._;
          while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
              if (node.L)
                node = node.L;
              else {
                before = node.P;
                break;
              }
            } else {
              if (node.R)
                node = node.R;
              else {
                before = node;
                break;
              }
            }
          }
          circles.insert(before, circle);
          if (!before)
            firstCircle = circle;
        }
        function detachCircle(arc) {
          var circle = arc.circle;
          if (circle) {
            if (!circle.P)
              firstCircle = circle.N;
            circles.remove(circle);
            circlePool.push(circle);
            RedBlackNode(circle);
            arc.circle = null;
          }
        }
        var beachPool = [];
        function Beach() {
          RedBlackNode(this);
          this.edge = this.site = this.circle = null;
        }
        function createBeach(site) {
          var beach = beachPool.pop() || new Beach();
          beach.site = site;
          return beach;
        }
        function detachBeach(beach) {
          detachCircle(beach);
          beaches.remove(beach);
          beachPool.push(beach);
          RedBlackNode(beach);
        }
        function removeBeach(beach) {
          var circle = beach.circle, x2 = circle.x, y2 = circle.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
          detachBeach(beach);
          var lArc = previous;
          while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            detachBeach(lArc);
            lArc = previous;
          }
          disappearing.unshift(lArc);
          detachCircle(lArc);
          var rArc = next;
          while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
            next = rArc.N;
            disappearing.push(rArc);
            detachBeach(rArc);
            rArc = next;
          }
          disappearing.push(rArc);
          detachCircle(rArc);
          var nArcs = disappearing.length, iArc;
          for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
          }
          lArc = disappearing[0];
          rArc = disappearing[nArcs - 1];
          rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
          attachCircle(lArc);
          attachCircle(rArc);
        }
        function addBeach(site) {
          var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
          while (node) {
            dxl = leftBreakPoint(node, directrix) - x2;
            if (dxl > epsilon)
              node = node.L;
            else {
              dxr = x2 - rightBreakPoint(node, directrix);
              if (dxr > epsilon) {
                if (!node.R) {
                  lArc = node;
                  break;
                }
                node = node.R;
              } else {
                if (dxl > -epsilon) {
                  lArc = node.P;
                  rArc = node;
                } else if (dxr > -epsilon) {
                  lArc = node;
                  rArc = node.N;
                } else {
                  lArc = rArc = node;
                }
                break;
              }
            }
          }
          createCell(site);
          var newArc = createBeach(site);
          beaches.insert(lArc, newArc);
          if (!lArc && !rArc)
            return;
          if (lArc === rArc) {
            detachCircle(lArc);
            rArc = createBeach(lArc.site);
            beaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
            attachCircle(lArc);
            attachCircle(rArc);
            return;
          }
          if (!rArc) {
            newArc.edge = createEdge(lArc.site, newArc.site);
            return;
          }
          detachCircle(lArc);
          detachCircle(rArc);
          var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
          setEdgeEnd(rArc.edge, lSite, rSite, vertex);
          newArc.edge = createEdge(lSite, site, null, vertex);
          rArc.edge = createEdge(site, rSite, null, vertex);
          attachCircle(lArc);
          attachCircle(rArc);
        }
        function leftBreakPoint(arc, directrix) {
          var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
          if (!pby2)
            return rfocx;
          var lArc = arc.P;
          if (!lArc)
            return -Infinity;
          site = lArc.site;
          var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
          if (!plby2)
            return lfocx;
          var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
          if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
          return (rfocx + lfocx) / 2;
        }
        function rightBreakPoint(arc, directrix) {
          var rArc = arc.N;
          if (rArc)
            return leftBreakPoint(rArc, directrix);
          var site = arc.site;
          return site[1] === directrix ? site[0] : Infinity;
        }
        var epsilon = 1e-6;
        var epsilon2 = 1e-12;
        var beaches;
        var cells;
        var circles;
        var edges;
        function triangleArea(a, b, c) {
          return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
        }
        function lexicographic(a, b) {
          return b[1] - a[1] || b[0] - a[0];
        }
        function Diagram(sites, extent) {
          var site = sites.sort(lexicographic).pop(), x2, y2, circle;
          edges = [];
          cells = new Array(sites.length);
          beaches = new RedBlackTree();
          circles = new RedBlackTree();
          while (true) {
            circle = firstCircle;
            if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
              if (site[0] !== x2 || site[1] !== y2) {
                addBeach(site);
                x2 = site[0], y2 = site[1];
              }
              site = sites.pop();
            } else if (circle) {
              removeBeach(circle.arc);
            } else {
              break;
            }
          }
          sortCellHalfedges();
          if (extent) {
            var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
            clipEdges(x0, y0, x1, y1);
            clipCells(x0, y0, x1, y1);
          }
          this.edges = edges;
          this.cells = cells;
          beaches = circles = edges = cells = null;
        }
        Diagram.prototype = {
          constructor: Diagram,
          polygons: function() {
            var edges2 = this.edges;
            return this.cells.map(function(cell) {
              var polygon = cell.halfedges.map(function(i) {
                return cellHalfedgeStart(cell, edges2[i]);
              });
              polygon.data = cell.site.data;
              return polygon;
            });
          },
          triangles: function() {
            var triangles = [], edges2 = this.edges;
            this.cells.forEach(function(cell, i) {
              if (!(m = (halfedges = cell.halfedges).length))
                return;
              var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
              while (++j < m) {
                s0 = s1;
                e1 = edges2[halfedges[j]];
                s1 = e1.left === site ? e1.right : e1.left;
                if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                  triangles.push([site.data, s0.data, s1.data]);
                }
              }
            });
            return triangles;
          },
          links: function() {
            return this.edges.filter(function(edge) {
              return edge.right;
            }).map(function(edge) {
              return {
                source: edge.left.data,
                target: edge.right.data
              };
            });
          },
          find: function(x2, y2, radius) {
            var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
            while (!(cell = that.cells[i1]))
              if (++i1 >= n)
                return null;
            var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
            do {
              cell = that.cells[i0 = i1], i1 = null;
              cell.halfedges.forEach(function(e) {
                var edge = that.edges[e], v = edge.left;
                if ((v === cell.site || !v) && !(v = edge.right))
                  return;
                var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
                if (v2 < d2)
                  d2 = v2, i1 = v.index;
              });
            } while (i1 !== null);
            that._found = i0;
            return radius == null || d2 <= radius * radius ? cell.site : null;
          }
        };
        function voronoi() {
          var x$$1 = x, y$$1 = y, extent = null;
          function voronoi2(data) {
            return new Diagram(data.map(function(d, i) {
              var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
              s.index = i;
              s.data = d;
              return s;
            }), extent);
          }
          voronoi2.polygons = function(data) {
            return voronoi2(data).polygons();
          };
          voronoi2.links = function(data) {
            return voronoi2(data).links();
          };
          voronoi2.triangles = function(data) {
            return voronoi2(data).triangles();
          };
          voronoi2.x = function(_) {
            return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : x$$1;
          };
          voronoi2.y = function(_) {
            return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : y$$1;
          };
          voronoi2.extent = function(_) {
            return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi2) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
          };
          voronoi2.size = function(_) {
            return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi2) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
          };
          return voronoi2;
        }
        exports2.voronoi = voronoi;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3-zoom/dist/d3-zoom.js
  var require_d3_zoom = __commonJS({
    "node_modules/dagre-d3/node_modules/d3-zoom/dist/d3-zoom.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_dispatch(), require_d3_drag(), require_d3_interpolate(), require_d3_selection(), require_d3_transition()) : typeof define === "function" && define.amd ? define(["exports", "d3-dispatch", "d3-drag", "d3-interpolate", "d3-selection", "d3-transition"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3));
      })(exports, function(exports2, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) {
        "use strict";
        function constant(x) {
          return function() {
            return x;
          };
        }
        function ZoomEvent(target, type, transform2) {
          this.target = target;
          this.type = type;
          this.transform = transform2;
        }
        function Transform(k, x, y) {
          this.k = k;
          this.x = x;
          this.y = y;
        }
        Transform.prototype = {
          constructor: Transform,
          scale: function(k) {
            return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
          },
          translate: function(x, y) {
            return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
          },
          apply: function(point) {
            return [point[0] * this.k + this.x, point[1] * this.k + this.y];
          },
          applyX: function(x) {
            return x * this.k + this.x;
          },
          applyY: function(y) {
            return y * this.k + this.y;
          },
          invert: function(location2) {
            return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
          },
          invertX: function(x) {
            return (x - this.x) / this.k;
          },
          invertY: function(y) {
            return (y - this.y) / this.k;
          },
          rescaleX: function(x) {
            return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
          },
          rescaleY: function(y) {
            return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
          },
          toString: function() {
            return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
          }
        };
        var identity = new Transform(1, 0, 0);
        transform.prototype = Transform.prototype;
        function transform(node) {
          while (!node.__zoom)
            if (!(node = node.parentNode))
              return identity;
          return node.__zoom;
        }
        function nopropagation() {
          d3Selection.event.stopImmediatePropagation();
        }
        function noevent() {
          d3Selection.event.preventDefault();
          d3Selection.event.stopImmediatePropagation();
        }
        function defaultFilter() {
          return !d3Selection.event.ctrlKey && !d3Selection.event.button;
        }
        function defaultExtent() {
          var e = this;
          if (e instanceof SVGElement) {
            e = e.ownerSVGElement || e;
            if (e.hasAttribute("viewBox")) {
              e = e.viewBox.baseVal;
              return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
            }
            return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
          }
          return [[0, 0], [e.clientWidth, e.clientHeight]];
        }
        function defaultTransform() {
          return this.__zoom || identity;
        }
        function defaultWheelDelta() {
          return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 2e-3);
        }
        function defaultTouchable() {
          return navigator.maxTouchPoints || "ontouchstart" in this;
        }
        function defaultConstrain(transform2, extent, translateExtent) {
          var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
          return transform2.translate(
            dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
            dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
          );
        }
        function zoom() {
          var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = d3Interpolate.interpolateZoom, listeners = d3Dispatch.dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
          function zoom2(selection2) {
            selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
          }
          zoom2.transform = function(collection, transform2, point) {
            var selection2 = collection.selection ? collection.selection() : collection;
            selection2.property("__zoom", defaultTransform);
            if (collection !== selection2) {
              schedule(collection, transform2, point);
            } else {
              selection2.interrupt().each(function() {
                gesture(this, arguments).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
              });
            }
          };
          zoom2.scaleBy = function(selection2, k, p) {
            zoom2.scaleTo(selection2, function() {
              var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
              return k0 * k1;
            }, p);
          };
          zoom2.scaleTo = function(selection2, k, p) {
            zoom2.transform(selection2, function() {
              var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
              return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
            }, p);
          };
          zoom2.translateBy = function(selection2, x, y) {
            zoom2.transform(selection2, function() {
              return constrain(this.__zoom.translate(
                typeof x === "function" ? x.apply(this, arguments) : x,
                typeof y === "function" ? y.apply(this, arguments) : y
              ), extent.apply(this, arguments), translateExtent);
            });
          };
          zoom2.translateTo = function(selection2, x, y, p) {
            zoom2.transform(selection2, function() {
              var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
              return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
                typeof x === "function" ? -x.apply(this, arguments) : -x,
                typeof y === "function" ? -y.apply(this, arguments) : -y
              ), e, translateExtent);
            }, p);
          };
          function scale(transform2, k) {
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
            return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
          }
          function translate(transform2, p0, p1) {
            var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
            return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
          }
          function centroid(extent2) {
            return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
          }
          function schedule(transition, transform2, point) {
            transition.on("start.zoom", function() {
              gesture(this, arguments).start();
            }).on("interrupt.zoom end.zoom", function() {
              gesture(this, arguments).end();
            }).tween("zoom", function() {
              var that = this, args = arguments, g = gesture(that, args), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1)
                  t = b;
                else {
                  var l = i(t), k = w / l[2];
                  t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
                }
                g.zoom(null, t);
              };
            });
          }
          function gesture(that, args, clean) {
            return !clean && that.__zooming || new Gesture(that, args);
          }
          function Gesture(that, args) {
            this.that = that;
            this.args = args;
            this.active = 0;
            this.extent = extent.apply(that, args);
            this.taps = 0;
          }
          Gesture.prototype = {
            start: function() {
              if (++this.active === 1) {
                this.that.__zooming = this;
                this.emit("start");
              }
              return this;
            },
            zoom: function(key, transform2) {
              if (this.mouse && key !== "mouse")
                this.mouse[1] = transform2.invert(this.mouse[0]);
              if (this.touch0 && key !== "touch")
                this.touch0[1] = transform2.invert(this.touch0[0]);
              if (this.touch1 && key !== "touch")
                this.touch1[1] = transform2.invert(this.touch1[0]);
              this.that.__zoom = transform2;
              this.emit("zoom");
              return this;
            },
            end: function() {
              if (--this.active === 0) {
                delete this.that.__zooming;
                this.emit("end");
              }
              return this;
            },
            emit: function(type) {
              d3Selection.customEvent(new ZoomEvent(zoom2, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
            }
          };
          function wheeled() {
            if (!filter2.apply(this, arguments))
              return;
            var g = gesture(this, arguments), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = d3Selection.mouse(this);
            if (g.wheel) {
              if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
                g.mouse[1] = t.invert(g.mouse[0] = p);
              }
              clearTimeout(g.wheel);
            } else if (t.k === k)
              return;
            else {
              g.mouse = [p, t.invert(p)];
              d3Transition.interrupt(this);
              g.start();
            }
            noevent();
            g.wheel = setTimeout(wheelidled, wheelDelay);
            g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
            function wheelidled() {
              g.wheel = null;
              g.end();
            }
          }
          function mousedowned() {
            if (touchending || !filter2.apply(this, arguments))
              return;
            var g = gesture(this, arguments, true), v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = d3Selection.mouse(this), x0 = d3Selection.event.clientX, y0 = d3Selection.event.clientY;
            d3Drag.dragDisable(d3Selection.event.view);
            nopropagation();
            g.mouse = [p, this.__zoom.invert(p)];
            d3Transition.interrupt(this);
            g.start();
            function mousemoved() {
              noevent();
              if (!g.moved) {
                var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
                g.moved = dx * dx + dy * dy > clickDistance2;
              }
              g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
            }
            function mouseupped() {
              v.on("mousemove.zoom mouseup.zoom", null);
              d3Drag.dragEnable(d3Selection.event.view, g.moved);
              noevent();
              g.end();
            }
          }
          function dblclicked() {
            if (!filter2.apply(this, arguments))
              return;
            var t0 = this.__zoom, p0 = d3Selection.mouse(this), p1 = t0.invert(p0), k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
            noevent();
            if (duration > 0)
              d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
            else
              d3Selection.select(this).call(zoom2.transform, t1);
          }
          function touchstarted() {
            if (!filter2.apply(this, arguments))
              return;
            var touches = d3Selection.event.touches, n = touches.length, g = gesture(this, arguments, d3Selection.event.changedTouches.length === n), started, i, t, p;
            nopropagation();
            for (i = 0; i < n; ++i) {
              t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
              p = [p, this.__zoom.invert(p), t.identifier];
              if (!g.touch0)
                g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
              else if (!g.touch1 && g.touch0[2] !== p[2])
                g.touch1 = p, g.taps = 0;
            }
            if (touchstarting)
              touchstarting = clearTimeout(touchstarting);
            if (started) {
              if (g.taps < 2)
                touchstarting = setTimeout(function() {
                  touchstarting = null;
                }, touchDelay);
              d3Transition.interrupt(this);
              g.start();
            }
          }
          function touchmoved() {
            if (!this.__zooming)
              return;
            var g = gesture(this, arguments), touches = d3Selection.event.changedTouches, n = touches.length, i, t, p, l;
            noevent();
            if (touchstarting)
              touchstarting = clearTimeout(touchstarting);
            g.taps = 0;
            for (i = 0; i < n; ++i) {
              t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
              if (g.touch0 && g.touch0[2] === t.identifier)
                g.touch0[0] = p;
              else if (g.touch1 && g.touch1[2] === t.identifier)
                g.touch1[0] = p;
            }
            t = g.that.__zoom;
            if (g.touch1) {
              var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
              t = scale(t, Math.sqrt(dp / dl));
              p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
            } else if (g.touch0)
              p = g.touch0[0], l = g.touch0[1];
            else
              return;
            g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
          }
          function touchended() {
            if (!this.__zooming)
              return;
            var g = gesture(this, arguments), touches = d3Selection.event.changedTouches, n = touches.length, i, t;
            nopropagation();
            if (touchending)
              clearTimeout(touchending);
            touchending = setTimeout(function() {
              touchending = null;
            }, touchDelay);
            for (i = 0; i < n; ++i) {
              t = touches[i];
              if (g.touch0 && g.touch0[2] === t.identifier)
                delete g.touch0;
              else if (g.touch1 && g.touch1[2] === t.identifier)
                delete g.touch1;
            }
            if (g.touch1 && !g.touch0)
              g.touch0 = g.touch1, delete g.touch1;
            if (g.touch0)
              g.touch0[1] = this.__zoom.invert(g.touch0[0]);
            else {
              g.end();
              if (g.taps === 2) {
                var p = d3Selection.select(this).on("dblclick.zoom");
                if (p)
                  p.apply(this, arguments);
              }
            }
          }
          zoom2.wheelDelta = function(_) {
            return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom2) : wheelDelta;
          };
          zoom2.filter = function(_) {
            return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), zoom2) : filter2;
          };
          zoom2.touchable = function(_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom2) : touchable;
          };
          zoom2.extent = function(_) {
            return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
          };
          zoom2.scaleExtent = function(_) {
            return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
          };
          zoom2.translateExtent = function(_) {
            return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
          };
          zoom2.constrain = function(_) {
            return arguments.length ? (constrain = _, zoom2) : constrain;
          };
          zoom2.duration = function(_) {
            return arguments.length ? (duration = +_, zoom2) : duration;
          };
          zoom2.interpolate = function(_) {
            return arguments.length ? (interpolate = _, zoom2) : interpolate;
          };
          zoom2.on = function() {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? zoom2 : value;
          };
          zoom2.clickDistance = function(_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
          };
          return zoom2;
        }
        exports2.zoom = zoom;
        exports2.zoomIdentity = identity;
        exports2.zoomTransform = transform;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/dagre-d3/node_modules/d3/dist/d3.node.js
  var require_d3_node = __commonJS({
    "node_modules/dagre-d3/node_modules/d3/dist/d3.node.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var d3Array = require_d3_array();
      var d3Axis = require_d3_axis();
      var d3Brush = require_d3_brush();
      var d3Chord = require_d3_chord();
      var d3Collection = require_d3_collection();
      var d3Color = require_d3_color();
      var d3Contour = require_d3_contour();
      var d3Dispatch = require_d3_dispatch();
      var d3Drag = require_d3_drag();
      var d3Dsv = require_d3_dsv();
      var d3Ease = require_d3_ease();
      var d3Fetch = require_d3_fetch();
      var d3Force = require_d3_force();
      var d3Format = require_d3_format();
      var d3Geo = require_d3_geo();
      var d3Hierarchy = require_d3_hierarchy();
      var d3Interpolate = require_d3_interpolate();
      var d3Path = require_d3_path();
      var d3Polygon = require_d3_polygon();
      var d3Quadtree = require_d3_quadtree();
      var d3Random = require_d3_random();
      var d3Scale = require_d3_scale();
      var d3ScaleChromatic = require_d3_scale_chromatic();
      var d3Selection = require_d3_selection();
      var d3Shape = require_d3_shape();
      var d3Time = require_d3_time();
      var d3TimeFormat = require_d3_time_format();
      var d3Timer = require_d3_timer();
      var d3Transition = require_d3_transition();
      var d3Voronoi = require_d3_voronoi();
      var d3Zoom = require_d3_zoom();
      var version = "5.16.0";
      Object.keys(d3Array).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Array[k];
            }
          });
      });
      Object.keys(d3Axis).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Axis[k];
            }
          });
      });
      Object.keys(d3Brush).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Brush[k];
            }
          });
      });
      Object.keys(d3Chord).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Chord[k];
            }
          });
      });
      Object.keys(d3Collection).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Collection[k];
            }
          });
      });
      Object.keys(d3Color).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Color[k];
            }
          });
      });
      Object.keys(d3Contour).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Contour[k];
            }
          });
      });
      Object.keys(d3Dispatch).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Dispatch[k];
            }
          });
      });
      Object.keys(d3Drag).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Drag[k];
            }
          });
      });
      Object.keys(d3Dsv).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Dsv[k];
            }
          });
      });
      Object.keys(d3Ease).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Ease[k];
            }
          });
      });
      Object.keys(d3Fetch).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Fetch[k];
            }
          });
      });
      Object.keys(d3Force).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Force[k];
            }
          });
      });
      Object.keys(d3Format).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Format[k];
            }
          });
      });
      Object.keys(d3Geo).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Geo[k];
            }
          });
      });
      Object.keys(d3Hierarchy).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Hierarchy[k];
            }
          });
      });
      Object.keys(d3Interpolate).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Interpolate[k];
            }
          });
      });
      Object.keys(d3Path).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Path[k];
            }
          });
      });
      Object.keys(d3Polygon).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Polygon[k];
            }
          });
      });
      Object.keys(d3Quadtree).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Quadtree[k];
            }
          });
      });
      Object.keys(d3Random).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Random[k];
            }
          });
      });
      Object.keys(d3Scale).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Scale[k];
            }
          });
      });
      Object.keys(d3ScaleChromatic).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3ScaleChromatic[k];
            }
          });
      });
      Object.keys(d3Selection).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Selection[k];
            }
          });
      });
      Object.keys(d3Shape).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Shape[k];
            }
          });
      });
      Object.keys(d3Time).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Time[k];
            }
          });
      });
      Object.keys(d3TimeFormat).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3TimeFormat[k];
            }
          });
      });
      Object.keys(d3Timer).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Timer[k];
            }
          });
      });
      Object.keys(d3Transition).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Transition[k];
            }
          });
      });
      Object.keys(d3Voronoi).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Voronoi[k];
            }
          });
      });
      Object.keys(d3Zoom).forEach(function(k) {
        if (k !== "default")
          Object.defineProperty(exports, k, {
            enumerable: true,
            get: function() {
              return d3Zoom[k];
            }
          });
      });
      exports.version = version;
    }
  });

  // node_modules/dagre-d3/lib/d3.js
  var require_d3 = __commonJS({
    "node_modules/dagre-d3/lib/d3.js"(exports, module) {
      var d3;
      if (!d3) {
        if (typeof __require === "function") {
          try {
            d3 = require_d3_node();
          } catch (e) {
          }
        }
      }
      if (!d3) {
        d3 = window.d3;
      }
      module.exports = d3;
    }
  });

  // node_modules/dagre-d3/lib/util.js
  var require_util3 = __commonJS({
    "node_modules/dagre-d3/lib/util.js"(exports, module) {
      var _ = require_lodash5();
      module.exports = {
        isSubgraph,
        edgeToId,
        applyStyle,
        applyClass,
        applyTransition
      };
      function isSubgraph(g, v) {
        return !!g.children(v).length;
      }
      function edgeToId(e) {
        return escapeId(e.v) + ":" + escapeId(e.w) + ":" + escapeId(e.name);
      }
      var ID_DELIM = /:/g;
      function escapeId(str) {
        return str ? String(str).replace(ID_DELIM, "\\:") : "";
      }
      function applyStyle(dom, styleFn) {
        if (styleFn) {
          dom.attr("style", styleFn);
        }
      }
      function applyClass(dom, classFn, otherClasses) {
        if (classFn) {
          dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
        }
      }
      function applyTransition(selection2, g) {
        var graph = g.graph();
        if (_.isPlainObject(graph)) {
          var transition = graph.transition;
          if (_.isFunction(transition)) {
            return transition(selection2);
          }
        }
        return selection2;
      }
    }
  });

  // node_modules/dagre-d3/lib/label/add-text-label.js
  var require_add_text_label = __commonJS({
    "node_modules/dagre-d3/lib/label/add-text-label.js"(exports, module) {
      var util = require_util3();
      module.exports = addTextLabel;
      function addTextLabel(root2, node) {
        var domNode = root2.append("text");
        var lines = processEscapeSequences(node.label).split("\n");
        for (var i = 0; i < lines.length; i++) {
          domNode.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(lines[i]);
        }
        util.applyStyle(domNode, node.labelStyle);
        return domNode;
      }
      function processEscapeSequences(text) {
        var newText = "";
        var escaped = false;
        var ch;
        for (var i = 0; i < text.length; ++i) {
          ch = text[i];
          if (escaped) {
            switch (ch) {
              case "n":
                newText += "\n";
                break;
              default:
                newText += ch;
            }
            escaped = false;
          } else if (ch === "\\") {
            escaped = true;
          } else {
            newText += ch;
          }
        }
        return newText;
      }
    }
  });

  // node_modules/dagre-d3/lib/label/add-html-label.js
  var require_add_html_label = __commonJS({
    "node_modules/dagre-d3/lib/label/add-html-label.js"(exports, module) {
      var util = require_util3();
      module.exports = addHtmlLabel;
      function addHtmlLabel(root2, node) {
        var fo = root2.append("foreignObject").attr("width", "100000");
        var div = fo.append("xhtml:div");
        div.attr("xmlns", "http://www.w3.org/1999/xhtml");
        var label = node.label;
        switch (typeof label) {
          case "function":
            div.insert(label);
            break;
          case "object":
            div.insert(function() {
              return label;
            });
            break;
          default:
            div.html(label);
        }
        util.applyStyle(div, node.labelStyle);
        div.style("display", "inline-block");
        div.style("white-space", "nowrap");
        var client = div.node().getBoundingClientRect();
        fo.attr("width", client.width).attr("height", client.height);
        return fo;
      }
    }
  });

  // node_modules/dagre-d3/lib/label/add-svg-label.js
  var require_add_svg_label = __commonJS({
    "node_modules/dagre-d3/lib/label/add-svg-label.js"(exports, module) {
      var util = require_util3();
      module.exports = addSVGLabel;
      function addSVGLabel(root2, node) {
        var domNode = root2;
        domNode.node().appendChild(node.label);
        util.applyStyle(domNode, node.labelStyle);
        return domNode;
      }
    }
  });

  // node_modules/dagre-d3/lib/label/add-label.js
  var require_add_label = __commonJS({
    "node_modules/dagre-d3/lib/label/add-label.js"(exports, module) {
      var addTextLabel = require_add_text_label();
      var addHtmlLabel = require_add_html_label();
      var addSVGLabel = require_add_svg_label();
      module.exports = addLabel;
      function addLabel(root2, node, location2) {
        var label = node.label;
        var labelSvg = root2.append("g");
        if (node.labelType === "svg") {
          addSVGLabel(labelSvg, node);
        } else if (typeof label !== "string" || node.labelType === "html") {
          addHtmlLabel(labelSvg, node);
        } else {
          addTextLabel(labelSvg, node);
        }
        var labelBBox = labelSvg.node().getBBox();
        var y;
        switch (location2) {
          case "top":
            y = -node.height / 2;
            break;
          case "bottom":
            y = node.height / 2 - labelBBox.height;
            break;
          default:
            y = -labelBBox.height / 2;
        }
        labelSvg.attr(
          "transform",
          "translate(" + -labelBBox.width / 2 + "," + y + ")"
        );
        return labelSvg;
      }
    }
  });

  // node_modules/dagre-d3/lib/create-nodes.js
  var require_create_nodes = __commonJS({
    "node_modules/dagre-d3/lib/create-nodes.js"(exports, module) {
      "use strict";
      var _ = require_lodash5();
      var addLabel = require_add_label();
      var util = require_util3();
      var d3 = require_d3();
      module.exports = createNodes;
      function createNodes(selection2, g, shapes) {
        var simpleNodes = g.nodes().filter(function(v) {
          return !util.isSubgraph(g, v);
        });
        var svgNodes = selection2.selectAll("g.node").data(simpleNodes, function(v) {
          return v;
        }).classed("update", true);
        svgNodes.exit().remove();
        svgNodes.enter().append("g").attr("class", "node").style("opacity", 0);
        svgNodes = selection2.selectAll("g.node");
        svgNodes.each(function(v) {
          var node = g.node(v);
          var thisGroup = d3.select(this);
          util.applyClass(
            thisGroup,
            node["class"],
            (thisGroup.classed("update") ? "update " : "") + "node"
          );
          thisGroup.select("g.label").remove();
          var labelGroup = thisGroup.append("g").attr("class", "label");
          var labelDom = addLabel(labelGroup, node);
          var shape = shapes[node.shape];
          var bbox = _.pick(labelDom.node().getBBox(), "width", "height");
          node.elem = this;
          if (node.id) {
            thisGroup.attr("id", node.id);
          }
          if (node.labelId) {
            labelGroup.attr("id", node.labelId);
          }
          if (_.has(node, "width")) {
            bbox.width = node.width;
          }
          if (_.has(node, "height")) {
            bbox.height = node.height;
          }
          bbox.width += node.paddingLeft + node.paddingRight;
          bbox.height += node.paddingTop + node.paddingBottom;
          labelGroup.attr("transform", "translate(" + (node.paddingLeft - node.paddingRight) / 2 + "," + (node.paddingTop - node.paddingBottom) / 2 + ")");
          var root2 = d3.select(this);
          root2.select(".label-container").remove();
          var shapeSvg = shape(root2, bbox, node).classed("label-container", true);
          util.applyStyle(shapeSvg, node.style);
          var shapeBBox = shapeSvg.node().getBBox();
          node.width = shapeBBox.width;
          node.height = shapeBBox.height;
        });
        var exitSelection;
        if (svgNodes.exit) {
          exitSelection = svgNodes.exit();
        } else {
          exitSelection = svgNodes.selectAll(null);
        }
        util.applyTransition(exitSelection, g).style("opacity", 0).remove();
        return svgNodes;
      }
    }
  });

  // node_modules/dagre-d3/lib/create-clusters.js
  var require_create_clusters = __commonJS({
    "node_modules/dagre-d3/lib/create-clusters.js"(exports, module) {
      var util = require_util3();
      var d3 = require_d3();
      var addLabel = require_add_label();
      module.exports = createClusters;
      function createClusters(selection2, g) {
        var clusters = g.nodes().filter(function(v) {
          return util.isSubgraph(g, v);
        });
        var svgClusters = selection2.selectAll("g.cluster").data(clusters, function(v) {
          return v;
        });
        svgClusters.selectAll("*").remove();
        svgClusters.enter().append("g").attr("class", "cluster").attr("id", function(v) {
          var node = g.node(v);
          return node.id;
        }).style("opacity", 0);
        svgClusters = selection2.selectAll("g.cluster");
        util.applyTransition(svgClusters, g).style("opacity", 1);
        svgClusters.each(function(v) {
          var node = g.node(v);
          var thisGroup = d3.select(this);
          d3.select(this).append("rect");
          var labelGroup = thisGroup.append("g").attr("class", "label");
          addLabel(labelGroup, node, node.clusterLabelPos);
        });
        svgClusters.selectAll("rect").each(function(c) {
          var node = g.node(c);
          var domCluster = d3.select(this);
          util.applyStyle(domCluster, node.style);
        });
        var exitSelection;
        if (svgClusters.exit) {
          exitSelection = svgClusters.exit();
        } else {
          exitSelection = svgClusters.selectAll(null);
        }
        util.applyTransition(exitSelection, g).style("opacity", 0).remove();
        return svgClusters;
      }
    }
  });

  // node_modules/dagre-d3/lib/create-edge-labels.js
  var require_create_edge_labels = __commonJS({
    "node_modules/dagre-d3/lib/create-edge-labels.js"(exports, module) {
      "use strict";
      var _ = require_lodash5();
      var addLabel = require_add_label();
      var util = require_util3();
      var d3 = require_d3();
      module.exports = createEdgeLabels;
      function createEdgeLabels(selection2, g) {
        var svgEdgeLabels = selection2.selectAll("g.edgeLabel").data(g.edges(), function(e) {
          return util.edgeToId(e);
        }).classed("update", true);
        svgEdgeLabels.exit().remove();
        svgEdgeLabels.enter().append("g").classed("edgeLabel", true).style("opacity", 0);
        svgEdgeLabels = selection2.selectAll("g.edgeLabel");
        svgEdgeLabels.each(function(e) {
          var root2 = d3.select(this);
          root2.select(".label").remove();
          var edge = g.edge(e);
          var label = addLabel(root2, g.edge(e), 0, 0).classed("label", true);
          var bbox = label.node().getBBox();
          if (edge.labelId) {
            label.attr("id", edge.labelId);
          }
          if (!_.has(edge, "width")) {
            edge.width = bbox.width;
          }
          if (!_.has(edge, "height")) {
            edge.height = bbox.height;
          }
        });
        var exitSelection;
        if (svgEdgeLabels.exit) {
          exitSelection = svgEdgeLabels.exit();
        } else {
          exitSelection = svgEdgeLabels.selectAll(null);
        }
        util.applyTransition(exitSelection, g).style("opacity", 0).remove();
        return svgEdgeLabels;
      }
    }
  });

  // node_modules/dagre-d3/lib/create-edge-paths.js
  var require_create_edge_paths = __commonJS({
    "node_modules/dagre-d3/lib/create-edge-paths.js"(exports, module) {
      "use strict";
      var _ = require_lodash5();
      var intersectNode = require_intersect_node();
      var util = require_util3();
      var d3 = require_d3();
      module.exports = createEdgePaths;
      function createEdgePaths(selection2, g, arrows) {
        var previousPaths = selection2.selectAll("g.edgePath").data(g.edges(), function(e) {
          return util.edgeToId(e);
        }).classed("update", true);
        var newPaths = enter(previousPaths, g);
        exit(previousPaths, g);
        var svgPaths = previousPaths.merge !== void 0 ? previousPaths.merge(newPaths) : previousPaths;
        util.applyTransition(svgPaths, g).style("opacity", 1);
        svgPaths.each(function(e) {
          var domEdge = d3.select(this);
          var edge = g.edge(e);
          edge.elem = this;
          if (edge.id) {
            domEdge.attr("id", edge.id);
          }
          util.applyClass(
            domEdge,
            edge["class"],
            (domEdge.classed("update") ? "update " : "") + "edgePath"
          );
        });
        svgPaths.selectAll("path.path").each(function(e) {
          var edge = g.edge(e);
          edge.arrowheadId = _.uniqueId("arrowhead");
          var domEdge = d3.select(this).attr("marker-end", function() {
            return "url(" + makeFragmentRef(location.href, edge.arrowheadId) + ")";
          }).style("fill", "none");
          util.applyTransition(domEdge, g).attr("d", function(e2) {
            return calcPoints(g, e2);
          });
          util.applyStyle(domEdge, edge.style);
        });
        svgPaths.selectAll("defs *").remove();
        svgPaths.selectAll("defs").each(function(e) {
          var edge = g.edge(e);
          var arrowhead = arrows[edge.arrowhead];
          arrowhead(d3.select(this), edge.arrowheadId, edge, "arrowhead");
        });
        return svgPaths;
      }
      function makeFragmentRef(url, fragmentId) {
        var baseUrl = url.split("#")[0];
        return baseUrl + "#" + fragmentId;
      }
      function calcPoints(g, e) {
        var edge = g.edge(e);
        var tail = g.node(e.v);
        var head = g.node(e.w);
        var points = edge.points.slice(1, edge.points.length - 1);
        points.unshift(intersectNode(tail, points[0]));
        points.push(intersectNode(head, points[points.length - 1]));
        return createLine(edge, points);
      }
      function createLine(edge, points) {
        var line = (d3.line || d3.svg.line)().x(function(d) {
          return d.x;
        }).y(function(d) {
          return d.y;
        });
        (line.curve || line.interpolate)(edge.curve);
        return line(points);
      }
      function getCoords(elem) {
        var bbox = elem.getBBox();
        var matrix = elem.ownerSVGElement.getScreenCTM().inverse().multiply(elem.getScreenCTM()).translate(bbox.width / 2, bbox.height / 2);
        return { x: matrix.e, y: matrix.f };
      }
      function enter(svgPaths, g) {
        var svgPathsEnter = svgPaths.enter().append("g").attr("class", "edgePath").style("opacity", 0);
        svgPathsEnter.append("path").attr("class", "path").attr("d", function(e) {
          var edge = g.edge(e);
          var sourceElem = g.node(e.v).elem;
          var points = _.range(edge.points.length).map(function() {
            return getCoords(sourceElem);
          });
          return createLine(edge, points);
        });
        svgPathsEnter.append("defs");
        return svgPathsEnter;
      }
      function exit(svgPaths, g) {
        var svgPathExit = svgPaths.exit();
        util.applyTransition(svgPathExit, g).style("opacity", 0).remove();
      }
    }
  });

  // node_modules/dagre-d3/lib/position-nodes.js
  var require_position_nodes = __commonJS({
    "node_modules/dagre-d3/lib/position-nodes.js"(exports, module) {
      "use strict";
      var util = require_util3();
      var d3 = require_d3();
      module.exports = positionNodes;
      function positionNodes(selection2, g) {
        var created = selection2.filter(function() {
          return !d3.select(this).classed("update");
        });
        function translate(v) {
          var node = g.node(v);
          return "translate(" + node.x + "," + node.y + ")";
        }
        created.attr("transform", translate);
        util.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
      }
    }
  });

  // node_modules/dagre-d3/lib/position-edge-labels.js
  var require_position_edge_labels = __commonJS({
    "node_modules/dagre-d3/lib/position-edge-labels.js"(exports, module) {
      "use strict";
      var util = require_util3();
      var d3 = require_d3();
      var _ = require_lodash5();
      module.exports = positionEdgeLabels;
      function positionEdgeLabels(selection2, g) {
        var created = selection2.filter(function() {
          return !d3.select(this).classed("update");
        });
        function translate(e) {
          var edge = g.edge(e);
          return _.has(edge, "x") ? "translate(" + edge.x + "," + edge.y + ")" : "";
        }
        created.attr("transform", translate);
        util.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
      }
    }
  });

  // node_modules/dagre-d3/lib/position-clusters.js
  var require_position_clusters = __commonJS({
    "node_modules/dagre-d3/lib/position-clusters.js"(exports, module) {
      "use strict";
      var util = require_util3();
      var d3 = require_d3();
      module.exports = positionClusters;
      function positionClusters(selection2, g) {
        var created = selection2.filter(function() {
          return !d3.select(this).classed("update");
        });
        function translate(v) {
          var node = g.node(v);
          return "translate(" + node.x + "," + node.y + ")";
        }
        created.attr("transform", translate);
        util.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
        util.applyTransition(created.selectAll("rect"), g).attr("width", function(v) {
          return g.node(v).width;
        }).attr("height", function(v) {
          return g.node(v).height;
        }).attr("x", function(v) {
          var node = g.node(v);
          return -node.width / 2;
        }).attr("y", function(v) {
          var node = g.node(v);
          return -node.height / 2;
        });
      }
    }
  });

  // node_modules/dagre-d3/lib/shapes.js
  var require_shapes = __commonJS({
    "node_modules/dagre-d3/lib/shapes.js"(exports, module) {
      "use strict";
      var intersectRect = require_intersect_rect();
      var intersectEllipse = require_intersect_ellipse();
      var intersectCircle = require_intersect_circle();
      var intersectPolygon = require_intersect_polygon();
      module.exports = {
        rect,
        ellipse,
        circle,
        diamond
      };
      function rect(parent, bbox, node) {
        var shapeSvg = parent.insert("rect", ":first-child").attr("rx", node.rx).attr("ry", node.ry).attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("width", bbox.width).attr("height", bbox.height);
        node.intersect = function(point) {
          return intersectRect(node, point);
        };
        return shapeSvg;
      }
      function ellipse(parent, bbox, node) {
        var rx = bbox.width / 2;
        var ry = bbox.height / 2;
        var shapeSvg = parent.insert("ellipse", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("rx", rx).attr("ry", ry);
        node.intersect = function(point) {
          return intersectEllipse(node, rx, ry, point);
        };
        return shapeSvg;
      }
      function circle(parent, bbox, node) {
        var r = Math.max(bbox.width, bbox.height) / 2;
        var shapeSvg = parent.insert("circle", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("r", r);
        node.intersect = function(point) {
          return intersectCircle(node, r, point);
        };
        return shapeSvg;
      }
      function diamond(parent, bbox, node) {
        var w = bbox.width * Math.SQRT2 / 2;
        var h = bbox.height * Math.SQRT2 / 2;
        var points = [
          { x: 0, y: -h },
          { x: -w, y: 0 },
          { x: 0, y: h },
          { x: w, y: 0 }
        ];
        var shapeSvg = parent.insert("polygon", ":first-child").attr("points", points.map(function(p) {
          return p.x + "," + p.y;
        }).join(" "));
        node.intersect = function(p) {
          return intersectPolygon(node, points, p);
        };
        return shapeSvg;
      }
    }
  });

  // node_modules/dagre-d3/lib/arrows.js
  var require_arrows = __commonJS({
    "node_modules/dagre-d3/lib/arrows.js"(exports, module) {
      var util = require_util3();
      module.exports = {
        "default": normal,
        "normal": normal,
        "vee": vee,
        "undirected": undirected
      };
      function normal(parent, id, edge, type) {
        var marker = parent.append("marker").attr("id", id).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
        var path = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
        util.applyStyle(path, edge[type + "Style"]);
        if (edge[type + "Class"]) {
          path.attr("class", edge[type + "Class"]);
        }
      }
      function vee(parent, id, edge, type) {
        var marker = parent.append("marker").attr("id", id).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
        var path = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
        util.applyStyle(path, edge[type + "Style"]);
        if (edge[type + "Class"]) {
          path.attr("class", edge[type + "Class"]);
        }
      }
      function undirected(parent, id, edge, type) {
        var marker = parent.append("marker").attr("id", id).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
        var path = marker.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
        util.applyStyle(path, edge[type + "Style"]);
        if (edge[type + "Class"]) {
          path.attr("class", edge[type + "Class"]);
        }
      }
    }
  });

  // node_modules/dagre-d3/lib/render.js
  var require_render = __commonJS({
    "node_modules/dagre-d3/lib/render.js"(exports, module) {
      var _ = require_lodash5();
      var d3 = require_d3();
      var layout = require_dagre2().layout;
      module.exports = render2;
      function render2() {
        var createNodes = require_create_nodes();
        var createClusters = require_create_clusters();
        var createEdgeLabels = require_create_edge_labels();
        var createEdgePaths = require_create_edge_paths();
        var positionNodes = require_position_nodes();
        var positionEdgeLabels = require_position_edge_labels();
        var positionClusters = require_position_clusters();
        var shapes = require_shapes();
        var arrows = require_arrows();
        var fn = function(svg, g) {
          preProcessGraph(g);
          var outputGroup = createOrSelectGroup(svg, "output");
          var clustersGroup = createOrSelectGroup(outputGroup, "clusters");
          var edgePathsGroup = createOrSelectGroup(outputGroup, "edgePaths");
          var edgeLabels = createEdgeLabels(createOrSelectGroup(outputGroup, "edgeLabels"), g);
          var nodes = createNodes(createOrSelectGroup(outputGroup, "nodes"), g, shapes);
          layout(g);
          positionNodes(nodes, g);
          positionEdgeLabels(edgeLabels, g);
          createEdgePaths(edgePathsGroup, g, arrows);
          var clusters = createClusters(clustersGroup, g);
          positionClusters(clusters, g);
          postProcessGraph(g);
        };
        fn.createNodes = function(value) {
          if (!arguments.length)
            return createNodes;
          createNodes = value;
          return fn;
        };
        fn.createClusters = function(value) {
          if (!arguments.length)
            return createClusters;
          createClusters = value;
          return fn;
        };
        fn.createEdgeLabels = function(value) {
          if (!arguments.length)
            return createEdgeLabels;
          createEdgeLabels = value;
          return fn;
        };
        fn.createEdgePaths = function(value) {
          if (!arguments.length)
            return createEdgePaths;
          createEdgePaths = value;
          return fn;
        };
        fn.shapes = function(value) {
          if (!arguments.length)
            return shapes;
          shapes = value;
          return fn;
        };
        fn.arrows = function(value) {
          if (!arguments.length)
            return arrows;
          arrows = value;
          return fn;
        };
        return fn;
      }
      var NODE_DEFAULT_ATTRS = {
        paddingLeft: 10,
        paddingRight: 10,
        paddingTop: 10,
        paddingBottom: 10,
        rx: 0,
        ry: 0,
        shape: "rect"
      };
      var EDGE_DEFAULT_ATTRS = {
        arrowhead: "normal",
        curve: d3.curveLinear
      };
      function preProcessGraph(g) {
        g.nodes().forEach(function(v) {
          var node = g.node(v);
          if (!_.has(node, "label") && !g.children(v).length) {
            node.label = v;
          }
          if (_.has(node, "paddingX")) {
            _.defaults(node, {
              paddingLeft: node.paddingX,
              paddingRight: node.paddingX
            });
          }
          if (_.has(node, "paddingY")) {
            _.defaults(node, {
              paddingTop: node.paddingY,
              paddingBottom: node.paddingY
            });
          }
          if (_.has(node, "padding")) {
            _.defaults(node, {
              paddingLeft: node.padding,
              paddingRight: node.padding,
              paddingTop: node.padding,
              paddingBottom: node.padding
            });
          }
          _.defaults(node, NODE_DEFAULT_ATTRS);
          _.each(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(k) {
            node[k] = Number(node[k]);
          });
          if (_.has(node, "width")) {
            node._prevWidth = node.width;
          }
          if (_.has(node, "height")) {
            node._prevHeight = node.height;
          }
        });
        g.edges().forEach(function(e) {
          var edge = g.edge(e);
          if (!_.has(edge, "label")) {
            edge.label = "";
          }
          _.defaults(edge, EDGE_DEFAULT_ATTRS);
        });
      }
      function postProcessGraph(g) {
        _.each(g.nodes(), function(v) {
          var node = g.node(v);
          if (_.has(node, "_prevWidth")) {
            node.width = node._prevWidth;
          } else {
            delete node.width;
          }
          if (_.has(node, "_prevHeight")) {
            node.height = node._prevHeight;
          } else {
            delete node.height;
          }
          delete node._prevWidth;
          delete node._prevHeight;
        });
      }
      function createOrSelectGroup(root2, name) {
        var selection2 = root2.select("g." + name);
        if (selection2.empty()) {
          selection2 = root2.append("g").attr("class", name);
        }
        return selection2;
      }
    }
  });

  // node_modules/dagre-d3/lib/version.js
  var require_version4 = __commonJS({
    "node_modules/dagre-d3/lib/version.js"(exports, module) {
      module.exports = "0.6.4";
    }
  });

  // node_modules/dagre-d3/index.js
  var require_dagre_d3 = __commonJS({
    "node_modules/dagre-d3/index.js"(exports, module) {
      module.exports = {
        graphlib: require_graphlib3(),
        dagre: require_dagre2(),
        intersect: require_intersect(),
        render: require_render(),
        util: require_util3(),
        version: require_version4()
      };
    }
  });

  // node_modules/wheel/index.js
  var require_wheel = __commonJS({
    "node_modules/wheel/index.js"(exports, module) {
      module.exports = addWheelListener;
      module.exports.addWheelListener = addWheelListener;
      module.exports.removeWheelListener = removeWheelListener;
      function addWheelListener(element, listener, useCapture) {
        element.addEventListener("wheel", listener, useCapture);
      }
      function removeWheelListener(element, listener, useCapture) {
        element.removeEventListener("wheel", listener, useCapture);
      }
    }
  });

  // node_modules/bezier-easing/src/index.js
  var require_src = __commonJS({
    "node_modules/bezier-easing/src/index.js"(exports, module) {
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function LinearEasing(x) {
        return x;
      }
      module.exports = function bezier(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          throw new Error("bezier x values must be in [0, 1] range");
        }
        if (mX1 === mY1 && mX2 === mY2) {
          return LinearEasing;
        }
        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        for (var i = 0; i < kSplineTableSize; ++i) {
          sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function BezierEasing(x) {
          if (x === 0) {
            return 0;
          }
          if (x === 1) {
            return 1;
          }
          return calcBezier(getTForX(x), mY1, mY2);
        };
      };
    }
  });

  // node_modules/amator/index.js
  var require_amator = __commonJS({
    "node_modules/amator/index.js"(exports, module) {
      var BezierEasing = require_src();
      var animations = {
        ease: BezierEasing(0.25, 0.1, 0.25, 1),
        easeIn: BezierEasing(0.42, 0, 1, 1),
        easeOut: BezierEasing(0, 0, 0.58, 1),
        easeInOut: BezierEasing(0.42, 0, 0.58, 1),
        linear: BezierEasing(0, 0, 1, 1)
      };
      module.exports = animate;
      module.exports.makeAggregateRaf = makeAggregateRaf;
      module.exports.sharedScheduler = makeAggregateRaf();
      function animate(source, target, options) {
        var start = /* @__PURE__ */ Object.create(null);
        var diff = /* @__PURE__ */ Object.create(null);
        options = options || {};
        var easing = typeof options.easing === "function" ? options.easing : animations[options.easing];
        if (!easing) {
          if (options.easing) {
            console.warn("Unknown easing function in amator: " + options.easing);
          }
          easing = animations.ease;
        }
        var step = typeof options.step === "function" ? options.step : noop;
        var done = typeof options.done === "function" ? options.done : noop;
        var scheduler = getScheduler(options.scheduler);
        var keys = Object.keys(target);
        keys.forEach(function(key) {
          start[key] = source[key];
          diff[key] = target[key] - source[key];
        });
        var durationInMs = typeof options.duration === "number" ? options.duration : 400;
        var durationInFrames = Math.max(1, durationInMs * 0.06);
        var previousAnimationId;
        var frame = 0;
        previousAnimationId = scheduler.next(loop);
        return {
          cancel
        };
        function cancel() {
          scheduler.cancel(previousAnimationId);
          previousAnimationId = 0;
        }
        function loop() {
          var t = easing(frame / durationInFrames);
          frame += 1;
          setValues(t);
          if (frame <= durationInFrames) {
            previousAnimationId = scheduler.next(loop);
            step(source);
          } else {
            previousAnimationId = 0;
            setTimeout(function() {
              done(source);
            }, 0);
          }
        }
        function setValues(t) {
          keys.forEach(function(key) {
            source[key] = diff[key] * t + start[key];
          });
        }
      }
      function noop() {
      }
      function getScheduler(scheduler) {
        if (!scheduler) {
          var canRaf = typeof window !== "undefined" && window.requestAnimationFrame;
          return canRaf ? rafScheduler() : timeoutScheduler();
        }
        if (typeof scheduler.next !== "function")
          throw new Error("Scheduler is supposed to have next(cb) function");
        if (typeof scheduler.cancel !== "function")
          throw new Error("Scheduler is supposed to have cancel(handle) function");
        return scheduler;
      }
      function rafScheduler() {
        return {
          next: window.requestAnimationFrame.bind(window),
          cancel: window.cancelAnimationFrame.bind(window)
        };
      }
      function timeoutScheduler() {
        return {
          next: function(cb) {
            return setTimeout(cb, 1e3 / 60);
          },
          cancel: function(id) {
            return clearTimeout(id);
          }
        };
      }
      function makeAggregateRaf() {
        var frontBuffer = /* @__PURE__ */ new Set();
        var backBuffer = /* @__PURE__ */ new Set();
        var frameToken = 0;
        return {
          next,
          cancel: next,
          clearAll
        };
        function clearAll() {
          frontBuffer.clear();
          backBuffer.clear();
          cancelAnimationFrame(frameToken);
          frameToken = 0;
        }
        function next(callback) {
          backBuffer.add(callback);
          renderNextFrame();
        }
        function renderNextFrame() {
          if (!frameToken)
            frameToken = requestAnimationFrame(renderFrame);
        }
        function renderFrame() {
          frameToken = 0;
          var t = backBuffer;
          backBuffer = frontBuffer;
          frontBuffer = t;
          frontBuffer.forEach(function(callback) {
            callback();
          });
          frontBuffer.clear();
        }
        function cancel(callback) {
          backBuffer.delete(callback);
        }
      }
    }
  });

  // node_modules/ngraph.events/index.js
  var require_ngraph = __commonJS({
    "node_modules/ngraph.events/index.js"(exports, module) {
      module.exports = function eventify(subject) {
        validateSubject(subject);
        var eventsStorage = createEventsStorage(subject);
        subject.on = eventsStorage.on;
        subject.off = eventsStorage.off;
        subject.fire = eventsStorage.fire;
        return subject;
      };
      function createEventsStorage(subject) {
        var registeredEvents = /* @__PURE__ */ Object.create(null);
        return {
          on: function(eventName, callback, ctx) {
            if (typeof callback !== "function") {
              throw new Error("callback is expected to be a function");
            }
            var handlers = registeredEvents[eventName];
            if (!handlers) {
              handlers = registeredEvents[eventName] = [];
            }
            handlers.push({ callback, ctx });
            return subject;
          },
          off: function(eventName, callback) {
            var wantToRemoveAll = typeof eventName === "undefined";
            if (wantToRemoveAll) {
              registeredEvents = /* @__PURE__ */ Object.create(null);
              return subject;
            }
            if (registeredEvents[eventName]) {
              var deleteAllCallbacksForEvent = typeof callback !== "function";
              if (deleteAllCallbacksForEvent) {
                delete registeredEvents[eventName];
              } else {
                var callbacks = registeredEvents[eventName];
                for (var i = 0; i < callbacks.length; ++i) {
                  if (callbacks[i].callback === callback) {
                    callbacks.splice(i, 1);
                  }
                }
              }
            }
            return subject;
          },
          fire: function(eventName) {
            var callbacks = registeredEvents[eventName];
            if (!callbacks) {
              return subject;
            }
            var fireArguments;
            if (arguments.length > 1) {
              fireArguments = Array.prototype.splice.call(arguments, 1);
            }
            for (var i = 0; i < callbacks.length; ++i) {
              var callbackInfo = callbacks[i];
              callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
            }
            return subject;
          }
        };
      }
      function validateSubject(subject) {
        if (!subject) {
          throw new Error("Eventify cannot use falsy object as events subject");
        }
        var reservedWords = ["on", "fire", "off"];
        for (var i = 0; i < reservedWords.length; ++i) {
          if (subject.hasOwnProperty(reservedWords[i])) {
            throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
          }
        }
      }
    }
  });

  // node_modules/panzoom/lib/kinetic.js
  var require_kinetic = __commonJS({
    "node_modules/panzoom/lib/kinetic.js"(exports, module) {
      module.exports = kinetic;
      function kinetic(getPoint, scroll, settings) {
        if (typeof settings !== "object") {
          settings = {};
        }
        var minVelocity = typeof settings.minVelocity === "number" ? settings.minVelocity : 5;
        var amplitude = typeof settings.amplitude === "number" ? settings.amplitude : 0.25;
        var cancelAnimationFrame2 = typeof settings.cancelAnimationFrame === "function" ? settings.cancelAnimationFrame : getCancelAnimationFrame();
        var requestAnimationFrame2 = typeof settings.requestAnimationFrame === "function" ? settings.requestAnimationFrame : getRequestAnimationFrame();
        var lastPoint;
        var timestamp;
        var timeConstant = 342;
        var ticker;
        var vx, targetX, ax;
        var vy, targetY, ay;
        var raf;
        return {
          start,
          stop,
          cancel: dispose
        };
        function dispose() {
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
        }
        function start() {
          lastPoint = getPoint();
          ax = ay = vx = vy = 0;
          timestamp = new Date();
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
          ticker = requestAnimationFrame2(track);
        }
        function track() {
          var now = Date.now();
          var elapsed = now - timestamp;
          timestamp = now;
          var currentPoint = getPoint();
          var dx = currentPoint.x - lastPoint.x;
          var dy = currentPoint.y - lastPoint.y;
          lastPoint = currentPoint;
          var dt = 1e3 / (1 + elapsed);
          vx = 0.8 * dx * dt + 0.2 * vx;
          vy = 0.8 * dy * dt + 0.2 * vy;
          ticker = requestAnimationFrame2(track);
        }
        function stop() {
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
          var currentPoint = getPoint();
          targetX = currentPoint.x;
          targetY = currentPoint.y;
          timestamp = Date.now();
          if (vx < -minVelocity || vx > minVelocity) {
            ax = amplitude * vx;
            targetX += ax;
          }
          if (vy < -minVelocity || vy > minVelocity) {
            ay = amplitude * vy;
            targetY += ay;
          }
          raf = requestAnimationFrame2(autoScroll);
        }
        function autoScroll() {
          var elapsed = Date.now() - timestamp;
          var moving = false;
          var dx = 0;
          var dy = 0;
          if (ax) {
            dx = -ax * Math.exp(-elapsed / timeConstant);
            if (dx > 0.5 || dx < -0.5)
              moving = true;
            else
              dx = ax = 0;
          }
          if (ay) {
            dy = -ay * Math.exp(-elapsed / timeConstant);
            if (dy > 0.5 || dy < -0.5)
              moving = true;
            else
              dy = ay = 0;
          }
          if (moving) {
            scroll(targetX + dx, targetY + dy);
            raf = requestAnimationFrame2(autoScroll);
          }
        }
      }
      function getCancelAnimationFrame() {
        if (typeof cancelAnimationFrame === "function")
          return cancelAnimationFrame;
        return clearTimeout;
      }
      function getRequestAnimationFrame() {
        if (typeof requestAnimationFrame === "function")
          return requestAnimationFrame;
        return function(handler) {
          return setTimeout(handler, 16);
        };
      }
    }
  });

  // node_modules/panzoom/lib/createTextSelectionInterceptor.js
  var require_createTextSelectionInterceptor = __commonJS({
    "node_modules/panzoom/lib/createTextSelectionInterceptor.js"(exports, module) {
      module.exports = createTextSelectionInterceptor;
      function createTextSelectionInterceptor(useFake) {
        if (useFake) {
          return {
            capture: noop,
            release: noop
          };
        }
        var dragObject;
        var prevSelectStart;
        var prevDragStart;
        var wasCaptured = false;
        return {
          capture,
          release
        };
        function capture(domObject) {
          wasCaptured = true;
          prevSelectStart = window.document.onselectstart;
          prevDragStart = window.document.ondragstart;
          window.document.onselectstart = disabled;
          dragObject = domObject;
          dragObject.ondragstart = disabled;
        }
        function release() {
          if (!wasCaptured)
            return;
          wasCaptured = false;
          window.document.onselectstart = prevSelectStart;
          if (dragObject)
            dragObject.ondragstart = prevDragStart;
        }
      }
      function disabled(e) {
        e.stopPropagation();
        return false;
      }
      function noop() {
      }
    }
  });

  // node_modules/panzoom/lib/transform.js
  var require_transform2 = __commonJS({
    "node_modules/panzoom/lib/transform.js"(exports, module) {
      module.exports = Transform;
      function Transform() {
        this.x = 0;
        this.y = 0;
        this.scale = 1;
      }
    }
  });

  // node_modules/panzoom/lib/svgController.js
  var require_svgController = __commonJS({
    "node_modules/panzoom/lib/svgController.js"(exports, module) {
      module.exports = makeSvgController;
      module.exports.canAttach = isSVGElement;
      function makeSvgController(svgElement, options) {
        if (!isSVGElement(svgElement)) {
          throw new Error("svg element is required for svg.panzoom to work");
        }
        var owner = svgElement.ownerSVGElement;
        if (!owner) {
          throw new Error(
            "Do not apply panzoom to the root <svg> element. Use its child instead (e.g. <g></g>). As of March 2016 only FireFox supported transform on the root element"
          );
        }
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getScreenCTM,
          getOwner,
          applyTransform,
          initTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          var bbox = svgElement.getBBox();
          return {
            left: bbox.x,
            top: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        }
        function getScreenCTM() {
          var ctm = owner.getCTM();
          if (!ctm) {
            return owner.getScreenCTM();
          }
          return ctm;
        }
        function initTransform(transform) {
          var screenCTM = svgElement.getCTM();
          if (screenCTM === null) {
            screenCTM = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
          }
          transform.x = screenCTM.e;
          transform.y = screenCTM.f;
          transform.scale = screenCTM.a;
          owner.removeAttributeNS(null, "viewBox");
        }
        function applyTransform(transform) {
          svgElement.setAttribute("transform", "matrix(" + transform.scale + " 0 0 " + transform.scale + " " + transform.x + " " + transform.y + ")");
        }
      }
      function isSVGElement(element) {
        return element && element.ownerSVGElement && element.getCTM;
      }
    }
  });

  // node_modules/panzoom/lib/domController.js
  var require_domController = __commonJS({
    "node_modules/panzoom/lib/domController.js"(exports, module) {
      module.exports = makeDomController;
      module.exports.canAttach = isDomElement;
      function makeDomController(domElement, options) {
        var elementValid = isDomElement(domElement);
        if (!elementValid) {
          throw new Error("panzoom requires DOM element to be attached to the DOM tree");
        }
        var owner = domElement.parentElement;
        domElement.scrollTop = 0;
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getOwner,
          applyTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          return {
            left: 0,
            top: 0,
            width: domElement.clientWidth,
            height: domElement.clientHeight
          };
        }
        function applyTransform(transform) {
          domElement.style.transformOrigin = "0 0 0";
          domElement.style.transform = "matrix(" + transform.scale + ", 0, 0, " + transform.scale + ", " + transform.x + ", " + transform.y + ")";
        }
      }
      function isDomElement(element) {
        return element && element.parentElement && element.style;
      }
    }
  });

  // node_modules/panzoom/index.js
  var require_panzoom = __commonJS({
    "node_modules/panzoom/index.js"(exports, module) {
      "use strict";
      var wheel = require_wheel();
      var animate = require_amator();
      var eventify = require_ngraph();
      var kinetic = require_kinetic();
      var createTextSelectionInterceptor = require_createTextSelectionInterceptor();
      var domTextSelectionInterceptor = createTextSelectionInterceptor();
      var fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);
      var Transform = require_transform2();
      var makeSvgController = require_svgController();
      var makeDomController = require_domController();
      var defaultZoomSpeed = 1;
      var defaultDoubleTapZoomSpeed = 1.75;
      var doubleTapSpeedInMS = 300;
      var clickEventTimeInMS = 200;
      module.exports = createPanZoom;
      function createPanZoom(domElement, options) {
        options = options || {};
        var panController = options.controller;
        if (!panController) {
          if (makeSvgController.canAttach(domElement)) {
            panController = makeSvgController(domElement, options);
          } else if (makeDomController.canAttach(domElement)) {
            panController = makeDomController(domElement, options);
          }
        }
        if (!panController) {
          throw new Error(
            "Cannot create panzoom for the current type of dom element"
          );
        }
        var owner = panController.getOwner();
        var storedCTMResult = { x: 0, y: 0 };
        var isDirty = false;
        var transform = new Transform();
        if (panController.initTransform) {
          panController.initTransform(transform);
        }
        var filterKey = typeof options.filterKey === "function" ? options.filterKey : noop;
        var pinchSpeed = typeof options.pinchSpeed === "number" ? options.pinchSpeed : 1;
        var bounds = options.bounds;
        var maxZoom = typeof options.maxZoom === "number" ? options.maxZoom : Number.POSITIVE_INFINITY;
        var minZoom = typeof options.minZoom === "number" ? options.minZoom : 0;
        var boundsPadding = typeof options.boundsPadding === "number" ? options.boundsPadding : 0.05;
        var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === "number" ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;
        var beforeWheel = options.beforeWheel || noop;
        var beforeMouseDown = options.beforeMouseDown || noop;
        var speed = typeof options.zoomSpeed === "number" ? options.zoomSpeed : defaultZoomSpeed;
        var transformOrigin = parseTransformOrigin(options.transformOrigin);
        var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;
        validateBounds(bounds);
        if (options.autocenter) {
          autocenter();
        }
        var frameAnimation;
        var lastTouchEndTime = 0;
        var lastTouchStartTime = 0;
        var pendingClickEventTimeout = 0;
        var lastMouseDownedEvent = null;
        var lastMouseDownTime = new Date();
        var lastSingleFingerOffset;
        var touchInProgress = false;
        var panstartFired = false;
        var mouseX;
        var mouseY;
        var clickX;
        var clickY;
        var pinchZoomLength;
        var smoothScroll;
        if ("smoothScroll" in options && !options.smoothScroll) {
          smoothScroll = rigidScroll();
        } else {
          smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);
        }
        var moveByAnimation;
        var zoomToAnimation;
        var multiTouch;
        var paused = false;
        listenForEvents();
        var api = {
          dispose,
          moveBy: internalMoveBy,
          moveTo,
          smoothMoveTo,
          centerOn,
          zoomTo: publicZoomTo,
          zoomAbs,
          smoothZoom,
          smoothZoomAbs,
          showRectangle,
          pause,
          resume,
          isPaused,
          getTransform: getTransformModel,
          getMinZoom,
          setMinZoom,
          getMaxZoom,
          setMaxZoom,
          getTransformOrigin,
          setTransformOrigin,
          getZoomSpeed,
          setZoomSpeed
        };
        eventify(api);
        var initialX = typeof options.initialX === "number" ? options.initialX : transform.x;
        var initialY = typeof options.initialY === "number" ? options.initialY : transform.y;
        var initialZoom = typeof options.initialZoom === "number" ? options.initialZoom : transform.scale;
        if (initialX != transform.x || initialY != transform.y || initialZoom != transform.scale) {
          zoomAbs(initialX, initialY, initialZoom);
        }
        return api;
        function pause() {
          releaseEvents();
          paused = true;
        }
        function resume() {
          if (paused) {
            listenForEvents();
            paused = false;
          }
        }
        function isPaused() {
          return paused;
        }
        function showRectangle(rect) {
          var clientRect = owner.getBoundingClientRect();
          var size = transformToScreen(clientRect.width, clientRect.height);
          var rectWidth = rect.right - rect.left;
          var rectHeight = rect.bottom - rect.top;
          if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {
            throw new Error("Invalid rectangle");
          }
          var dw = size.x / rectWidth;
          var dh = size.y / rectHeight;
          var scale = Math.min(dw, dh);
          transform.x = -(rect.left + rectWidth / 2) * scale + size.x / 2;
          transform.y = -(rect.top + rectHeight / 2) * scale + size.y / 2;
          transform.scale = scale;
        }
        function transformToScreen(x, y) {
          if (panController.getScreenCTM) {
            var parentCTM = panController.getScreenCTM();
            var parentScaleX = parentCTM.a;
            var parentScaleY = parentCTM.d;
            var parentOffsetX = parentCTM.e;
            var parentOffsetY = parentCTM.f;
            storedCTMResult.x = x * parentScaleX - parentOffsetX;
            storedCTMResult.y = y * parentScaleY - parentOffsetY;
          } else {
            storedCTMResult.x = x;
            storedCTMResult.y = y;
          }
          return storedCTMResult;
        }
        function autocenter() {
          var w;
          var h;
          var left = 0;
          var top = 0;
          var sceneBoundingBox = getBoundingBox();
          if (sceneBoundingBox) {
            left = sceneBoundingBox.left;
            top = sceneBoundingBox.top;
            w = sceneBoundingBox.right - sceneBoundingBox.left;
            h = sceneBoundingBox.bottom - sceneBoundingBox.top;
          } else {
            var ownerRect = owner.getBoundingClientRect();
            w = ownerRect.width;
            h = ownerRect.height;
          }
          var bbox = panController.getBBox();
          if (bbox.width === 0 || bbox.height === 0) {
            return;
          }
          var dh = h / bbox.height;
          var dw = w / bbox.width;
          var scale = Math.min(dw, dh);
          transform.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;
          transform.y = -(bbox.top + bbox.height / 2) * scale + h / 2 + top;
          transform.scale = scale;
        }
        function getTransformModel() {
          return transform;
        }
        function getMinZoom() {
          return minZoom;
        }
        function setMinZoom(newMinZoom) {
          minZoom = newMinZoom;
        }
        function getMaxZoom() {
          return maxZoom;
        }
        function setMaxZoom(newMaxZoom) {
          maxZoom = newMaxZoom;
        }
        function getTransformOrigin() {
          return transformOrigin;
        }
        function setTransformOrigin(newTransformOrigin) {
          transformOrigin = parseTransformOrigin(newTransformOrigin);
        }
        function getZoomSpeed() {
          return speed;
        }
        function setZoomSpeed(newSpeed) {
          if (!Number.isFinite(newSpeed)) {
            throw new Error("Zoom speed should be a number");
          }
          speed = newSpeed;
        }
        function getPoint() {
          return {
            x: transform.x,
            y: transform.y
          };
        }
        function moveTo(x, y) {
          transform.x = x;
          transform.y = y;
          keepTransformInsideBounds();
          triggerEvent("pan");
          makeDirty();
        }
        function moveBy(dx, dy) {
          moveTo(transform.x + dx, transform.y + dy);
        }
        function keepTransformInsideBounds() {
          var boundingBox = getBoundingBox();
          if (!boundingBox)
            return;
          var adjusted = false;
          var clientRect = getClientRect();
          var diff = boundingBox.left - clientRect.right;
          if (diff > 0) {
            transform.x += diff;
            adjusted = true;
          }
          diff = boundingBox.right - clientRect.left;
          if (diff < 0) {
            transform.x += diff;
            adjusted = true;
          }
          diff = boundingBox.top - clientRect.bottom;
          if (diff > 0) {
            transform.y += diff;
            adjusted = true;
          }
          diff = boundingBox.bottom - clientRect.top;
          if (diff < 0) {
            transform.y += diff;
            adjusted = true;
          }
          return adjusted;
        }
        function getBoundingBox() {
          if (!bounds)
            return;
          if (typeof bounds === "boolean") {
            var ownerRect = owner.getBoundingClientRect();
            var sceneWidth = ownerRect.width;
            var sceneHeight = ownerRect.height;
            return {
              left: sceneWidth * boundsPadding,
              top: sceneHeight * boundsPadding,
              right: sceneWidth * (1 - boundsPadding),
              bottom: sceneHeight * (1 - boundsPadding)
            };
          }
          return bounds;
        }
        function getClientRect() {
          var bbox = panController.getBBox();
          var leftTop = client(bbox.left, bbox.top);
          return {
            left: leftTop.x,
            top: leftTop.y,
            right: bbox.width * transform.scale + leftTop.x,
            bottom: bbox.height * transform.scale + leftTop.y
          };
        }
        function client(x, y) {
          return {
            x: x * transform.scale + transform.x,
            y: y * transform.scale + transform.y
          };
        }
        function makeDirty() {
          isDirty = true;
          frameAnimation = window.requestAnimationFrame(frame);
        }
        function zoomByRatio(clientX, clientY, ratio) {
          if (isNaN2(clientX) || isNaN2(clientY) || isNaN2(ratio)) {
            throw new Error("zoom requires valid numbers");
          }
          var newScale = transform.scale * ratio;
          if (newScale < minZoom) {
            if (transform.scale === minZoom)
              return;
            ratio = minZoom / transform.scale;
          }
          if (newScale > maxZoom) {
            if (transform.scale === maxZoom)
              return;
            ratio = maxZoom / transform.scale;
          }
          var size = transformToScreen(clientX, clientY);
          transform.x = size.x - ratio * (size.x - transform.x);
          transform.y = size.y - ratio * (size.y - transform.y);
          if (bounds && boundsPadding === 1 && minZoom === 1) {
            transform.scale *= ratio;
            keepTransformInsideBounds();
          } else {
            var transformAdjusted = keepTransformInsideBounds();
            if (!transformAdjusted)
              transform.scale *= ratio;
          }
          triggerEvent("zoom");
          makeDirty();
        }
        function zoomAbs(clientX, clientY, zoomLevel) {
          var ratio = zoomLevel / transform.scale;
          zoomByRatio(clientX, clientY, ratio);
        }
        function centerOn(ui) {
          var parent = ui.ownerSVGElement;
          if (!parent)
            throw new Error("ui element is required to be within the scene");
          var clientRect = ui.getBoundingClientRect();
          var cx = clientRect.left + clientRect.width / 2;
          var cy = clientRect.top + clientRect.height / 2;
          var container = parent.getBoundingClientRect();
          var dx = container.width / 2 - cx;
          var dy = container.height / 2 - cy;
          internalMoveBy(dx, dy, true);
        }
        function smoothMoveTo(x, y) {
          internalMoveBy(x - transform.x, y - transform.y, true);
        }
        function internalMoveBy(dx, dy, smooth) {
          if (!smooth) {
            return moveBy(dx, dy);
          }
          if (moveByAnimation)
            moveByAnimation.cancel();
          var from = { x: 0, y: 0 };
          var to = { x: dx, y: dy };
          var lastX = 0;
          var lastY = 0;
          moveByAnimation = animate(from, to, {
            step: function(v) {
              moveBy(v.x - lastX, v.y - lastY);
              lastX = v.x;
              lastY = v.y;
            }
          });
        }
        function scroll(x, y) {
          cancelZoomAnimation();
          moveTo(x, y);
        }
        function dispose() {
          releaseEvents();
        }
        function listenForEvents() {
          owner.addEventListener("mousedown", onMouseDown, { passive: false });
          owner.addEventListener("dblclick", onDoubleClick, { passive: false });
          owner.addEventListener("touchstart", onTouch, { passive: false });
          owner.addEventListener("keydown", onKeyDown, { passive: false });
          wheel.addWheelListener(owner, onMouseWheel, { passive: false });
          makeDirty();
        }
        function releaseEvents() {
          wheel.removeWheelListener(owner, onMouseWheel);
          owner.removeEventListener("mousedown", onMouseDown);
          owner.removeEventListener("keydown", onKeyDown);
          owner.removeEventListener("dblclick", onDoubleClick);
          owner.removeEventListener("touchstart", onTouch);
          if (frameAnimation) {
            window.cancelAnimationFrame(frameAnimation);
            frameAnimation = 0;
          }
          smoothScroll.cancel();
          releaseDocumentMouse();
          releaseTouches();
          textSelection.release();
          triggerPanEnd();
        }
        function frame() {
          if (isDirty)
            applyTransform();
        }
        function applyTransform() {
          isDirty = false;
          panController.applyTransform(transform);
          triggerEvent("transform");
          frameAnimation = 0;
        }
        function onKeyDown(e) {
          var x = 0, y = 0, z = 0;
          if (e.keyCode === 38) {
            y = 1;
          } else if (e.keyCode === 40) {
            y = -1;
          } else if (e.keyCode === 37) {
            x = 1;
          } else if (e.keyCode === 39) {
            x = -1;
          } else if (e.keyCode === 189 || e.keyCode === 109) {
            z = 1;
          } else if (e.keyCode === 187 || e.keyCode === 107) {
            z = -1;
          }
          if (filterKey(e, x, y, z)) {
            return;
          }
          if (x || y) {
            e.preventDefault();
            e.stopPropagation();
            var clientRect = owner.getBoundingClientRect();
            var offset = Math.min(clientRect.width, clientRect.height);
            var moveSpeedRatio = 0.05;
            var dx = offset * moveSpeedRatio * x;
            var dy = offset * moveSpeedRatio * y;
            internalMoveBy(dx, dy);
          }
          if (z) {
            var scaleMultiplier = getScaleMultiplier(z * 100);
            var offset = transformOrigin ? getTransformOriginOffset() : midPoint();
            publicZoomTo(offset.x, offset.y, scaleMultiplier);
          }
        }
        function midPoint() {
          var ownerRect = owner.getBoundingClientRect();
          return {
            x: ownerRect.width / 2,
            y: ownerRect.height / 2
          };
        }
        function onTouch(e) {
          beforeTouch(e);
          clearPendingClickEventTimeout();
          if (e.touches.length === 1) {
            return handleSingleFingerTouch(e, e.touches[0]);
          } else if (e.touches.length === 2) {
            pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);
            multiTouch = true;
            startTouchListenerIfNeeded();
          }
        }
        function beforeTouch(e) {
          if (options.onTouch && !options.onTouch(e)) {
            return;
          }
          e.stopPropagation();
          e.preventDefault();
        }
        function beforeDoubleClick(e) {
          clearPendingClickEventTimeout();
          if (options.onDoubleClick && !options.onDoubleClick(e)) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        }
        function handleSingleFingerTouch(e) {
          lastTouchStartTime = new Date();
          var touch = e.touches[0];
          var offset = getOffsetXY(touch);
          lastSingleFingerOffset = offset;
          var point = transformToScreen(offset.x, offset.y);
          mouseX = point.x;
          mouseY = point.y;
          clickX = mouseX;
          clickY = mouseY;
          smoothScroll.cancel();
          startTouchListenerIfNeeded();
        }
        function startTouchListenerIfNeeded() {
          if (touchInProgress) {
            return;
          }
          touchInProgress = true;
          document.addEventListener("touchmove", handleTouchMove);
          document.addEventListener("touchend", handleTouchEnd);
          document.addEventListener("touchcancel", handleTouchEnd);
        }
        function handleTouchMove(e) {
          if (e.touches.length === 1) {
            e.stopPropagation();
            var touch = e.touches[0];
            var offset = getOffsetXY(touch);
            var point = transformToScreen(offset.x, offset.y);
            var dx = point.x - mouseX;
            var dy = point.y - mouseY;
            if (dx !== 0 && dy !== 0) {
              triggerPanStart();
            }
            mouseX = point.x;
            mouseY = point.y;
            internalMoveBy(dx, dy);
          } else if (e.touches.length === 2) {
            multiTouch = true;
            var t1 = e.touches[0];
            var t2 = e.touches[1];
            var currentPinchLength = getPinchZoomLength(t1, t2);
            var scaleMultiplier = 1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;
            var firstTouchPoint = getOffsetXY(t1);
            var secondTouchPoint = getOffsetXY(t2);
            mouseX = (firstTouchPoint.x + secondTouchPoint.x) / 2;
            mouseY = (firstTouchPoint.y + secondTouchPoint.y) / 2;
            if (transformOrigin) {
              var offset = getTransformOriginOffset();
              mouseX = offset.x;
              mouseY = offset.y;
            }
            publicZoomTo(mouseX, mouseY, scaleMultiplier);
            pinchZoomLength = currentPinchLength;
            e.stopPropagation();
            e.preventDefault();
          }
        }
        function clearPendingClickEventTimeout() {
          if (pendingClickEventTimeout) {
            clearTimeout(pendingClickEventTimeout);
            pendingClickEventTimeout = 0;
          }
        }
        function handlePotentialClickEvent(e) {
          if (!options.onClick)
            return;
          clearPendingClickEventTimeout();
          var dx = mouseX - clickX;
          var dy = mouseY - clickY;
          var l = Math.sqrt(dx * dx + dy * dy);
          if (l > 5)
            return;
          pendingClickEventTimeout = setTimeout(function() {
            pendingClickEventTimeout = 0;
            options.onClick(e);
          }, doubleTapSpeedInMS);
        }
        function handleTouchEnd(e) {
          clearPendingClickEventTimeout();
          if (e.touches.length > 0) {
            var offset = getOffsetXY(e.touches[0]);
            var point = transformToScreen(offset.x, offset.y);
            mouseX = point.x;
            mouseY = point.y;
          } else {
            var now = new Date();
            if (now - lastTouchEndTime < doubleTapSpeedInMS) {
              if (transformOrigin) {
                var offset = getTransformOriginOffset();
                smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
              } else {
                smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);
              }
            } else if (now - lastTouchStartTime < clickEventTimeInMS) {
              handlePotentialClickEvent(e);
            }
            lastTouchEndTime = now;
            triggerPanEnd();
            releaseTouches();
          }
        }
        function getPinchZoomLength(finger1, finger2) {
          var dx = finger1.clientX - finger2.clientX;
          var dy = finger1.clientY - finger2.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }
        function onDoubleClick(e) {
          beforeDoubleClick(e);
          var offset = getOffsetXY(e);
          if (transformOrigin) {
            offset = getTransformOriginOffset();
          }
          smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
        }
        function onMouseDown(e) {
          clearPendingClickEventTimeout();
          if (beforeMouseDown(e))
            return;
          lastMouseDownedEvent = e;
          lastMouseDownTime = new Date();
          if (touchInProgress) {
            e.stopPropagation();
            return false;
          }
          var isLeftButton = e.button === 1 && window.event !== null || e.button === 0;
          if (!isLeftButton)
            return;
          smoothScroll.cancel();
          var offset = getOffsetXY(e);
          var point = transformToScreen(offset.x, offset.y);
          clickX = mouseX = point.x;
          clickY = mouseY = point.y;
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          textSelection.capture(e.target || e.srcElement);
          return false;
        }
        function onMouseMove(e) {
          if (touchInProgress)
            return;
          triggerPanStart();
          var offset = getOffsetXY(e);
          var point = transformToScreen(offset.x, offset.y);
          var dx = point.x - mouseX;
          var dy = point.y - mouseY;
          mouseX = point.x;
          mouseY = point.y;
          internalMoveBy(dx, dy);
        }
        function onMouseUp() {
          var now = new Date();
          if (now - lastMouseDownTime < clickEventTimeInMS)
            handlePotentialClickEvent(lastMouseDownedEvent);
          textSelection.release();
          triggerPanEnd();
          releaseDocumentMouse();
        }
        function releaseDocumentMouse() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
          panstartFired = false;
        }
        function releaseTouches() {
          document.removeEventListener("touchmove", handleTouchMove);
          document.removeEventListener("touchend", handleTouchEnd);
          document.removeEventListener("touchcancel", handleTouchEnd);
          panstartFired = false;
          multiTouch = false;
          touchInProgress = false;
        }
        function onMouseWheel(e) {
          if (beforeWheel(e))
            return;
          smoothScroll.cancel();
          var delta = e.deltaY;
          if (e.deltaMode > 0)
            delta *= 100;
          var scaleMultiplier = getScaleMultiplier(delta);
          if (scaleMultiplier !== 1) {
            var offset = transformOrigin ? getTransformOriginOffset() : getOffsetXY(e);
            publicZoomTo(offset.x, offset.y, scaleMultiplier);
            e.preventDefault();
          }
        }
        function getOffsetXY(e) {
          var offsetX, offsetY;
          var ownerRect = owner.getBoundingClientRect();
          offsetX = e.clientX - ownerRect.left;
          offsetY = e.clientY - ownerRect.top;
          return { x: offsetX, y: offsetY };
        }
        function smoothZoom(clientX, clientY, scaleMultiplier) {
          var fromValue = transform.scale;
          var from = { scale: fromValue };
          var to = { scale: scaleMultiplier * fromValue };
          smoothScroll.cancel();
          cancelZoomAnimation();
          zoomToAnimation = animate(from, to, {
            step: function(v) {
              zoomAbs(clientX, clientY, v.scale);
            },
            done: triggerZoomEnd
          });
        }
        function smoothZoomAbs(clientX, clientY, toScaleValue) {
          var fromValue = transform.scale;
          var from = { scale: fromValue };
          var to = { scale: toScaleValue };
          smoothScroll.cancel();
          cancelZoomAnimation();
          zoomToAnimation = animate(from, to, {
            step: function(v) {
              zoomAbs(clientX, clientY, v.scale);
            }
          });
        }
        function getTransformOriginOffset() {
          var ownerRect = owner.getBoundingClientRect();
          return {
            x: ownerRect.width * transformOrigin.x,
            y: ownerRect.height * transformOrigin.y
          };
        }
        function publicZoomTo(clientX, clientY, scaleMultiplier) {
          smoothScroll.cancel();
          cancelZoomAnimation();
          return zoomByRatio(clientX, clientY, scaleMultiplier);
        }
        function cancelZoomAnimation() {
          if (zoomToAnimation) {
            zoomToAnimation.cancel();
            zoomToAnimation = null;
          }
        }
        function getScaleMultiplier(delta) {
          var sign = Math.sign(delta);
          var deltaAdjustedSpeed = Math.min(0.25, Math.abs(speed * delta / 128));
          return 1 - sign * deltaAdjustedSpeed;
        }
        function triggerPanStart() {
          if (!panstartFired) {
            triggerEvent("panstart");
            panstartFired = true;
            smoothScroll.start();
          }
        }
        function triggerPanEnd() {
          if (panstartFired) {
            if (!multiTouch)
              smoothScroll.stop();
            triggerEvent("panend");
          }
        }
        function triggerZoomEnd() {
          triggerEvent("zoomend");
        }
        function triggerEvent(name) {
          api.fire(name, api);
        }
      }
      function parseTransformOrigin(options) {
        if (!options)
          return;
        if (typeof options === "object") {
          if (!isNumber(options.x) || !isNumber(options.y))
            failTransformOrigin(options);
          return options;
        }
        failTransformOrigin();
      }
      function failTransformOrigin(options) {
        console.error(options);
        throw new Error(
          [
            "Cannot parse transform origin.",
            "Some good examples:",
            '  "center center" can be achieved with {x: 0.5, y: 0.5}',
            '  "top center" can be achieved with {x: 0.5, y: 0}',
            '  "bottom right" can be achieved with {x: 1, y: 1}'
          ].join("\n")
        );
      }
      function noop() {
      }
      function validateBounds(bounds) {
        var boundsType = typeof bounds;
        if (boundsType === "undefined" || boundsType === "boolean")
          return;
        var validBounds = isNumber(bounds.left) && isNumber(bounds.top) && isNumber(bounds.bottom) && isNumber(bounds.right);
        if (!validBounds)
          throw new Error(
            "Bounds object is not valid. It can be: undefined, boolean (true|false) or an object {left, top, right, bottom}"
          );
      }
      function isNumber(x) {
        return Number.isFinite(x);
      }
      function isNaN2(value) {
        if (Number.isNaN) {
          return Number.isNaN(value);
        }
        return value !== value;
      }
      function rigidScroll() {
        return {
          start: noop,
          stop: noop,
          cancel: noop
        };
      }
      function autoRun() {
        if (typeof document === "undefined")
          return;
        var scripts = document.getElementsByTagName("script");
        if (!scripts)
          return;
        var panzoomScript;
        for (var i = 0; i < scripts.length; ++i) {
          var x = scripts[i];
          if (x.src && x.src.match(/\bpanzoom(\.min)?\.js/)) {
            panzoomScript = x;
            break;
          }
        }
        if (!panzoomScript)
          return;
        var query = panzoomScript.getAttribute("query");
        if (!query)
          return;
        var globalName = panzoomScript.getAttribute("name") || "pz";
        var started = Date.now();
        tryAttach();
        function tryAttach() {
          var el = document.querySelector(query);
          if (!el) {
            var now = Date.now();
            var elapsed = now - started;
            if (elapsed < 2e3) {
              setTimeout(tryAttach, 100);
              return;
            }
            console.error("Cannot find the panzoom element", globalName);
            return;
          }
          var options = collectOptions(panzoomScript);
          console.log(options);
          window[globalName] = createPanZoom(el, options);
        }
        function collectOptions(script) {
          var attrs = script.attributes;
          var options = {};
          for (var j = 0; j < attrs.length; ++j) {
            var attr = attrs[j];
            var nameValue = getPanzoomAttributeNameValue(attr);
            if (nameValue) {
              options[nameValue.name] = nameValue.value;
            }
          }
          return options;
        }
        function getPanzoomAttributeNameValue(attr) {
          if (!attr.name)
            return;
          var isPanZoomAttribute = attr.name[0] === "p" && attr.name[1] === "z" && attr.name[2] === "-";
          if (!isPanZoomAttribute)
            return;
          var name = attr.name.substr(3);
          var value = JSON.parse(attr.value);
          return { name, value };
        }
      }
      autoRun();
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    AssemblyFunction: () => AssemblyFunction,
    Edge: () => Edge,
    Label: () => Label,
    Node: () => Node,
    buildGraph: () => buildGraph,
    isLabelLine: () => isLabelLine,
    isUnconditionalJump: () => isUnconditionalJump,
    makeInteractive: () => makeInteractive,
    parse: () => parse,
    parseClangGccAssembly: () => parseClangGccAssembly,
    parseMSVCAssembly: () => parseMSVCAssembly,
    renderDot: () => renderDot,
    renderGraphlib: () => renderGraphlib,
    renderSvg: () => renderSvg,
    renderSvgFromGraphlib: () => renderSvgFromGraphlib
  });

  // src/types.ts
  var Node = class {
    constructor(id, lineStart, label, lines = []) {
      this.id = id;
      this.lineStart = lineStart;
      this.label = label;
      this.lines = lines;
    }
  };
  var Edge = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var Label = class {
    constructor(label, node) {
      this.label = label;
      this.node = node;
    }
  };
  var AssemblyFunction = class {
    constructor(name, lineStart = 0, lineEnd = 0) {
      this.name = name;
      this.lineStart = lineStart;
      this.lineEnd = lineEnd;
      this.nextId = 0;
      this.labels = [];
      this.nodes = [];
      this.labeledNodes = /* @__PURE__ */ new Map();
      this.edges = [];
      this.rootNode = this.addNode(lineStart, name);
    }
    addNode(lineStart, label) {
      const node = new Node(this.nextId++, lineStart, label);
      this.nodes.push(node);
      if (label) {
        this.labels.push(new Label(label, node));
        this.labeledNodes.set(label, node);
      }
      return node;
    }
  };

  // src/graph.ts
  function buildGraph(lines, functions) {
    for (const func of functions) {
      let node = func.rootNode;
      for (let lineIndex = func.lineStart; lineIndex < func.lineEnd; lineIndex++) {
        const line = lines[lineIndex];
        if (isLabelLine(line)) {
          const label = line.substr(0, line.indexOf(":")).trim();
          let nextNode = func.labeledNodes.get(label);
          if (!nextNode)
            throw new Error(`Can not find node with label ${label}`);
          const lastLine = node.lines[node.lines.length - 1];
          if (node.lines.length > 1 && isUnconditionalJump(lastLine)) {
            if (lastLine.indexOf(label) > 0) {
              func.edges.push(new Edge(node.id, nextNode.id));
            }
          } else {
            func.edges.push(new Edge(node.id, nextNode.id));
          }
          node = nextNode;
          continue;
        }
        node.lines.push(line);
        let foundLabel = null;
        for (const label of func.labels) {
          if (line.indexOf(label.label) > 0) {
            if (foundLabel == null) {
              foundLabel = label;
            } else {
              if (label.label.length > foundLabel.label.length) {
                foundLabel = label;
              }
            }
          }
        }
        if (foundLabel) {
          func.edges.push({ from: node.id, to: foundLabel.node.id });
          if (lineIndex < func.lineEnd - 1 && !isLabelLine(lines[lineIndex + 1])) {
            let nextNode = func.addNode(lineIndex, null);
            func.edges.push(new Edge(node.id, nextNode.id));
            node = nextNode;
          }
        }
      }
    }
  }

  // src/parsers.ts
  function isLabelLine(line) {
    if (line.indexOf(":") > 0) {
      for (let i = 0; i < line.indexOf(":"); i++) {
        if (line.charAt(i) == " ")
          return false;
      }
      return true;
    }
  }
  function isUnconditionalJump(line) {
    line = line.trim();
    return line.indexOf("jmp ") == 0 || line.indexOf("b ") == 0;
  }
  function parse(assemblyCode) {
    const lines = assemblyCode.split(/\r?\n/);
    let functions;
    if (assemblyCode.indexOf("PROC") >= 0 && assemblyCode.indexOf("ENDP") >= 0) {
      functions = parseMSVCAssembly(lines);
    } else {
      functions = parseClangGccAssembly(lines);
    }
    buildGraph(lines, functions);
    return functions;
  }
  function parseMSVCAssembly(lines) {
    const functions = [];
    let func = null;
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      if (line.indexOf("PROC") > 0) {
        const functionName = line.substr(0, line.indexOf("PROC")).trim();
        func = new AssemblyFunction(functionName, lineIndex + 1);
        functions.push(func);
      } else if (line.indexOf(" ENDP") > 0) {
        if (!func)
          throw new Error("Found ENDP without corresponding PROC");
        func.lineEnd = lineIndex;
        func = null;
      } else if (isLabelLine(line)) {
        if (!func)
          throw new Error("Found a label outside of a function");
        const label = line.substr(0, line.indexOf(":")).trim();
        func.addNode(lineIndex, label);
      }
    }
    return functions;
  }
  function parseClangGccAssembly(lines) {
    const functions = [];
    let func = null;
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      if (isLabelLine(line)) {
        const label = line.substr(0, line.indexOf(":")).trim();
        if (label.charAt(0) == ".") {
          if (!func)
            throw new Error("Found label outside of a function");
          func.addNode(lineIndex, label);
        } else {
          if (func)
            func.lineEnd = lineIndex;
          func = new AssemblyFunction(label, lineIndex + 1);
          functions.push(func);
        }
      }
    }
    if (func && !func.lineEnd)
      func.lineEnd = lines.length;
    return functions;
  }

  // src/render.ts
  var graphlibDot = __toESM(require_graphlib_dot());
  var dagreD3 = __toESM(require_dagre_d3());

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
      name = name.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x) {
    return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function")
      select = arrayAll(select);
    else
      select = selectorAll_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update)
        update = update.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare)
      compare = ascending;
    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this)
      ++size;
    return size;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          callback.call(node, node.__data__, i, group);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name);
      else
        this.setAttribute(name, v);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name);
      else
        this.style.setProperty(name, v, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name];
      else
        this[name] = v;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.add(names[i]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0)
        name = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }
  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }
  function dispatch_default(type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default,
    [Symbol.iterator]: iterator_default
  };

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // src/render.ts
  function renderDot(func) {
    let dot = "digraph {\n";
    for (let i = 0; i < func.nodes.length; i++) {
      let node = func.nodes[i];
      let lines;
      let label = node.label;
      if (label) {
        label = label + "\\n";
        lines = node.lines.map((l) => l.trim()).map((l) => "   " + l).join("\\n");
      } else {
        label = "";
        lines = node.lines.map((l) => l.trim()).join("\\n");
      }
      lines = lines.split('"').join('\\"');
      dot += node.id + ' [label="' + label + lines + '\\n"]\n';
    }
    for (let i = 0; i < func.edges.length; i++) {
      let edge = func.edges[i];
      let from = func.nodes[edge.from];
      let to = func.nodes[edge.to];
      let attributes = "";
      if (to.label) {
        if (from.lines.length > 0 && from.lines[from.lines.length - 1].indexOf(to.label) >= 0)
          attributes = '[color="darkgreen"]';
        else
          attributes = '[color="#aa0000"]';
      } else {
        attributes = '[color="#aa0000"]';
      }
      attributes = "";
      dot += edge.from + " -> " + edge.to + attributes + "\n";
    }
    dot += "\n}";
    return dot;
  }
  function renderGraphlib(func) {
    return __async(this, null, function* () {
      const dot = renderDot(func);
      let graph = yield graphlibDot.read(dot);
      return graph;
    });
  }
  function renderSvg(func, svgElement) {
    return __async(this, null, function* () {
      let graph = yield renderGraphlib(func);
      var render2 = new dagreD3.render();
      select_default2(svgElement.querySelector("g")).call(render2, graph);
      return svgElement;
    });
  }
  function renderSvgFromGraphlib(graph, svgElement) {
    return __async(this, null, function* () {
      var render2 = new dagreD3.render();
      select_default2(svgElement.querySelector("g")).call(render2, graph);
      return svgElement;
    });
  }

  // src/input.ts
  var panzoom = __toESM(require_panzoom());
  function makeInteractive(element, func = null, clickCallback = () => {
  }) {
    if (element["_asmcfg_zoom"]) {
      let oldZoom = element["_asmcfg_zoom"];
      oldZoom.dispose();
    }
    let zoom = panzoom.default(element, {
      autocenter: true
    });
    element["_asmcfg_zoom"] = zoom;
    if (func && clickCallback) {
      let svgNodes = element.querySelectorAll(".node");
      for (let i = 0; i < svgNodes.length; i++) {
        let svgNode = svgNodes[i];
        let listener = () => {
          let nodeId = Number.parseInt(svgNode["__data__"]);
          let node = func.nodes[nodeId];
          let start = node.lineStart + 1;
          let end = start + node.lines.length;
          clickCallback(start, end, node, func);
        };
        svgNode.addEventListener("click", listener);
        svgNode.addEventListener("touchdown", listener);
      }
    }
  }
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=asmcfg.js.map
